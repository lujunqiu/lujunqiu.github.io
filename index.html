
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>Qiu‘s homepage</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Lujunqiu">
    

    
    <meta property="og:type" content="website">
<meta property="og:title" content="Qiu‘s homepage">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Qiu‘s homepage">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Qiu‘s homepage">

    
    <link rel="alternative" href="/atom.xml" title="Qiu‘s homepage" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="Qiu‘s homepage" title="Qiu‘s homepage"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Qiu‘s homepage">Qiu‘s homepage</a></h1>
				<h2 class="blog-motto">大道唯有自成。</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/09/16/Java多线程学习笔记-五/" title="Java多线程学习笔记(五)" itemprop="url">Java多线程学习笔记(五)</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lujunqiu" target="_blank" itemprop="author">Lujunqiu</a>
		
  <p class="article-time">
    <time datetime="2017-09-16T14:01:22.000Z" itemprop="datePublished"> Published 2017-09-16</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="Java内存模型基础"><a href="#Java内存模型基础" class="headerlink" title="Java内存模型基础"></a>Java内存模型基础</h1><p>在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。Java的并发采用的就是共享内存模型，线程之间共享程序的公共状态，通过写－读内存中的公共状态进行隐式通信。</p>
<p>Java线程之间的通信由Java内存模型(JMM)控制，JMM通过控制主内存与每个线程的本地内存之间的交互来决定了一个线程对共享变量的写入何时对另一个线程可见。</p>
<p>JMM定义了线程和主内存之间的抽象关系:线程之间的共享变量存储在主内存中,每个线程都有一个私有的本地内存,本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念,并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。但是这里需要说明的是，由于写缓存仅对自己的处理器可见，它会导致处理器执行内存操作的顺序与内存实际的操作顺序不一致，因为只有在JMM将缓存区数据刷新到内存中，才算完成了对内存的实际的操作。<br><img src="../../../../img/bingfa/3-1.png" alt=""></p>
<h1 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h1><p>重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。从Java源代码到最终实际执行的指令序列，会分别经历3种重排序。<br><img src="../../../../img/bingfa/3-3.png" alt=""></p>
<ol>
<li>编译器优化的重排序：编译器在不改变单线程程序语义的前提下,可以重新安排语句的执行顺序。</li>
<li>指令级并行的重排序：如果不存在数据依赖性,处理器可以改变语句对应机器指令的执行顺序，将多条指令重叠执行。</li>
<li>内存系统的重排序：使用了读／写缓存区，导致加载和存储的顺序改变。</li>
</ol>
<p>编译器和处理器在重排序的时候，会遵守数据依赖性(仅针对单个处理器和单个线程的操作指令)，也就是说不会改变存在数据依赖关系的两个操作的执行顺序。同样，为了提高并行度，编译器和处理器不管怎么重排序，单线程的执行结果不会改变，这就是内存模型中as-if-serial语义的内容。</p>
<p>但是在并发编程中，如果不理会这些重排序优化则很可能出现内存可见性问题。我们可以通过JMM来禁止特定类型的编译器重排序和处理器重排序(通过插入特定类型的内存屏障指令，实现对内存操作的顺序限制)，来保证多线程情况下的内存可见性。</p>
<p>这里我们补充说明一点，JMM不保证对64位的long型和double型变量的写操作具有原子性(分为2个32位的写总线事物)，但是在JDK5之后，保证其读操作是具有原子性的。</p>
<h1 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h1><p>happens-before：在JMM中，如果一个操作执行的结果需要对另一个操作操作可见，那么这两个操作之间必须要存在happens-before关系。</p>
<p>需要说明的是，上面提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间的，而且并不意味着前一个操作必须要在后一个操作之前执行，仅仅要求前一个操作(执行结果)对后一个操作可见。</p>
<p>happens-before规则如下:</p>
<ul>
<li>程序顺序规则：单个线程中的每个操作，happens-before于该线程中的任意后续操作</li>
<li>监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁</li>
<li>volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读</li>
<li>传递性：如果A happens-before B ，且B happens-before C，那么A happens-before C</li>
<li>join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回</li>
</ul>
<h1 id="volatile的内存语义"><a href="#volatile的内存语义" class="headerlink" title="volatile的内存语义"></a>volatile的内存语义</h1><p>volatile变量自身具有以下特性：</p>
<ul>
<li>可见性：对一个volatile变量的读，总是能看到(任意线程)对这个volatile变量最后的写入</li>
<li>原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性</li>
</ul>
<p>从内存语义的角度来说，volatile的写-读与锁的释放-获取有相同的内存效果：</p>
<ul>
<li>volatile写：当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存</li>
<li>volatile读：当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来将从主内存中读取共享变量</li>
</ul>
<p>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</p>
<p><img src="../../../../img/bingfa/3-16.png" alt=""></p>
<p>在上图中，黑色箭头表示happens－before的程序顺序规则，橙色箭头表示volatile规则，蓝色箭头表示happens－before关系的传递性。</p>
<p>另外，Java的CAS操作同时具有volatile读和volatile写的内存语义，是整个concurrent包得以实现的基石。</p>
<h1 id="锁的内存语义"><a href="#锁的内存语义" class="headerlink" title="锁的内存语义"></a>锁的内存语义</h1><p>锁是Java并发编程中最重要的同步机制，除了让临界区互斥执行外，还可以让释放锁的线程向获取同一个锁的线程发送消息。</p>
<p>从内存语义的角度来说：</p>
<ul>
<li>释放锁：先线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中</li>
<li>获取锁：JMM会把该线程对应的本地内存置为无效，从而使得被监视器保护的临界区代码必须从主内存中读取共享变量</li>
</ul>
<h1 id="final域的内存语义"><a href="#final域的内存语义" class="headerlink" title="final域的内存语义"></a>final域的内存语义</h1><p>对于final域，编译器和处理器要遵守两个重排序规则：</p>
<ol>
<li>在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序</li>
<li>初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序，确保在读一个对象域之间，一定会先读包含这个final域的对象引用</li>
</ol>
<p>从上面两个规则我们可以知道，写final域的重排序规则禁止把final域的写重排序到构造函数之外，编译器会在final域的写之后，构造函数return之前，插入一个StoreStore屏障。我们可以确保，在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域不具有这个保障。</p>
<p><img src="../../../../img/bingfa/3-29.png" alt=""></p>
<p>同时我们需要保证在构造函数内部，不能让这个被构造对象的引用为其他线程所见，也就是对象引用不能在构造函数中“逸出”。</p>
<p>于是JMM提供了初始化安全保证：只要对象是正确构造的(被构造对象的引用在构造函数中没有“逸出”)，那么不需要使用同步，就可以保证任意线程都能看到这个final域在构造函数中被初始化之后的值。</p>
<h1 id="双重检查锁定解决多线程中的单例"><a href="#双重检查锁定解决多线程中的单例" class="headerlink" title="双重检查锁定解决多线程中的单例"></a>双重检查锁定解决多线程中的单例</h1><p>在Java多线程程序中，有时候需要使用单例模式，并采用延迟初始化来降低初始化类和创建对象的开销，人们首先提出了双重锁定检查来降低使用synchronized来锁定方法的同步开销，示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> class <span class="title">DoubleCheckedLocking</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Instance instance;                  <span class="comment">//2</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span></span>&#123;              <span class="comment">//3</span></div><div class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;                          <span class="comment">//4:第一次检查</span></div><div class="line">            <span class="keyword">synchronized</span>(DoubleCheckedLocking.class)&#123;  <span class="comment">//5：加锁</span></div><div class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)                   <span class="comment">//6：第二次检查</span></div><div class="line">                    instance = <span class="keyword">new</span> Instance();         <span class="comment">//7</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先，上面的双重检查锁定代码示例是错误的，错误的地方在与第7行(instance = new Instance();)，这个语句可以分解为如下3行伪代码：</p>
<p>memory = allocate();  // 1:分配对象的内存空间<br>ctorInstance(memory);  // 2:初始化对象<br>instance = memory;   // 3:设置instance指向刚分配的内存地址</p>
<p>这里就有一个重排序的问题了，上面3行伪代码中的2和3之间,可能会被重排序，如果2,3被重排序了，在多线程环境中，就会有问题了。另外一个线程B在访问instance的时候，操作3已经执行了所有instance != null，但是操作2还未执行，这个时候线程B就去访问这个未被初始化的对象，于是出现了脏读的问题。</p>
<p>上述问题的解决方案也很简单，在JDK5增强了volatile的内存语义之后，我们只需一点小小的修改就行了，声明instance为volatile即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> class <span class="title">DoubleCheckedLocking</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Instance instance;                    </div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span></span>&#123;                </div><div class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;                            </div><div class="line">            <span class="keyword">synchronized</span>(DoubleCheckedLocking.class)&#123;    </div><div class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)                     </div><div class="line">                    instance = <span class="keyword">new</span> Instance();           </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="类初始化解决多线程中的单例"><a href="#类初始化解决多线程中的单例" class="headerlink" title="类初始化解决多线程中的单例"></a>类初始化解决多线程中的单例</h1><p>JVM在类初始化阶段(即在Class被加载后，且被线程使用之前)，会执行类的初始化。初始化一个类，包含执行这个类的静态初始化和初始化在这个类中声明的静态字段。JVM在执行类的初始化期间，会去获取一个锁，这个锁可以同步多个线程对同一个类的初始化。Java语言规范规定，对于每一个类或接口C，都有一个唯一的初始化锁LC与之对应。JVM在类初始化期间会获取这个初始化锁，确保每一个线程至少获取一次锁来确保这个类已经被初始化过了(获取Class对象锁之后，若类或者接口没有初始化则开始初始化，若已经被标记为初始化过了，则开始访问)。</p>
<p><img src="../../../../img/bingfa/3-40.png" alt=""></p>
<p>基于这个特性，可以实现另一种线程安全的延迟初始化方案：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceFactory</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceHolder</span></span>&#123;</div><div class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Instance instance = <span class="keyword">new</span> Instance();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> InstanceHolder.instance;   <span class="comment">//导致InstanceHolder类被初始化</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaSE/">JavaSE</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/多线程/">多线程</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/08/22/Java多线程学习笔记-四/" title="Java多线程学习笔记(四)" itemprop="url">Java多线程学习笔记(四)</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lujunqiu" target="_blank" itemprop="author">Lujunqiu</a>
		
  <p class="article-time">
    <time datetime="2017-08-22T06:17:38.000Z" itemprop="datePublished"> Published 2017-08-22</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="Lock的使用"><a href="#Lock的使用" class="headerlink" title="Lock的使用"></a>Lock的使用</h1><h2 id="使用ReentrantLock类"><a href="#使用ReentrantLock类" class="headerlink" title="使用ReentrantLock类"></a>使用ReentrantLock类</h2><p>在Java多线程中，可以使用synchronized关键字来实现线程之间同步互斥，但在JDK1.5中新增了ReentrantLock类也能达到同样的效果，并且在扩展功能上也更加强大，比如嗅探锁定，多路分支通知等功能，而且在使用上也比synchronized更加的灵活。</p>
<h3 id="使用ReentrantLock实现同步"><a href="#使用ReentrantLock实现同步" class="headerlink" title="使用ReentrantLock实现同步"></a>使用ReentrantLock实现同步</h3><p>ReentrantLock类的使用用例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            lock.lock();<span class="comment">//获取锁</span></div><div class="line">            System.out.println(<span class="string">"methodA begin ThreadName="</span> + Thread.currentThread().getName() + <span class="string">" time="</span> + System.currentTimeMillis());</div><div class="line">            Thread.sleep(<span class="number">5000</span>);</div><div class="line">            System.out.println(<span class="string">"methodA end ThreadName="</span> + Thread.currentThread().getName() + <span class="string">" time="</span> + System.currentTimeMillis());</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            lock.unlock();<span class="comment">//释放锁</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            lock.lock();</div><div class="line">            System.out.println(<span class="string">"methodB begin ThreadName="</span> + Thread.currentThread().getName() + <span class="string">" time="</span> + System.currentTimeMillis());</div><div class="line">            Thread.sleep(<span class="number">5000</span>);</div><div class="line">            System.out.println(<span class="string">"methodB end ThreadName="</span> + Thread.currentThread().getName() + <span class="string">" time="</span> + System.currentTimeMillis());</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        MyService service = <span class="keyword">new</span> MyService();</div><div class="line">        ThreadA a = <span class="keyword">new</span> ThreadA(service);</div><div class="line">        a.setName(<span class="string">"A"</span>);</div><div class="line">        a.start();</div><div class="line">        ThreadB b = <span class="keyword">new</span> ThreadB(service);</div><div class="line">        b.setName(<span class="string">"B"</span>);</div><div class="line">        b.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：<br>methodA begin ThreadName=A time=1503279665595<br>methodA end ThreadName=A time=1503279670595<br>methodB begin ThreadName=B time=1503279670596<br>methodB end ThreadName=B time=1503279675596</p>
<h3 id="使用Condition实现等待-通知"><a href="#使用Condition实现等待-通知" class="headerlink" title="使用Condition实现等待/通知"></a>使用Condition实现等待/通知</h3><p>在使用notify()/notifyAll()方法进行通知时，被通知的线程却是由JVM随机选择的。但使用ReentrantLock结合Condition类是可以实现选择性通知的，也就是在一个Lock对象里面可以创建多个Condition(即对象监视器)实例，线程对象可以注册在指定的Condition中，从而可以有选择性地进行线程通知，在调度线程上更加灵活。</p>
<p>而synchronized就相当于整个Lock对象中只有一个单一的Condition对象，所有的线程都注册在它的一个对象上。线程开始notifyAll()时，需要通知所有的WAITING对象，没有选择权，会出现相当大的效率问题。</p>
<p>使用多个Condition实现通知部分线程代码实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line">    <span class="keyword">public</span> Condition conditionA = lock.newCondition();</div><div class="line">    <span class="keyword">public</span> Condition conditionB = lock.newCondition();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">awaitA</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            lock.lock();</div><div class="line">            System.out.println(<span class="string">"begin awaitA 时间为"</span> + System.currentTimeMillis() + <span class="string">"ThreadName="</span> + Thread.currentThread().getName());</div><div class="line">            conditionA.await();</div><div class="line">            System.out.println(<span class="string">"end awaitA　时间为"</span> + System.currentTimeMillis() + <span class="string">"ThreadName="</span> + Thread.currentThread().getName());</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">awaitB</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            lock.lock();</div><div class="line">            System.out.println(<span class="string">"begin awaitB 时间为"</span> + System.currentTimeMillis() + <span class="string">"ThreadName="</span> + Thread.currentThread().getName());</div><div class="line">            conditionB.await();</div><div class="line">            System.out.println(<span class="string">"end awaitB　时间为"</span> + System.currentTimeMillis() + <span class="string">"ThreadName="</span> + Thread.currentThread().getName());</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signalAll_A</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            lock.lock();</div><div class="line">            System.out.println(<span class="string">"signalAll_A　时间为"</span> + System.currentTimeMillis() + <span class="string">"ThreadName="</span> + Thread.currentThread().getName());</div><div class="line">            conditionA.signalAll();</div><div class="line">        &#125;<span class="keyword">finally</span> &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signalAll_B</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            lock.lock();</div><div class="line">            System.out.println(<span class="string">"signalAll_B　时间为"</span> + System.currentTimeMillis() + <span class="string">"ThreadName="</span> + Thread.currentThread().getName());</div><div class="line">            conditionB.signalAll();</div><div class="line">        &#125;<span class="keyword">finally</span> &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        MyService service = <span class="keyword">new</span> MyService();</div><div class="line">        ThreadA a = <span class="keyword">new</span> ThreadA(service);</div><div class="line">        a.setName(<span class="string">"A"</span>);</div><div class="line">        a.start();</div><div class="line">        ThreadB b = <span class="keyword">new</span> ThreadB(service);</div><div class="line">        b.setName(<span class="string">"B"</span>);</div><div class="line">        b.start();</div><div class="line">        Thread.sleep(<span class="number">3000</span>);</div><div class="line">        service.signalAll_A();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> MyService service;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadA</span><span class="params">(MyService service)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.service = service;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        service.awaitA();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadB</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> MyService service;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadB</span><span class="params">(MyService service)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.service = service;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        service.awaitB();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：<br>begin awaitA 时间为1503282953886ThreadName=A<br>begin awaitB 时间为1503282953889ThreadName=B<br>signalAll_A　时间为1503282956889ThreadName=main<br>end awaitA　时间为1503282956890ThreadName=A</p>
<p>我们成功实现等待/通知模式:<br>Object类中的wait()方法相当于Condition类中的await()方法。<br>Object类中的notify()方法相当于Condition类中的signal()方法。<br>Object类中的notifyAll()方法相当于Condition类中的signalAll()方法。</p>
<h3 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h3><p>公平与非公平锁：锁Lock分为”公平锁”和”非公平锁”，公平锁表示线程获取锁的顺序是按照线程加锁的顺序来分配的，即先来先得的FIFO先进先出顺序。而非公平锁就是一种获取锁的抢占机制，是随机获得锁的，和公平锁不一样的就是先来的不一定先得到锁，这个方式可能造成某些线程一直拿不到锁，结果就是不公平的了。默认情况下，ReentrantLock类使用的是非公平锁。</p>
<p>代码实例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Lock lock;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">(<span class="keyword">boolean</span> isFair)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.lock = <span class="keyword">new</span> ReentrantLock(isFair);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            lock.lock();</div><div class="line">            System.out.println(<span class="string">"Thread Name="</span> + Thread.currentThread().getName() + <span class="string">"获得锁定"</span>);</div><div class="line">        &#125;<span class="keyword">finally</span> &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        MyService service = <span class="keyword">new</span> MyService(<span class="keyword">true</span>);<span class="comment">//公平锁</span></div><div class="line"><span class="comment">//        MyService service = new MyService(false);//非公平锁</span></div><div class="line">        Thread[] threads = <span class="keyword">new</span> Thread[<span class="number">10</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">            threads[i] = <span class="keyword">new</span> ThreadA(service);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">            threads[i].start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> MyService service;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadA</span><span class="params">(MyService service)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.service = service;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"*线程"</span> + Thread.currentThread().getName() + <span class="string">"运行了"</span>);</div><div class="line">        service.service();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="其他方法接口"><a href="#其他方法接口" class="headerlink" title="其他方法接口"></a>其他方法接口</h3><p>关于ReentrantLock类的使用，有很多辅助方法接口，我们在实际编程使用的时候以Java官方的API为主，这里列举一些简单的方法。</p>
<ol>
<li>方法　int getHoldCount() 的作用是查询当前线程保持此锁定的个数，也就是调用lock()方法的次数。</li>
<li>方法　int getQueueLength()的作用是返回正等待获取此锁定的线程估计数。</li>
<li>方法　int getWaitQueueLength(Condition condition)的作用是返回等待与此锁定相关的给定条件Condition的线程估计数。</li>
<li>方法　boolean hasQueuedThread(Thread thread)的作用是查询指定的线程是否正在等待获取此锁定。</li>
<li>方法　boolean hasWaiters(Condition condition)的作用是查询是否有线程正在等待与此锁定有关的condition条件。</li>
<li>方法　boolean isFair()的作用是判断是不是公平锁。</li>
<li>方法　boolean isHeldByCurrentThread()的作用是查询当前线程是否保持此锁定。</li>
<li>方法　boolean isLocked(0的作用是查询此锁定是否由任意线程保持。</li>
</ol>
<h2 id="使用ReentrantReadWriteLock类"><a href="#使用ReentrantReadWriteLock类" class="headerlink" title="使用ReentrantReadWriteLock类"></a>使用ReentrantReadWriteLock类</h2><p>类ReentrantLock具有完全互斥排他的效果，即同一时间只有一个线程在执行ReentrantLock.lock()方法后面的任务。这样做虽然保证了实例变量的线程安全性，但效率却是非常低下的。所以在JDK中提供了一种读写锁ReentrantReadWriteLock类，使用它可以加快运行效率。</p>
<p>读写锁表示也有两个锁，一个是读操作相关的锁，也称为共享锁；另一个是写操作相关的锁，也叫排他锁。也就是多个读锁之间不互斥，读锁与写锁互斥，写锁与写锁互斥。在没有线程Thread进行写入操作时，进行读取操作的多个Thread都可以获取读锁，而进行写入操作的线程Thread只有在获取写锁后才能进行写入操作。即多个Thread可以同时进行读取操作，但是同一时刻只允许一个Thread进行写入操作。</p>
<p>代码实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            lock.readLock().lock();</div><div class="line">            System.out.println(<span class="string">"获得读锁="</span> + System.currentTimeMillis() );</div><div class="line">        &#125;<span class="keyword">finally</span> &#123;</div><div class="line">            lock.readLock().unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            lock.writeLock().lock();</div><div class="line">            System.out.println(<span class="string">"获得写锁="</span> + System.currentTimeMillis());</div><div class="line">        &#125;<span class="keyword">finally</span> &#123;</div><div class="line">            lock.writeLock().unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        MyService service = <span class="keyword">new</span> MyService();</div><div class="line">        ThreadA threadA = <span class="keyword">new</span> ThreadA(service);</div><div class="line">        ThreadA threadB = <span class="keyword">new</span> ThreadA(service);</div><div class="line">        </div><div class="line">        threadA.start();</div><div class="line">        threadB.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> MyService service;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadA</span><span class="params">(MyService service)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.service = service;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        service.read();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadB</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> MyService service;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadB</span><span class="params">(MyService service)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.service = service;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        service.write();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaSE/">JavaSE</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/多线程/">多线程</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/07/30/Java多线程学习笔记-三/" title="Java多线程学习笔记(三)" itemprop="url">Java多线程学习笔记(三)</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lujunqiu" target="_blank" itemprop="author">Lujunqiu</a>
		
  <p class="article-time">
    <time datetime="2017-07-30T14:09:52.000Z" itemprop="datePublished"> Published 2017-07-30</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h1><p>线程是操作系统中独立的个体，但这些个体如果不经过特殊处理就不能成为一个整体。在线程间进行通信后，系统之间的交互性会更加强大，在大大提高CPU利用率的同时还会使程序员对各线程任务在处理的过程中进行有效的把控与监督。</p>
<h2 id="等待／通知机制"><a href="#等待／通知机制" class="headerlink" title="等待／通知机制"></a>等待／通知机制</h2><p>wait():使当前执行代码的线程进行等待,该方法是Object类的方法，可以将当前线程置入”预执行队列”中，并且在wait()所在的代码行停止执行，直到接到通知或被中断为止。在调用wait()之前，线程必须获得该对象的对象级别锁，也就是说只能在同步方法或同步块中调用wait()方法。在执行wait()方法后，当前线程释放对象锁。如果调用wait()时没有持有适当的锁，则抛出IllagalMonitorStateException，这是RuntimeException的一个子类，不需要try-catch语句进行捕捉。</p>
<p>notify()/notifyAll():在调用notify()之前，线程也必须获得该对象的对象级别锁，也就是说要在同步方法或同步块中调用。同样，如果调用notify()时没有持有适当的锁，也会抛出IllagalMonitorStateException。notify()方法用来通知那些可能等待该对象的对象锁的其他线程，如果有多个线程等待，则由线程规划器随机挑选出一个呈wait状态的线程，对其发出notify，并使得它等待获取该对象的对象锁。但是需要说明的是，在执行notify()方法后，当前线程不会马上释放该对象锁，要等到执行notify()方法的线程将程序执行完，也就是退出synchronized代码后，当前线程才会释放锁。总而言之，notify()方法随机唤醒等待队列中的等待同一共享资源(同一对象锁)的线程，进入可运行状态。如果发出notify操作时没有处于阻塞状态中的线程，那么该命令可以忽略。</p>
<p>关键字synchronized可以将任何一个Object对象作为同步对象来看待，而Java为每个Object都实现了wait()和notify()方法，它们必须用在被synchronized同步的Object的临界区内。通过调用wait()方法可以使处于临界区内的线程进入等待状态，同时释放被同步对象的锁。而notify操作可以唤醒一个因调用了wait操作而处于等待状态的线程，使其进入就绪状态，重新试图获得对象锁，等待CPU的调用，执行wait()方法之后的代码。</p>
<p>我们需要注意的是，sleep()方法是不释放对象锁的。同时，每个锁对象都有两个队列，一个是就绪队列，一个是阻塞队列。就绪队列存储了将要获得锁的线程，阻塞队列存储了被阻塞的线程。一个线程被唤醒后，才会进入就绪队列，等待CPU的调度；反之，一个线程被wait后，就会进入阻塞队列，等待下一次被唤醒。</p>
<p>总结一下，对象锁何时会被释放：</p>
<ul>
<li>执行完同步代码块</li>
<li>在执行同步代码块的过程中，遇到异常而导致线程终止</li>
<li>在执行同步代码块的过程中，执行了锁所属对象的wait()方法，这个线程会释放锁，进行对象的等待池</li>
</ul>
<p>这里介绍一个结束线程的方法:对某一线程调用interrupt()时，如果该线程正在执行普通的代码，那么该线程根本就不会抛出InterruptedException。但是，一旦该线程进入到wait()/sleep()/join()后，就会立刻抛出InterruptedException。那么，如果线程A希望立即结束线程B，则可以对线程B对应的Thread实例调用interrupt方法。如果此刻线程B正在wait/sleep /join，则线程B会立刻抛出InterruptedException，在catch() {} 中直接return即可安全地结束线程。</p>
<p>多线程实例代码：通过管道进行线程之间数据通信</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PipeInputOutputTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            WriteData writeData = <span class="keyword">new</span> WriteData();</div><div class="line">            ReadData readData = <span class="keyword">new</span> ReadData();</div><div class="line"></div><div class="line">            PipedInputStream inputStream = <span class="keyword">new</span> PipedInputStream();</div><div class="line">            PipedOutputStream outputStream = <span class="keyword">new</span> PipedOutputStream();</div><div class="line">            </div><div class="line">            <span class="comment">//将输入管道和输出管道连接起来</span></div><div class="line">            outputStream.connect(inputStream);</div><div class="line">            </div><div class="line">            <span class="comment">//注意：首先读取线程启动，由于当时没有数据写入，会有I/O阻塞，直到数据被写入，才继续运行下去</span></div><div class="line">            ThreadRead threadRead = <span class="keyword">new</span> ThreadRead(readData, inputStream);</div><div class="line">            threadRead.start();</div><div class="line">            Thread.sleep(<span class="number">1000</span>);</div><div class="line">            ThreadWrite threadWrite = <span class="keyword">new</span> ThreadWrite(writeData, outputStream);</div><div class="line">            threadWrite.start();</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WriteData</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeMethod</span><span class="params">(PipedOutputStream outputStream)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            System.out.println(<span class="string">"write:"</span>);</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">                String outData = <span class="string">""</span> + i;</div><div class="line">                outputStream.write(outData.getBytes());</div><div class="line">                System.out.print(outData);</div><div class="line">            &#125;</div><div class="line">            System.out.println();</div><div class="line">            outputStream.close();</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadData</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readMethod</span><span class="params">(PipedInputStream inputStream)</span></span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            System.out.println(<span class="string">"read:"</span>);</div><div class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>];</div><div class="line">            <span class="keyword">int</span> readLength = inputStream.read(bytes);</div><div class="line">            <span class="keyword">while</span> (readLength != -<span class="number">1</span>) &#123;</div><div class="line">                String readData = <span class="keyword">new</span> String(bytes, <span class="number">0</span>, readLength);</div><div class="line">                System.out.print(<span class="string">" read : "</span>+readData);</div><div class="line">                readLength = inputStream.read(bytes);</div><div class="line">            &#125;</div><div class="line">            System.out.println();</div><div class="line">            inputStream.close();</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadWrite</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> WriteData writeData;</div><div class="line">    <span class="keyword">private</span> PipedOutputStream outputStream;</div><div class="line"></div><div class="line">    ThreadWrite(WriteData writeData, PipedOutputStream outputStream) &#123;</div><div class="line">        <span class="keyword">this</span>.writeData = writeData;</div><div class="line">        <span class="keyword">this</span>.outputStream = outputStream;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.run();</div><div class="line">        writeData.writeMethod(outputStream);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadRead</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> ReadData readData;</div><div class="line">    <span class="keyword">private</span> PipedInputStream inputStream;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadRead</span><span class="params">(ReadData readData, PipedInputStream inputStream)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.readData = readData;</div><div class="line">        <span class="keyword">this</span>.inputStream = inputStream;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.run();</div><div class="line">        readData.readMethod(inputStream);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="方法join的使用"><a href="#方法join的使用" class="headerlink" title="方法join的使用"></a>方法join的使用</h2><p>在很多情况下，主线程启动子线程，如果子线程中要进行大量的耗时运算，主线程往往将早于子线程之前结束。这时，如果主线程想等待子线程执行完成之后再结束，比如子线程处理一个数据，主线程要取得这个数据中的值，就要用到join()方法了。join()方法的作用是等待对象销毁。可以将两个交替执行的线程合并为顺序执行的线程。比如在线程B中调用了线程A的join()方法，直到线程A执行完毕后，才会继续执行线程B。join()方法内部实现是通过调用wait()方法实现的，比如当main线程调用t.join时候，main线程会获得线程对象t的锁（wait意味着拿到该对象的锁),调用该对象的wait(等待时间)。这就意味着main线程调用t.join时，必须能够拿到线程t对象的锁。同时，在调用join()方法的时候也会释放对象锁。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            MyThread thread = <span class="keyword">new</span> MyThread();</div><div class="line">            thread.start();</div><div class="line">            thread.join();</div><div class="line">            System.out.println(<span class="string">"在thread对象执行完之后再执行"</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.run();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">int</span> secondValue = (<span class="keyword">int</span>) (Math.random() * <span class="number">1000</span>);</div><div class="line">            System.out.println(secondValue);</div><div class="line">            Thread.sleep(secondValue);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="类ThreadLocal的使用"><a href="#类ThreadLocal的使用" class="headerlink" title="类ThreadLocal的使用"></a>类ThreadLocal的使用</h2><p>类ThreadLocal主要解决的就是每个线程绑定自己的值，可以将ThreadLocal类比喻成全局存放数据的盒子，盒子中可以存储每个线程的私有数据。</p>
<p>类Threadlocal解决的是变量在不同线程间的隔离性，也就是不同线程拥有自己的值，不同线程中的值是可以放入Threadlocal类中进行保存的。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaSE/">JavaSE</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/多线程/">多线程</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/07/29/内部类学习笔记/" title=" 内部类学习笔记" itemprop="url"> 内部类学习笔记</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lujunqiu" target="_blank" itemprop="author">Lujunqiu</a>
		
  <p class="article-time">
    <time datetime="2017-07-29T02:40:17.000Z" itemprop="datePublished"> Published 2017-07-29</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="内部类讲解"><a href="#内部类讲解" class="headerlink" title="内部类讲解"></a>内部类讲解</h1><p>内部类有两种情况：</p>
<ul>
<li>在类中定义一个类（私有内部类，静态内部类）</li>
<li>在方法中定义一个类（局部内部类，匿名内部类）</li>
</ul>
<h2 id="私有内部类"><a href="#私有内部类" class="headerlink" title="私有内部类"></a>私有内部类</h2><p>1.在外部类的作用范围内可以任意创建内部类对象，即使内部类是私有的(私有内部类)。即内部类对包围它的外部类可见。</p>
<p>2.在内部类中可以访问其外部类的所有域，即使是私有域。即外部类对内部类可见。</p>
<p>问题来了：上面两个特点到底如何办到的呢？内部类的”内部”到底发生了什么？</p>
<p>其实，内部类是Java编译器一手操办的。虚拟机并不知道内部类与常规类有什么不同。对内部类进行编译后发现有两个class文件：Outer.class和Outer@Inner.class.这说明内部类Inner仍然被编译成一个独立的类(Outer@Inner.class),而不是Outer类的某一个域。虚拟机运行的时候，也是把Inner作为一个常规类来处理的。</p>
<p>那么，为什么外部类可以创建内部类的对象？</p>
<p>首先编译器将外、内部类编译后放在同一个包中。在内部类中附加一个包可见构造器。这样，虚拟机运行Outer类中Inner in=new Inner(); 实际上调用的是包可见构造： new   Outer@Inner(this,null)。因此即使是private内部类，也会通过隐含的包可见构造器成功的获得私有内部类的构造权限。再者，Outer@Inner类中有一个指向外部类Outer的引用this@0，那么通过这个引用就可以方便的得到外部类对象中可见成员。</p>
<p>但是Outer类中的private成员是如何访问到的呢？这就要看看下面Outer.class文件中的秘密了。那么，为什么内部类可以引用外部类的私有域？</p>
<p>原因的关键就在编译器在外围类中添加了静态方法access@0。它将返回值作为参数传递给他的对象域data。</p>
<p>这样内部类Inner中的打印语句： System.out.println(data);</p>
<p> 实际上运行的时候调用的是：System.out.println(this@0.access@0(Outer));</p>
<p> 总结一下编译器对类中内部类做的手脚：</p>
<ul>
<li>在内部类中偷偷摸摸的创建了包可见构造器，从而使外部类获得了创建权限。</li>
<li>在外部类中偷偷摸摸的创建了访问私有变量的静态方法，从而 使 内部类获得了访问权限。</li>
</ul>
<p>这样，类中定义的内部类无论私有，公有，静态都可以被包围它的外部类所访问。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name ;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line"></div><div class="line">    <span class="comment">/**省略getter和setter方法**/</span></div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InnerClass</span><span class="params">()</span></span>&#123;</div><div class="line">            name = <span class="string">"chenssy"</span>;</div><div class="line">            age = <span class="number">23</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</div><div class="line">            System.out.println(<span class="string">"name："</span> + getName() +<span class="string">"   ;age："</span> + getAge());</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">public</span> OuterClass <span class="title">getOuterClass</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">return</span> OuterClass.<span class="keyword">this</span>;</div><div class="line">        &#125;</div><div class="line">    </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        OuterClass outerClass = <span class="keyword">new</span> OuterClass();</div><div class="line">        OuterClass.InnerClass innerClass = outerClass.new InnerClass();</div><div class="line">        innerClass.display();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>静态内部类和私有内部类最大的区别在于，静态内部类中无法引用到其外围类的非静态成员.也就是说静态内部类只能访问其外围类的静态成员，除此之外与非静态内部类没有任何区别。</p>
<h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>局部内部类是在方法中定义的内部类，有两个特点：</p>
<ul>
<li>方法中的内部类没有修饰符号，就是说方法中的内部类对包围它的方法之外的任何东西都不可见。</li>
<li>方法内部类只能够访问该方法中的局部变量，所以也叫局部内部类。而且这些局部变量一定要是final修饰的常量。</li>
</ul>
<p>代码示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outter</span></span>&#123;   </div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outMethod</span><span class="params">()</span></span>&#123;   </div><div class="line">             <span class="keyword">final</span> <span class="keyword">int</span> beep=<span class="number">0</span>;   </div><div class="line">             <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;   </div><div class="line">                   <span class="comment">//使用beep   </span></div><div class="line">             &#125;   </div><div class="line">             Inner in=<span class="keyword">new</span> Inner();   </div><div class="line">      &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 我们可以这样解释Inner类中的这个备份常量域，首先当JVM运行到需要创建Inner对象之后，Outter类已经全部运行完毕，这是垃圾回收机制很有可能释放掉局部变量beep。那么Inner类到哪去找beep变量呢？</p>
<p>编译器又出来帮我们解决了这个问题，他在Inner类中创建了一个beep的备份 ，也就是说即使Ouuter中的beep被回收了，Inner中还有一个备份存在，自然就不怕找不到了。</p>
<p>但是问题又来了。如果Outter中的beep不停的在变化那。那岂不是也要让备份的beep变量无时无刻的变化。为了保持局部变量与局部内部类中备份域保持一致。 编译器不得不规定死这些局部域必须是常量，一旦赋值不能再发生变化了。</p>
<p>所以为什么局部内部类应用外部方法的域必须是常量域的原因所在了。</p>
<h2 id="总结内部类的特点"><a href="#总结内部类的特点" class="headerlink" title="总结内部类的特点"></a>总结内部类的特点</h2><p>(1)  在方法间定义的非静态内部类： </p>
<pre><code>● 外围类和内部类可互相访问自己的私有成员。

● 内部类中不能定义静态成员变量。
</code></pre><p>(2) 在方法间定义的静态内部类：</p>
<pre><code>● 只能访问外部类的静态成员。
</code></pre><p>(3) 在方法中定义的局部内部类：</p>
<pre><code>● 该内部类没有任何的访问控制权限

● 外围类看不见方法中的局部内部类的，但是局部内部类可以访问外围类的任何成员。

● 方法体中可以访问局部内部类，但是访问语句必须在定义局部内部类之后。

● 局部内部类只能访问方法体中的常量，即用final修饰的成员。
</code></pre><p>(4) 在方法中定义的匿名内部类：</p>
<pre><code>● 没有构造器，取而代之的是将构造器参数传递给超类构造器。
</code></pre><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="匿名内部类的作用"><a href="#匿名内部类的作用" class="headerlink" title="匿名内部类的作用"></a>匿名内部类的作用</h3><p>除了匿名只使用一次之外,当你想使用一个类的protected方法时，但是又不和这个类在同一个包下，你是没办法调用的。这时候匿名类就派上用场了，你可以声明一个匿名类继承该类，并定义一个方法，在这个方法内使用super调用你想调用的那个方法（其实你也可以写个类继承这个类，就能调用父类的protected方法了，但是匿名类更简洁，因为你只想调用这个方法而已）</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span></span>&#123;</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> test&#123;</div><div class="line">        System.out.println(<span class="string">"test"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个类有一个protected方法test，如果你在其他包下想调用这个protected方法是不行的，可以发现没有提示test方法.这时候你可以使用匿名类继承这个类，定义一个方法callParentTest()，在这个方法体内调用super.test()，最后调用这个callParentTest()即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">new</span> TestClass()&#123;</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">callParentTest</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">super</span>.test();</div><div class="line">        &#125;</div><div class="line">    &#125;.callParentTest();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaSE/">JavaSE</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/内部类/">内部类</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/07/21/Java多线程学习笔记（二）/" title="Java多线程学习笔记（二）" itemprop="url">Java多线程学习笔记（二）</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lujunqiu" target="_blank" itemprop="author">Lujunqiu</a>
		
  <p class="article-time">
    <time datetime="2017-07-21T14:39:39.000Z" itemprop="datePublished"> Published 2017-07-21</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="对象及变量的并发访问"><a href="#对象及变量的并发访问" class="headerlink" title="对象及变量的并发访问"></a>对象及变量的并发访问</h1><p>“非线程安全”其实会在多个线程对同一个对象中的实例变量进行并发访问时发生，产生的后果就是”脏读”，也就是取到的数据其实是被更改过的。而”线程安全”获得的实例变量的值是经过同步处理的，不会出现”脏读”的现象。</p>
<h2 id="synchronized同步方法"><a href="#synchronized同步方法" class="headerlink" title="synchronized同步方法"></a>synchronized同步方法</h2><h3 id="方法内的私有变量"><a href="#方法内的私有变量" class="headerlink" title="方法内的私有变量"></a>方法内的私有变量</h3><p>“非线程安全”问题存在于”实例变量”，如果是方法内部的私有变量，则不存在”非线程安全”问题，永远都是线程安全的，这是方法内部的变量是私有(作用域)的特性造成的。</p>
<h3 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h3><p>如果多个线程共同访问1个对象中的实例变量，则有可能出现”非线程安全”问题。我们需要在有可能产生”非线程安全”的方法前面加上synchronized关键字，将此方法变成同步方法。</p>
<p>关键字synchronized取得的锁都是对象锁，而不是把一段代码或者方法(函数)当作锁，哪个线程先执行带synchronized关键字的方法，哪个线程就持有该方法所属对象的锁Lock，那么其他线程只能呈现等待状态，前提是多个线程访问的是同一个对象。如果多个线程访问多个对象，则JVM会创建多个锁。</p>
<p>假设两个线程访问同一个对象的两个同步synchronized方法：</p>
<ol>
<li>A线程调用object对象加入synchronized关键字的X方法时，A线程就获得了X方法锁，准确的讲，是获得了对象的锁，所以其他线程必须等A线程执行完毕才可以调用X方法，但B线程可以随意调用其他的非synchronized同步方法。</li>
<li>A线程调用object对象加入synchronized关键字的X方法时，A线程就获得了X方法所在对象的锁，所以其他线程必须等A线程执行完毕才可以调用X方法，而B线程如果调用声明了synchronized关键字的非X方法时，必须等A线程将X方法执行完，也就是释放了对象锁后才可以调用。</li>
</ol>
<p>“可重入锁”:当有一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当这个线程再次想要获得这个对象的锁的时候还是可以获取的。特别的说明，当存在父子类继承关系时，子类是完全可以通过”可重入锁”调用父类的同步方法的。</p>
<p>但是，当一个线程执行的代码出现异常退出时，其所持有的锁会自动释放。</p>
<h2 id="synchronized-this-同步语句块"><a href="#synchronized-this-同步语句块" class="headerlink" title="synchronized(this)同步语句块"></a>synchronized(this)同步语句块</h2><p>用synchronized声明方法在时间效率上是有弊端的，比如A线程调用了同步方法执行一个长时间的任务，那么B线程则必须等待比较长的时间。</p>
<p>当两个并发线程访问同一个对象object中的synchronized(this)同步代码块时，一段时间内只能有一个线程被执行，另一个线程必须等待当前线程执行完这个代码块以后才能执行。并且当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object对象中的非synchronized(this)同步代码块。也就是说，不在synchronized(this)同步代码块就是异步执行，在synchronized块中就是同步执行。</p>
<p>当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对同一个object中所有其他synchronized(this)同步代码块的访问将被阻塞，这就说明synchronized使用的“对象监视器”是同一个。也就是说，和synchronized方法一样，synchronized(this)同步代码块也是锁定当前对象的。</p>
<h2 id="对象监视器"><a href="#对象监视器" class="headerlink" title="对象监视器"></a>对象监视器</h2><p>在前面的学习中，使用synchronized(this)格式来同步代码块，其实我们还可以用”任意对象”作为”对象监视器”来实现同步的功能，使用的格式为synchronized(非this对象x)。那么，在多个线程持有”对象监视器”为同一个对象时，同一时间只有一个线程可以执行synchronized(非this对象x)同步代码块中的代码。如果不是同一个对象监视器，则会异步运行。更多示例参考《Java多线程编程核心技术》2.2.8节。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyOneList</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> List list = <span class="keyword">new</span> ArrayList();</div><div class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String data)</span></span>&#123;</div><div class="line">        list.add(data);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> list.size();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> MyOneList list;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread1</span><span class="params">(MyOneList list)</span></span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="keyword">this</span>.list = list;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            <span class="keyword">if</span>(list.getSize() &lt; <span class="number">1</span>)&#123;</div><div class="line">                Thread.sleep(<span class="number">2000</span>);</div><div class="line">                list.add(<span class="string">"A"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e )&#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> MyOneList list;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread2</span><span class="params">(MyOneList list)</span></span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="keyword">this</span>.list = list;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            <span class="keyword">if</span>(list.getSize() &lt; <span class="number">1</span>)&#123;</div><div class="line">                Thread.sleep(<span class="number">2000</span>);</div><div class="line">                list.add(<span class="string">"B"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e )&#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        MyOneList list = <span class="keyword">new</span> MyOneList();</div><div class="line">        MyThread1 thread1 = <span class="keyword">new</span> MyThread1(list);</div><div class="line">        thread1.setName(<span class="string">"A"</span>);</div><div class="line">        thread1.start();</div><div class="line">        MyThread2 thread2 = <span class="keyword">new</span> MyThread1(list);</div><div class="line">        thread1.setName(<span class="string">"B"</span>);</div><div class="line">        thread1.start();</div><div class="line">        Thread.sleep(<span class="number">6000</span>);</div><div class="line">        System.out.println(<span class="string">"listSize = "</span> + list.getSize());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码就有可能出现”脏读”，导致输出结果为”listSize=2”，原因是２个线程以异步的方式返回list参数的size()大小，导致同时进入if判断语句中。</p>
<p>这个例子中如何解决”脏读”呢？由于list参数对象在项目中是一份实例，是单例的，而且也正需要对list参数的getSize()方法做同步调用，所以就对list参数进行同步处理。</p>
<p>更改代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> MyOneList list;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread1</span><span class="params">(MyOneList list)</span></span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="keyword">this</span>.list = list;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            <span class="keyword">synchronized</span>(list)&#123;</div><div class="line">                <span class="keyword">if</span>(list.getSize() &lt; <span class="number">1</span>)&#123;</div><div class="line">                    Thread.sleep(<span class="number">2000</span>);</div><div class="line">                    list.add(<span class="string">"A"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e )&#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="静态同步synchronized方法与synchronized-class-代码块"><a href="#静态同步synchronized方法与synchronized-class-代码块" class="headerlink" title="静态同步synchronized方法与synchronized(class)代码块"></a>静态同步synchronized方法与synchronized(class)代码块</h2><p>关键字synchronized还可以应用在static静态方法上，如果这样写，那是对当前的.java文件对应的Class类进行持锁。synchronized关键字加到static静态方法上是给Class类上锁，可以对类的所有对象实例起作用，而synchronized关键字加到非static静态方法上是给对象上锁，这2个锁不是同一个锁。synchronized(class)代码块的作用其实和synchronized static方法的作用一样。我们需要注意的是，synchronized(ClassName)与synchronized(ClassName的实例)，线程各自获取各自的锁，不会有等待。</p>
<p>注意:我们在将任何数据类型作为同步锁时，需要观察，是否有多个线程同时持有锁对象，如果同时持有相同的锁对象，则这些线程之间就是同步的；如果分别获得锁对象，就是异步的。</p>
<h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><p>并发专家建议我们远离它，尤其是在JDK6的synchronized关键字的性能被大幅优化之后，更是几乎没有使用它的场景，但这仍然是个值得研究的关键字，研究它的意义不在于去使用它，而在于理解它对理解Java的整个多线程的机制是很有帮助的。</p>
<p>关键字volatile的主要作用是使变量在多个线程间可见。简单地说就是当线程A对变量X进行了修改后，在线程A后面执行的其他线程能看到变量X的变动。同时关键字synchronized也可以同样的完成volatile关键字可见性的功能。</p>
<p>更详细地说是要符合以下两个规则：</p>
<ul>
<li>线程对变量进行修改之后，要立刻回写到主内存。</li>
<li>线程对变量读取的时候，要从主内存中读，而不是缓存。</li>
</ul>
<p>这里我们需要提到Java内存模型。在Java内存模型中，内存分为主内存和工作内存两个部分，其中主内存是所有线程所共享的，而工作内存则是每个线程分配一份，各线程的工作内存间彼此独立、互不可见，在线程启动的时候，虚拟机为每个内存分配一块工作内存，不仅包含了线程内部定义的局部变量，也包含了线程所需要使用的共享变量(非线程内构造的对象)的副本，即为了提高执行效率，读取副本比直接读取主内存更快(这里可以简单地将主内存理解为虚拟机中的堆，而工作内存理解为栈(或称为虚拟机栈)，栈是连续的小空间、顺序入栈出栈，而堆是不连续的大空间，所以在栈中寻址的速度比堆要快很多)。</p>
<p>对于共享普通变量来说，约定了变量在工作内存中发生变化了之后，必须要回写到工作内存(迟早要回写但并非马上回写)，但对于volatile变量则要求工作内存中发生变化之后，必须马上回写到工作内存，而线程读取volatile变量的时候，必须马上到工作内存中去取最新值而不是读取本地工作内存的副本，此规则保证了前面所说的“当线程A对变量X进行了修改后，在线程A后面执行的其他线程能看到变量X的变动”。</p>
<p>volatile虽然保证了线程之间共享变量的及时可见性，但是并没有保证同步。也就是说，volatile不能保证原子性。而synchronized关键字解决的是多个线程之间访问资源的同步性。</p>
<p>这里说明一下，如果真的需要使用volatile关键字，那么，在禁止指令重排序是一个很好的场景。具体volatile关键字的用法，参考这篇博客：<a href="https://www.ibm.com/developerworks/cn/java/j-jtp06197.html" target="_blank" rel="external">正确使用 Volatile 变量</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaSE/">JavaSE</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/多线程/">多线程</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/06/30/模版方法模式/" title="模版方法模式" itemprop="url">模版方法模式</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lujunqiu" target="_blank" itemprop="author">Lujunqiu</a>
		
  <p class="article-time">
    <time datetime="2017-06-30T02:01:34.000Z" itemprop="datePublished"> Published 2017-06-30</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h1><p><em>定义：规定一个操作中的算法的骨架，而将步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义算法的某些特定步骤。</em></p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>通过模板方法我们可以控制子类扩展，因为子类必须遵守算法规则(从父类继承而来)。在多个子类拥有相同的方法，并且这些方法逻辑相同时，可以考虑使用模版方法模式。在程序的主框架相同，细节不同的场合下，也比较适合使用这种模式。</p>
<h2 id="策略模式的结构："><a href="#策略模式的结构：" class="headerlink" title="策略模式的结构："></a>策略模式的结构：</h2><p><img src="../../../../img/moshi/moban.png" alt=""></p>
<p>图中的角色：</p>
<p>抽象类（AbstractClass）：在抽象类中定义了一系列基本操作，这些基本操作可以是具体的，也可以是抽象的，每一个基本操作对应算法的一个步骤，在其子类中可以重定义或实现这些步骤。同时，在抽象类中实现了一个模板方法，用于定义一个算法的框架，模板方法不仅可以调用在抽象类中实现的基本方法，也可以调用在抽象类的子类中实现的基本方法，还可以调用其他对象中的方法。</p>
<p>具体类（ConcreteClass)：它是抽象类的子类，用于实现在父类中声明的抽象基本操作以完成子类特定算法的步骤，也可以覆盖在父类中已经实现的具体基本操作</p>
<h2 id="进一步了解策略模式"><a href="#进一步了解策略模式" class="headerlink" title="进一步了解策略模式"></a>进一步了解策略模式</h2><p>关于钩子方法：</p>
<p>由抽象类声明并加以实现，但是子类可以去扩展，子类可以通过扩展钩子方法来影响模版方法的逻辑。最简单的钩子方法就是空方法，另一种钩子方法可以实现对其他方法进行约束，这种钩子方法通常返回一个bool类型，即返回true或false，用来判断是否执行某一个基本方法。同时我们也可以在钩子方法中定义一个默认的实现，如果子类不覆盖钩子方法，则执行父类的默认实现代码。</p>
<p>优点：</p>
<ul>
<li>模板方法模式通过把不变的行为搬移到超类，去除了子类中的重复代码</li>
<li>子类实现算法的某些细节，有助于算法的扩展。</li>
<li>通过一个父类调用子类实现的操作，通过子类扩展增加新的行为，符合“开放-封闭原则”</li>
</ul>
<h2 id="代码实例："><a href="#代码实例：" class="headerlink" title="代码实例："></a>代码实例：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doAnything</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isDoSomething</span><span class="params">()</span></span>&#123; <span class="comment">//父类方法返回真</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">templateMethod</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * 调用基本方法，完成相关的逻辑</div><div class="line">         */</div><div class="line">        <span class="keyword">this</span>.doAnything();</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.isDoSomething())</div><div class="line">            <span class="keyword">this</span>.doSomething();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteClass1</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isDoSth;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doAnything</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        <span class="comment">//子类实现具体</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub    </span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setDo</span><span class="params">(<span class="keyword">boolean</span> isDo)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.isDoSth = isDo;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isDoSomething</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> isDoSth;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/设计模式/">设计模式</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/模版方法模式/">模版方法模式</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/06/28/策略模式/" title="策略模式" itemprop="url">策略模式</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lujunqiu" target="_blank" itemprop="author">Lujunqiu</a>
		
  <p class="article-time">
    <time datetime="2017-06-28T06:09:53.000Z" itemprop="datePublished"> Published 2017-06-28</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p><em>定义：针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以互相替换。</em></p>
<p>策略模式属于对象行为模式，可以使得算法在不影响到客户端(算法的调用者)的情况下发生变化。策略模式通常把一个系列的算法包装到一系列的策略类里面，作为一个抽象策略类的子类，可以将策略模式理解为相同行为的不同实现而已。</p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>在软件开发中也常常遇到类似的情况，实现某一个功能有多种算法或者策略，我们可以根据环境或者条件的不同选择不同的算法或者策略来完成该功能。如查找、排序等，一种常用的方法是硬编码(Hard Coding)。在一个类中，如需要提供多种查找算法，可以将这些算法写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的查找算法；当然也可以将这些查找算法封装在一个统一的方法中，通过if…else…或者case等条件判断语句来进行选择。这两种实现方法我们都可以称之为硬编码，如果需要增加一种新的查找算法，需要修改封装算法类的源代码；更换查找算法，也需要修改客户端调用代码。在这个算法类中封装了大量查找算法，该类代码将较复杂，维护较为困难。如果我们将这些策略包含在客户端，这种做法更不可取，将导致客户端程序庞大而且难以维护，如果存在大量可供选择的算法时问题将变得更加严重。这时候我们就需要使用到策略模式来设计我们的代码了。</p>
<h2 id="策略模式的结构："><a href="#策略模式的结构：" class="headerlink" title="策略模式的结构："></a>策略模式的结构：</h2><p><img src="../../../../img/moshi/celue.png" alt=""></p>
<p>以上结构涉及到三个角色：</p>
<ul>
<li>环境(Context):持有一个Strategy的引用,对策略进行二次封装，目的是避免高层模块对策略的直接调用</li>
<li>抽象策略类(Strategy):通常由一个接口或者抽象类实现，给出所有的具体策略类所需的接口,当各个实现类中存在着重复的逻辑时，则使用抽象类来封装这部分公共的代码</li>
<li>具体策略类(ConcreteStrategy):包装了相关算法的实现</li>
</ul>
<h2 id="进一步了解策略模式"><a href="#进一步了解策略模式" class="headerlink" title="进一步了解策略模式"></a>进一步了解策略模式</h2><p>策略模式仅仅封装算法，在什么情况下使用什么算法是由调用者决定的，而且策略模式的重心不是如何实现算法，而是如何组织、调用这些算法，从而让程序结构更灵活，具有更好的维护性和扩展性。</p>
<p>策略模式的优点：</p>
<ul>
<li>策略类之间可以自由切换，由于策略类实现自同一个抽象，所以他们之间可以自由切换</li>
<li>易于扩展，增加一个新的策略对策略模式来说非常容易，基本上可以在不改变原有代码的基础上进行扩展</li>
<li>使用策略模式可以避免使用多重条件(if-else)语句。多重条件语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重条件语句里面，比使用继承的办法还要原始和落后</li>
</ul>
<p>策略模式的缺点：</p>
<ul>
<li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道算法或行为的情况</li>
<li>由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观</li>
</ul>
<h2 id="代码实例："><a href="#代码实例：" class="headerlink" title="代码实例："></a>代码实例：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</div><div class="line">    <span class="comment">//持有一个具体策略的对象</span></div><div class="line">    <span class="keyword">private</span> Strategy strategy;        </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 构造函数，传入一个具体策略对象</div><div class="line">     * <span class="doctag">@param</span> strategy    具体策略对象</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(Strategy strategy)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.strategy = strategy;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 策略方法</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInterface</span><span class="params">()</span></span>&#123;</div><div class="line">        strategy.strategyInterface();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 策略方法</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyInterface</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyA</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyInterface</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//相关的业务</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyB</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyInterface</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//相关的业务</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/设计模式/">设计模式</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/策略模式/">策略模式</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/06/24/Java多线程学习笔记/" title="Java多线程学习笔记(一)" itemprop="url">Java多线程学习笔记(一)</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lujunqiu" target="_blank" itemprop="author">Lujunqiu</a>
		
  <p class="article-time">
    <time datetime="2017-06-24T15:38:47.000Z" itemprop="datePublished"> Published 2017-06-24</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="Java多线程入门"><a href="#Java多线程入门" class="headerlink" title="Java多线程入门"></a>Java多线程入门</h1><h2 id="进程和多线程的概念"><a href="#进程和多线程的概念" class="headerlink" title="进程和多线程的概念"></a>进程和多线程的概念</h2><p>什么是进程？</p>
<p>进程是操作系统结构的基础，是一次程序的执行；是一个程序及其数据在处理机上顺序执行时所发生的活动；是程序在一个数据集合上运行的过程；它是系统进行资源分配和调度的一个独立单位；是受操作系统管理的基本运行单元。</p>
<p>什么是线程？</p>
<p>线程是在进程中独立运行的子任务。我们也要记住，多线程是异步的，线程被调用的时机是随机的，与CPU的调度有关，代码的执行顺序(代码的书写顺序)与代码的调用顺序无关。</p>
<p>线程的状态：</p>
<ul>
<li>新建状态(New):新创建了一个线程对象</li>
<li>就绪状态(Runnable):线程对象调用了start()方法后，该线程处于可运行线程池中，等待CPU的调度</li>
<li>运行状态(Running):CPU调度可运行池中的线程，执行线程的代码</li>
<li>阻塞状态(Blocked):线程因某种原因放弃CPU的使用权</li>
</ul>
<h2 id="使用多线程"><a href="#使用多线程" class="headerlink" title="使用多线程"></a>使用多线程</h2><h3 id="创建多线程对象"><a href="#创建多线程对象" class="headerlink" title="创建多线程对象"></a>创建多线程对象</h3><p>我们在运行Java代码的时候，有一个最基本的线程，就是在调用public static void main()方法的时候，我们其实在通过一个名为main的线程在执行main()方法，该线程由JVM创建。</p>
<p>创建多线程有２种方式，一种是继承Thread类，另一种是实现Runnable接口。这２种方式在工作时的性质是一样的，没有本质区别。</p>
<p><em>通过继承Thread类创建多线程：</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.run();</div><div class="line">        System.out.println(<span class="string">"Thread"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Thread thread = <span class="keyword">new</span> Thread();</div><div class="line">        thread.start();</div><div class="line">        System.out.println(<span class="string">"运行结束！"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<p>运行结束！</p>
<p>Thread</p>
<p>我们可以看到，继承Thread类的方式创建新线程时，最大的局限就是不支持多继承，所以为了支持多继承，完全可以实现Runnable接口的方式。</p>
<p>我们可以看到Thread类的源代码，如下：</p>
<p><em>public class Thread implements Runnable</em></p>
<p>从这里可以看出，Thread类实现了Runnbale接口，它们之间具有多态关系。</p>
<p>我们注意到Thread.java类中start()方法与run()方法都可以调用线程对象中的run()方法，这２个方法有什么区别呢？</p>
<p>Thread.java类中的start()方法通知”线程规划器”此线程已经准备就绪，等待调用线程对象的run()方法。这个过程其实就是让系统安排一个时间来调用Thread中的run()方法，也就是使线程得到运行，启动线程，具有异步执行的效果。如果调用代码的thread.run()方法就不是异步执行了，而是同步，那么此线程对象并不交给”线程规划器”来处理，而是由main主线程来调用run()方法，这个时候与多线程无关与普通调用方法一样，必须等run()方法中的代码执行完毕后才能执行main函数后面的代码。</p>
<p><em>通过实现Runnable接口创建多线程：</em></p>
<p>如果欲创建的线程类已经有一个父类了，这时就不能再继承Thread类了，所以我们需要实现Runnable接口来应对这样的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Runnable</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Runnable"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Runnable runnable = <span class="keyword">new</span> Runnable();</div><div class="line">        Thread thread = <span class="keyword">new</span> Thread(runnable);</div><div class="line">        thread.start();</div><div class="line">        System.out.println(<span class="string">"运行结束！"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<p>运行结束！</p>
<p>Runnable</p>
<p>另外需要说明的是，我们已经知道了Thread类实现了Runnbale接口，那也就意味着构造函数Thread(Runnable target)方法不光可以传入Runnable接口的对象，还可以传入一个Thread类对象，这样做完全可以将一个Thread对象中的run()方法交给其他的线程进行调用。</p>
<h3 id="多线程对象的常用函数"><a href="#多线程对象的常用函数" class="headerlink" title="多线程对象的常用函数"></a>多线程对象的常用函数</h3><ul>
<li>Thread.currentThread()方法返回代码段正在被哪个线程调用的信息</li>
<li><p>Thread对象实例.isAlive()方法的功能是判断当前线程是否处于活跃状态(正在运行状态或者准备开始运行状态)</p>
</li>
<li><p>Thread.sleep()方法的作用是在指定的毫秒数内让”当前执行的线程”休眠(暂停执行)</p>
</li>
<li><p>getId()方法可以获取线程的唯一标识</p>
</li>
<li><p>yield()方法的作用是放弃当前的CPU资源，将它让给其他的任务去占用CPU执行时间。当放弃的时间不确定，有可能刚刚放弃，马上又获取CPU时间片。</p>
</li>
</ul>
<p>接下来，我们重要讨论一下如何停止正在运行的线程。停止一个线程意味着在线程处理完任务之前停掉正在做的事情，也就是放弃当前的操作。</p>
<p>在Java中有３种方法可以终止正在运行的线程：</p>
<ol>
<li>使用退出标志，是线程正常退出，也就是run方法完成之后线程终止</li>
<li>使用stop方法强行终止线程，但是不推荐使用这个方法，因为stop和suspend以及resume一样，都是作废过期的方法，使用它们可能产生不可预料的结果</li>
<li>使用interrupt()方法中断线程</li>
</ol>
<p>接下来，介绍如何使用interrupt()方法来停止线程。</p>
<p>如何判断线程是否处于停止状态呢?</p>
<ol>
<li>Thread.interrupted():测试当前线程是否已经中断，static方法，调用这个方法后线程的中断状态被清除。换句话说，如果连续２次调用该方法，则第二次调用将返回false。</li>
<li>this.isInterrupted():测试线程Thread对象实例是否已经中断，非static方法，不清除状态标识</li>
</ol>
<p>调用interrupt()方法不会真的停止线程，而是在当前线程中打了一个停止的标记，还需要配合其他的代码来停止线程。</p>
<p>我们可以在线程对象的run()方法中加入判断语句，判断如果线程处于停止状态那么就可以通过异常来跳过后面的代码执行，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</div><div class="line">                <span class="keyword">if</span> (Thread.interrupted()) &#123;</div><div class="line">                    System.out.println(<span class="string">"停止状态"</span>);</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">                &#125;</div><div class="line">                System.out.println(<span class="string">"i = "</span> + i);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            System.out.println(<span class="string">"线程进入异常处理模块，停止运行run方法"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        MyThread thread = <span class="keyword">new</span> MyThread();</div><div class="line">        thread.start();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="number">1</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        thread.interrupt();</div><div class="line">        System.out.println(<span class="string">"end"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<p>…</p>
<p>i = 16</p>
<p>i = 17</p>
<p>end</p>
<p>i = 18</p>
<p>停止状态</p>
<p>线程进入异常处理模块，停止运行run方法</p>
<p>除了使用异常，我们还可以通过线程sleep的状态来停止线程以及通过interrupt方法与return结合来停止线程。不过，我们还是建议使用“抛异常”的方法来实现线程的停止，因为在catch快中还可以将异常向上抛，使线程停止的事件得到传播。</p>
<h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p>在操作系统中，线程可以划分优先级，优先级较高的线程得到的CPU资源较多，也就是CPU优先执行优先级较高的线程对象中的任务。</p>
<p>在Java中，线程的优先级分为１－１０这个１０个等级，如果超出范围，则JDK抛出异常。</p>
<p>优先级具有继承性质，比如A线程启动了B线程，则B线程的优先级与A是一样的。</p>
<p>但是，优先级具有随机性，高优先级的线程总是大部分先执行完，但不代表高优先级的线程全部都先执行完，CPU是<em>尽量</em>将执行资源让给优先级比较高的线程而已。</p>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>在Java中有２种线程：一种是用户线程，另一种是守护线程。</p>
<p>守护线程是一种特殊的线程，当进程中不存在非守护线程了，守护线程就自动销毁。典型的守护线程就是垃圾回收线程，当进程中没有非守护线程了，则垃圾回收线程也就没有存在的必要了，自动销毁。Deamon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是GC(垃圾回收器)。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaSE/">JavaSE</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/多线程/">多线程</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/06/22/编辑距离问题/" title="编辑距离问题" itemprop="url">编辑距离问题</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lujunqiu" target="_blank" itemprop="author">Lujunqiu</a>
		
  <p class="article-time">
    <time datetime="2017-06-22T01:37:41.000Z" itemprop="datePublished"> Published 2017-06-22</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="编辑距离问题"><a href="#编辑距离问题" class="headerlink" title="编辑距离问题"></a>编辑距离问题</h1><p>概念描述：编辑距离，又称Levenshtein距离，是指两个字串之间，由一个转成另一个所需的最少编辑操作次数。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。</p>
<p>问题解析：</p>
<p>计算编辑距离的问题，符合动态规划的几个特征：</p>
<p>最优子结构性质。如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。</p>
<p>无后效性。即子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。</p>
<p>子问题重叠性质。子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。</p>
<p>因此考虑用动态规划求解。</p>
<p>首先，我们可以定义一个函数——edit(i,j)，它表示第一个字符串的长度为i的子串到第二个字符串的长度为j的子串的编辑距离。这也就是动态规划过程中状态的定义，接下来我们就要探讨状态转移方程是如何描述的。</p>
<p>状态转移可以分为以下几个情况来讨论：</p>
<ul>
<li>if i == 0 &amp;&amp; j == 0 ,edit(i,j) = 0</li>
<li>if i == 0 &amp;&amp; j &gt; 0 ,edit(i,j) = j</li>
<li>if i &gt; 0 &amp;&amp; j == 0 ,edit(i,j) = i</li>
<li>if i &gt; 0 &amp;&amp; j &gt; 0 ,edit(i,j) = min{edit(i - 1,j) + 1 ,edit(i,j - 1) + 1 ,edit(i - 1,j - 1) + f(i,j)},当第一个字符串的第i个字符不等于第二个字符串的第j个字符的时候，f(i,j) = 1,否则 f(i,j) = 0</li>
</ul>
<p>根据状态的定义与状态转移方程的描述，我们在解决问题的过程中只需要完成一个二维数组作为DP表就行。</p>
<p>代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    System.out.println(getEditDistance(<span class="string">"ab"</span>, <span class="string">"abaaa"</span>));</div><div class="line">    System.out.println(getEditDistance(<span class="string">"abcca"</span>, <span class="string">"abaaa"</span>));</div><div class="line">    System.out.println(getEditDistance(<span class="string">"ab"</span>, <span class="string">"aba"</span>));</div><div class="line">    System.out.println(getEditDistance(<span class="string">"cafe"</span>, <span class="string">"coffee"</span>));</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getEditDistance</span><span class="params">(String s, String t)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> dp[][];</div><div class="line">    <span class="keyword">int</span> n;<span class="comment">//字符串s的长度</span></div><div class="line">    <span class="keyword">int</span> m;<span class="comment">//字符串t的长度</span></div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">int</span> j;</div><div class="line">    <span class="keyword">char</span> s_i;<span class="comment">//字符串s的第i个字符</span></div><div class="line">    <span class="keyword">char</span> t_j;<span class="comment">//字符串t的第j个字符</span></div><div class="line"></div><div class="line">    n = s.length();</div><div class="line">    m = t.length();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> m;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> n;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</div><div class="line">    <span class="comment">//初始化第一列</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n; i++) &#123;</div><div class="line">        dp[i][<span class="number">0</span>] = i;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//初始化第一行</span></div><div class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= m; j++) &#123;</div><div class="line">        dp[<span class="number">0</span>][j] = j;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//根据状态转移方程完成DP表</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</div><div class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= m; j++) &#123;</div><div class="line">            s_i = s.charAt(i - <span class="number">1</span>);</div><div class="line">            t_j = t.charAt(j - <span class="number">1</span>);</div><div class="line">            <span class="keyword">int</span> f;</div><div class="line">            <span class="keyword">if</span> (s_i == t_j) &#123;</div><div class="line">                f = <span class="number">0</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                f = <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">            dp[i][j] = mininum(dp[i - <span class="number">1</span>][j] + <span class="number">1</span>, dp[i][j - <span class="number">1</span>] + <span class="number">1</span>, dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + f);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dp[n][m];</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line">３个数取最小值方法</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mininum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> min = a &lt; b ? a : b;</div><div class="line">    <span class="keyword">return</span> min &lt; c ? min : c;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/算法/">算法</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/算法/">算法</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/06/21/Maven学习笔记/" title="Maven学习笔记" itemprop="url">Maven学习笔记</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lujunqiu" target="_blank" itemprop="author">Lujunqiu</a>
		
  <p class="article-time">
    <time datetime="2017-06-21T05:04:37.000Z" itemprop="datePublished"> Published 2017-06-21</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="什么是Maven"><a href="#什么是Maven" class="headerlink" title="什么是Maven"></a>什么是Maven</h2><p>maven这个单词的翻译为“专家”或“内行”。作为我们开发过程中使用的工具而言，Maven是一个跨平台的项目管理工具，并且是Apache组织中的开源项目之一，主要用于Java平台的项目构建，依赖管理和项目信息管理等。它是一个异常强大的构建工具，能够帮助我们自动化构建过程，从清理，编译，测试到生产报告，再到打包和部署，我们只需要使用maven配置好项目，然后输入简单的命令，maven会帮我们处理这些繁琐的任务。</p>
<p>maven是跨平台的，这意味着无论是windows上还是在linux,mac上的项目都可以使用同样的命令。同时，maven不仅仅是构建工具，还是一个依赖管理工具和项目信息管理个工具，可以帮助我们自动下载项目所需要的构件。</p>
<p>maven对于项目目录结构，测试用例命名方法等内容都有既定的规则，只要遵循了这些成熟的规则，我们在不同的项目切换的时候就免去了额外的学习成本，上手就容易许多，可以说是约定优于配置(Convention over Configuration)。</p>
<h2 id="Maven的安装-Ubantu"><a href="#Maven的安装-Ubantu" class="headerlink" title="Maven的安装(Ubantu)"></a>Maven的安装(Ubantu)</h2><ol>
<li><p>检查系统的java环境变量配置是否成功</p>
<p> qiu@qiu-qiu:~$ echo $JAVA_HOME</p>
<p> qiu@qiu-qiu:~$ java -version</p>
</li>
<li><p>java环境配置成功后，下载maven:<a href="http://maven.apache.org/download.cgi" target="_blank" rel="external">http://maven.apache.org/download.cgi</a></p>
</li>
<li><p>配置maven的环境变量:</p>
<p> 解压安装包后，到解压出来的maven文件的目录下创建一个符号链接，方便更新：</p>
<p> qiu@qiu-qiu:~$ ln -s apache-maven-3.5.0 apache-maven</p>
<p> 设置M2_HOME变量指向这个符号链接，然后将符号链接中的bin目录添加进系统的PATH变量:</p>
<p> qiu@qiu-qiu:~$ sudo vi /etc/profile</p>
<p> 添加以下几行：</p>
<p> export M2_HOME=/home/qiu/maven/apache-maven</p>
<p> export PATH=$PATH:$M2_HOME/bin</p>
<p> 最后更新配置文件:</p>
<p>　qiu@qiu-qiu:~$ source /etc/profile</p>
</li>
<li><p>检查是否安装成功</p>
<p>  qiu@qiu-qiu:~$ mvn -v</p>
</li>
</ol>
<p>输出：</p>
<p>Apache Maven 3.5.0 (ff8f5e7444045639af65f6095c62210b5713f426; 2017-04-04T03:39:06+08:00)<br>Maven home: /home/qiu/maven/apache-maven<br>Java version: 1.8.0_131, vendor: Oracle Corporation<br>Java home: /usr/jdk1.8.0_131/jre<br>Default locale: zh_CN, platform encoding: UTF-8<br>OS name: “linux”, version: “4.8.0-49-generic”, arch: “amd64”, family: “unix”</p>
<p>关于maven的升级：由于我们之前平行地创建了一个符号链接，然后在配置环境变量的时候使用的是这个符号链接，于是在升级的时候就可以利用这个符号链接了。我们只需要将符号链接指向新的maven版本即可。</p>
<p>在IDEA(版本：2017.1.2)开发环境中搭建maven：<br>在Settings—Build,Execution,Deployment—Build Tools—Maven中设置Maven home directory;   User settings file;   Local repository即可。</p>
<h1 id="maven的使用"><a href="#maven的使用" class="headerlink" title="maven的使用"></a>maven的使用</h1><h2 id="POM文件"><a href="#POM文件" class="headerlink" title="POM文件"></a>POM文件</h2><p>maven项目的核心是pom.xml。POM(Project Object Model，项目对象模型)定义了项目的基本信息，用于描述项目是如何构建的，声明项目依赖，等等。</p>
<p>pom.xml文件里面元素介绍：<br>首先是XML头，指定了该xml文件的版本以及编码方式。紧接着是project元素，project元素是所有pom.xml的根元素，它还声明了一些POM相关的命名空间以及xsd元素。根元素下的第一个子元素是modelVersion指定了当前POM模型的版本。接下来介绍３个重要的元素标签：<br>groupId,artifactId,version。这３个元素定义了一个项目的基本坐标，在maven世界中，任何的jar,pom或者war都是以基于这些基本的坐标进行区分的。</p>
<p>groupId定义了项目属于哪个组，这个组往往和项目所在的组织有关。artifactId定义了当前maven项目在组中唯一的ID。version，顾名思义，指定了当前项目的版本号。最后还可以为项目设定name元素，声明一个对于用户更为友好的项目名称。</p>
<p>dependencies元素声明项目的依赖(java代码中的import)，该元素下可以包含多个dependency元素，里面包含所依赖的构件的mavan坐标。</p>
<p>没有任何实际的java代码，我们就能够定义一个maven项目的POM，这体现了maven的一大优点，它能让项目对象模型最大程度地与实际代码相独立，也就是解耦。这样也避免了java代码与POM代码的相互影响。比如以后当项目需要升级版本的时候，我们只需要修改POM即可。</p>
<h2 id="主代码以及测试代码"><a href="#主代码以及测试代码" class="headerlink" title="主代码以及测试代码"></a>主代码以及测试代码</h2><p>项目的主代码和测试代码不用在于，主代码会被打包到最终的构件中(如jar)，而测试代码只是在运行测试时候用到，不会被打包。</p>
<p>一般来说，项目中的java类的包(package)都应该基于项目的groupId和artifactId，这样更加清晰，更加符合逻辑，也方便搜索构件或者java类。</p>
<p>主代码位于:/src/main/java目录下;测试代码位于:/src/test/java目录下；</p>
<h2 id="mvn命令"><a href="#mvn命令" class="headerlink" title="mvn命令"></a>mvn命令</h2><p>mvn clean　：清除maven的输出目录target</p>
<p>mvn compile :编译项目主代码，将项目主代码编译至target/classes目录中</p>
<p>mvn test-compile　：编译测试的内容</p>
<p>mvn test :运行测试(在运行测试之前会自动执行项目主资源处理，主代码编译，测试资源<br>处理，测试代码编译等工作)</p>
<p>mvn package :生成target目录，编译、测试代码，生成测试报告，生成jar/war文件；默认是jar文件，只打包主项目代码。</p>
<p>mvn install :在本地Repository中安装jar</p>
<p>mvn archetype:generate　：创建mvn项目(使用Archetype生成项目骨架)</p>
<p>mvn dependency:list :查看当前项目的已解析依赖</p>
<p>mvn dependency:tree :查看当前项目的依赖树(传递依赖的路径)</p>
<p>mvn dependency:analyze :帮助分析当前项目的依赖</p>
<h1 id="maven坐标"><a href="#maven坐标" class="headerlink" title="maven坐标"></a>maven坐标</h1><p>为了能够自动化解析任何一个java构件，maven就必须将他们唯一标识，这就依赖管理的底层基础－－坐标。maven定义了这样一组规则：世界上任何一个构件都可以使用maven坐标唯一标识，maven坐标的元素包括groupId,artifactId,version,packaging,classifier。</p>
<p>坐标元素介绍：</p>
<p>groupId:定义当前maven项目隶属的实际项目</p>
<p>artifactId：定义实际项目中的一个maven项目(模块)</p>
<p>version:定义maven项目的当前所处的版本</p>
<p>packaging:定义maven项目的打包方式，默认的打包方式是jar</p>
<p>classifier：用来帮助定义构建输出的一些附属构件。不能直接定义项目的classifier，因为附属构件不是项目默认生成的，而是由附件的插件帮助生成的</p>
<h1 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h1><p>根元素project下的dependencies可以包含一个或者多个dependency元素，以声明一个或者多个项目依赖。每个依赖可以包含的元素有：</p>
<p>groupId,artifactId和version:依赖的基本坐标，对于任何一个依赖来说，基本坐标是最重要的，maven根据坐标才能找到需要的依赖。</p>
<p>type:依赖的类型，对应于项目坐标定义的packaging。大部分情况下，该元素不必声明，默认为jar</p>
<p>scope:依赖的范围</p>
<p>optional:标记依赖是否可选</p>
<p>exclusions:用来排除传递性依赖</p>
<h2 id="依赖的范围"><a href="#依赖的范围" class="headerlink" title="依赖的范围"></a>依赖的范围</h2><p>依赖范围就是用来控制依赖与三种classpath(编译classpath,测试classpath,运行classpath)的关系:</p>
<p>compile:编译依赖范围。如果没有指定，就会默认是该范围。此范围的依赖对编译，测试，运行都有效。</p>
<p>test:测试依赖范围。只在测试是有效，在编译主代码或者运行项目的时候无法使用此类依赖。</p>
<p>provided:已提供依赖范围。对于编译和测试有效，但在运行时候无效。</p>
<p>runtime:运行时依赖范围。对于测试和运行时有效，但在编译主代码时无效。</p>
<h2 id="依赖的传递性"><a href="#依赖的传递性" class="headerlink" title="依赖的传递性"></a>依赖的传递性</h2><p>在使用其他依赖的构件的时候，不用去考虑它依赖了什么，也不用担心引入多余的依赖。maven会解析各个直接依赖的POM,将那些必要的间接依赖以传递性的形式引入到当前的项目中。</p>
<p>maven引入的传递性依赖机制，一方面大大简化和方便了依赖声明，另一方面，大部分情况下我们只需要关心项目的直接依赖是什么，而不用去考虑这些直接依赖会引入声明传递性依赖。</p>
<h2 id="依赖的调解"><a href="#依赖的调解" class="headerlink" title="依赖的调解"></a>依赖的调解</h2><p>比如，项目A有这样的依赖关系:A–B–C–X(1.0)，A–D–X(2.0)，这个时候X是A的传递性依赖。会选择哪个呢？根据maven的第一原则：路径最近者优先。选择X(2.0)；</p>
<p>那么，如果路径相同的呢？这时就用到了第二原则：第一声明者优先。也就是说，在依赖路径长度相等的时候，在POM中的依赖声明的顺序决定了谁会被使用。</p>
<h2 id="排除依赖"><a href="#排除依赖" class="headerlink" title="排除依赖"></a>排除依赖</h2><p>传递性依赖会给项目隐式地引入很多依赖，这极大地简化了项目依赖的管理，但是由于一些原因，不想引入某些传递性依赖。这个时候我们可以使用exclusions标签声明排除依赖，exclusions可以包含一个或者多个exclusion子元素，可以排除一个或者多个传递性依赖。</p>
<h1 id="maven仓库"><a href="#maven仓库" class="headerlink" title="maven仓库"></a>maven仓库</h1><h2 id="maven仓库简介"><a href="#maven仓库简介" class="headerlink" title="maven仓库简介"></a>maven仓库简介</h2><p>坐标和依赖是任何一个构件在maven世界中的逻辑表示方式，而构件的物理表示方式是文件，maven通过仓库来统一管理这些文件。实际的maven项目将不再各自存储其依赖文件，它们只需要声明这些依赖的坐标，在需要的时候,maven会自动根据坐标找到仓库中的构件，并使用它们。</p>
<h2 id="maven仓库分类"><a href="#maven仓库分类" class="headerlink" title="maven仓库分类"></a>maven仓库分类</h2><p>对于maven来说，仓库分为２大类：本地仓库与远程仓库。当maven根据坐标寻找构件的时候，它首先会查看本地仓库，如果本地仓库存在此构件，则直接使用。如果本地仓库不存在此构件，或者需要查看是否有更新的构件，maven就会去远程仓库查找，发现需要的构件之后，下载到本地仓库再使用。如果本地仓库与远程仓库都没有，则报错。</p>
<p>这里，需要说明私服。私服是一种特殊的远程仓库，为了节省带宽和时间，应该在局域网内架设一个私有的仓库服务器，用其代理所有外部的远程仓库。</p>
<p>如果默认的中央仓库无法满足项目的需求，可能项目需要的构件存在于另一个远程仓库中。这个时候可以在项目的POM文件中，repositories元素下使用repository子元素声明一个或者多个远程仓库。我们需要注意的是，maven默认的中央仓库的id是central。</p>
<h2 id="依赖坐标搜索"><a href="#依赖坐标搜索" class="headerlink" title="依赖坐标搜索"></a>依赖坐标搜索</h2><p>使用maven进行日常开发的时候，一个常见的问题就是如何寻找需要的依赖，我们可以通过需要使用的类库的名字来找到maven依赖所需的坐标。</p>
<p>我们可以直接去maven的官方网站的中央仓库搜索也可以通过其他的搜索服务，比如：</p>
<p>地址：<a href="http://repository.sonatype.org/" target="_blank" rel="external">http://repository.sonatype.org/</a></p>
<p>Nexus是当前流行的开源maven仓库管理软件，提供了关键字搜索，类名搜索，坐标搜索等功能。</p>
<h1 id="生命周期与插件"><a href="#生命周期与插件" class="headerlink" title="生命周期与插件"></a>生命周期与插件</h1><p>在maven的日常使用中，命令行的输入往往就对应了生命周期，如mvn package就表示执行默认生命周期阶段package。maven的生命周期是抽象的，其实际行为都由插件来完成，如package阶段的任务可能就就会由maven-jar-plugin完成。</p>
<p>maven的生命周期就是为了对所有的构建过程进行抽象统一，包含了项目的清理，初始化，编译，测试，打包，集成测试，验证，部署和站点生成等几乎所有的构建步骤。所有的项目构建都能够映射到这样一个生命周期上。在maven的设计中，实际的任务(如编译源代码)都交由插件了完成。</p>
<p>maven定义的生命周期和插件机制一方面保证了所有maven项目有一致的构建标准，另一方面又通过默认插件简化和稳定了实际项目的构建。此外，该机制还提供了足够的扩展空间，用户可以通过配置现有的插件或者自行编写插件来自定义构建行为。</p>
<h2 id="三套生命周期"><a href="#三套生命周期" class="headerlink" title="三套生命周期"></a>三套生命周期</h2><p>maven拥有三套互相独立的生命周期，分别是clean,default和site。需要注意的是，生命周期之间是互相独立的，生命周期中的各个阶段是前后依赖的。</p>
<h3 id="clean生命周期"><a href="#clean生命周期" class="headerlink" title="clean生命周期"></a>clean生命周期</h3><p>clean生命周期的目的是清理项目，它包含三个阶段：</p>
<ol>
<li><p>pre-clean 执行一些清理前需要完成的工作</p>
</li>
<li><p>clean 清理上一次构建生成的文件</p>
</li>
<li><p>post-clean 执行一些清理后需要完成的工作</p>
</li>
</ol>
<h3 id="default生命周期"><a href="#default生命周期" class="headerlink" title="default生命周期"></a>default生命周期</h3><p>default生命周期定义了真正构建时所需要执行的所有步骤，它是所有生命周期中最核心的部分。</p>
<p>这里只列举一些常见的阶段：(按照先后顺序)</p>
<p>compile:编译项目的主源码。一般来说，是编译src/main/java目录下的java文件至项目输出的主classpath目录中</p>
<p>test-compile:编译项目的测试代码。一般来说，是编译src/test/java目录下的java文件至项目输出的主classpath目录中</p>
<p>test:使用单元测试框架运行测试，测试代码不会被打包或部署</p>
<p>package:接受编译好的代码，打包成可发布的格式，如jar</p>
<p>install:将包安装到maven本地仓库</p>
<p>deploy:将最终的包复制到远程仓库</p>
<h3 id="site生命周期"><a href="#site生命周期" class="headerlink" title="site生命周期"></a>site生命周期</h3><p>site生命周期的目的是建立和发布项目站点，maven能够基于POM所包含的信息，自动生成一格友好的站点，方便团队交流和发布项目信息。</p>
<p>pre-site:执行一些在生成项目站点之前需要完成的工作</p>
<p>site:生成项目站点文档</p>
<p>post-site:执行一些在生成项目站点之后需要完成的工作</p>
<p>site-deploy:将生成的项目站点发布到服务器上</p>
<h2 id="插件目标"><a href="#插件目标" class="headerlink" title="插件目标"></a>插件目标</h2><p>我们知道，maven的核心仅仅定义了抽象的生命周期，具体的任务是交由插件完成的，插件以独立的构件形式存在。对于插件本身，为了能够复用代码，它往往能够完成多个任务，因此这些功能聚集在一个插件里，每个功能就是一个插件目标。</p>
<p>maven的生命周期与插件互相绑定，用以完成实际的构建任务。具体而言，是生命周期的阶段与插件的目标互相绑定，以完成某个具体的构建任务。</p>
<p>几乎所有maven插件的目标都有一些可配置的参数，可以通过POM文件的配置来调整参数。关于插件的文档信息，我们可以参考Apache的maven官方网站上去获取。</p>
<h1 id="聚合与继承"><a href="#聚合与继承" class="headerlink" title="聚合与继承"></a>聚合与继承</h1><p>在这个技术飞速发展的时代，各类用户对软件的要求越来越高，软件本身也变得越来越复杂。因此，软件设计人员往往会采用各种方式对软件划分模块，以得到更清晰的设计以及更高的重用性。当把maven应用到实际项目中的时候，也需要将项目分成不用的模块。maven的聚合特性能够把项目的各个模块聚合在一起构建，而maven的继承特性则能够帮助抽取各个模块中相同的　依赖和插件等配置，在简化POM的同时，还能促进各个模块配置的一致性。</p>
<h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><p>当我们希望一次性构建多个项目，而不是到多个模块的目录下分别运行mvn命令。这个时候，就需要maven的聚合。</p>
<p>为了能够使用一条命令就能构建多个模块，我们需要创建一个额外的模块(聚合模块)，然后通过该模块构建整个项目的所有模块。额外的聚合模块的POM特殊在于：</p>
<p>packaging标签的值为:POM。对于非聚合模块，他们的packaging默认为jar。</p>
<p>modules元素，这是实现聚合的核心配置。我们可以通过在一个打包方式为POM的maven项目中声明任意数量的module元素(需要被聚合的模块)来实现模块的聚合，每一个module的值都是一个当前的POM的相对目录(需要被聚合的模块的目录相对与当前聚合模块POM的相对目录)。</p>
<p>为了方便构建，通常将聚合模块放在项目目录的最顶层，其他模块则作为聚合模块的子目录存在。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>maven里面的继承，准确的说是POM文件的继承。我们可以创建POM文件的父子结构，然后在父POM中声明一些配置提供给子POM继承，以实现”一处声明，多处使用”的目的。父POM的packaging为pom，这一点与聚合模块一样。</p>
<p>由于父模块只是为了帮助消除配置的重复，因此它本身不包含除POM之外的项目文件。</p>
<p>有了父模块，就需要让其他模块来继承它。子模块的POM中，使用parent元素来声明父模块，parent下的子元素groupId,artifactId,version指定了父模块的坐标，元素relativePath表示父模块POM的相对路径。当项目构建时，maven首先会根据ralativePath检查父模块的POM,如果找不到，再从本地仓库中查找。relativePath的默认值是 ../pom.xml　也就是说，maven默认父POM在上一层目录中。</p>
<h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p>在POM文件中，依赖是可以被继承的。maven提供dependencyManagement元素既能让子模块继承到父模块的依赖配置，又能保证子模块依赖使用的灵活。在dependencyManagement元素下的依赖声明不会引入实际的依赖，不过它能够约束dependencies下依赖的使用。使用dependencyManagement声明的依赖，不会给子模块引入依赖，但是可以被继承。在子模块中只需要声明依赖的使用，如果子模块不声明依赖的使用，即使该依赖已经在父POM的dependencyManagement中声明了，也不会产生任何实际的效果。</p>
<p>在dependencyManagement元素中有import依赖范围，使用该范围的依赖通常指向一个POM,作用是将目标POM中的dependencyManagement配置导入并合并到当前POM的dependencyManagement元素中。这里import表示导入配置的意思。</p>
<h3 id="插件管理"><a href="#插件管理" class="headerlink" title="插件管理"></a>插件管理</h3><p>类似地，maven也提供了pluginManagement元素帮助管理插件，在该元素下配置的依赖不会造成实际的插件调用行为，当POM中配置了真正的plugin元素，并且其groupId,artifactId与pluginManagement中的插件匹配时，pluginManagement的配置才会影响实际的插件行为。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/工具/">工具</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Maven/">Maven</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  


  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/JavaSE/" title="JavaSE">JavaSE<sup>9</sup></a></li>
		  
		
		  
			<li><a href="/categories/Linux/" title="Linux">Linux<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/一本正经/" title="一本正经">一本正经<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/工具/" title="工具">工具<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/算法/" title="算法">算法<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/计算机网络/" title="计算机网络">计算机网络<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/设计模式/" title="设计模式">设计模式<sup>3</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/多线程/" title="多线程">多线程<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/学习笔记/" title="学习笔记">学习笔记<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/胡说八道/" title="胡说八道">胡说八道<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/算法/" title="算法">算法<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/java8/" title="java8">java8<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/http协议/" title="http协议">http协议<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/策略模式/" title="策略模式">策略模式<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/https协议/" title="https协议">https协议<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/内部类/" title="内部类">内部类<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Linux/" title="Linux">Linux<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Shell/" title="Shell">Shell<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Maven/" title="Maven">Maven<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/模版方法模式/" title="模版方法模式">模版方法模式<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/设计模式原则/" title="设计模式原则">设计模式原则<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/编程题/" title="编程题">编程题<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">Weibo</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=2831891302&verifier=a2b6ee82&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Lujunqiu.This is my blog. <br/>
			As Kobe said,Somebody has to win, so why not be me?</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/2831891302" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2017 
		
		<a href="/about" target="_blank" title="Lujunqiu">Lujunqiu</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
