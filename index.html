<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Qiu homepage">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Qiu homepage">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Qiu homepage">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Qiu homepage</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Qiu homepage</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/19/Servlet学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lujunqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qiu homepage">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/19/Servlet学习笔记/" itemprop="url">Servlet学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-19T11:34:32+08:00">
                2017-10-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Servlet-API概述"><a href="#Servlet-API概述" class="headerlink" title="Servlet API概述"></a>Servlet API概述</h1><p>Servlet技术的核心是Servlet，它是所有Servlet类必须直接或间接实现的一个接口。Servlet接口定义了Servlet与Servlet容器之间的契约，归结起来就是，Servlet容器将Servlet类载入内存，并在Servlet实例上调用具体的方法。在一个应用程序中，每种Servlet类型只有一个实例。</p>
<p>用户请求致使Servlet容器调用Servlet的Service方法，并传入一个ServletRequest实例和一个ServletResponse实例。</p>
<p>对于每个应用程序，Servlet容器还会创建一个ServletContext实例，封装了上下文(应用程序)的环境详情。每个上下文只有一个ServletContext，每个Servlet实例也都有一个封装Servlet配置的ServletConfig。</p>
<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><p>Servlet接口中定义了以下5种方法：</p>
<ul>
<li>void init(ServletConfig config) throws ServletException</li>
<li>void service(ServletRequest request, ServletResponse response) throws ServletException, java.io.IOException</li>
<li>void destroy()</li>
<li>java.lang.String getServletInfo()</li>
<li>ServletConfig getServletConfig()</li>
</ul>
<p>init,service,destroy是生命周期方法。Servlet容器根据以下规则调用这3个方法：</p>
<ul>
<li>init：当该Servlet第一次被请求时，Servlet容器会调用这个方法，在后续的请求中不会再被调用，利用这个方法执行一些初始化的工作。</li>
<li>service：每当请求Servlet时，Servlet容器会调用这个方法</li>
<li>destroy：当要销毁Servlet时，Servlet容器就会调用这个方法，在这个方法中编写一些清除代码。</li>
</ul>
<p>Servlet中另外2个方法是非生命周期的，即getServletInfo和getServletConfig：</p>
<ul>
<li>getServletInfo：这个方法返回Servlet的描述</li>
<li>getServletConfig：这个方法返回由Servlet容器传给init方法的ServletConfig</li>
</ul>
<h2 id="Servlet中的类："><a href="#Servlet中的类：" class="headerlink" title="Servlet中的类："></a>Servlet中的类：</h2><ul>
<li>ServletRequest：对于每个HTTP请求，Servlet容器都会创建一个ServletRequest实例，并将它传给Servlet的service方法。其中getParameter是在ServletRequest中最常用的方法，用于返回HTML表单域的值。</li>
<li>ServletResponse：在调用Servlet的service方法前，Servlet容器首先创建一个ServletResponse，隐藏了向浏览器发送响应的过程。</li>
<li>ServletConfig：当Servlet容器初始化Servlet时，会给Servlet的init方法传入一个ServConfig，封装了可以通过@WebServlet或者部署描述符传给Servlet的配置信息(初始参数)</li>
<li>ServletContext：表示Servlet应用程序，每个Web应用程序只有一个上下文，保持在ServletContext中的对象被称为属性。</li>
</ul>
<h2 id="HttpServlet"><a href="#HttpServlet" class="headerlink" title="HttpServlet"></a>HttpServlet</h2><p>HttpServlet覆盖GenericServlet中的service方法，添加了一个新的service方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">protected void service(HttpServletRequest request,HttpServletResponse response)throws ServletException, java.io.IOException</div></pre></td></tr></table></figure>
<p>HttpServlet中的service方法会检查用来发送请求的HTTP方法(request.getMethod)，并调用以下方法之一：doGet，doPost，doHead，doPut，doTrace，doOptions和doDelete。所以，我们不需要覆盖service方法，而是覆盖doGet，doPost(最常用)即可。</p>
<h2 id="部署描述符"><a href="#部署描述符" class="headerlink" title="部署描述符"></a>部署描述符</h2><p>Web应用的部署描述符总是命名为web.xml，并且放在WEB-INF目录下，在里面可以配置Servlet的路径映射等等，同时部署描述符还允许覆盖在Servlet注解中定义的值。</p>
<h1 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h1><p>我们知道HTTP协议是无状态性的协议，默认情况下，Web服务器是无法区分一个HTTP请求是否为第一次访问的。会话管理是Web应用开发一个无可避免的话题，以下介绍4种会话管理的方法。</p>
<h2 id="URL重写"><a href="#URL重写" class="headerlink" title="URL重写"></a>URL重写</h2><p>顾名思义，URL重写将一个或多个token添加到URL的查询字符串中，每个token通常为key=value形式，URL和token之间用问号(?)分割，token之间用与号(&amp;)，如下：<br>url?key-1=value-1&amp;key-2=value-2 … &amp;key-n=value-n</p>
<p>根据上面的描述，URL重写来管理会话适合于信息仅在少量页面间传递，且信息本身不敏感的情况。URL重写需要在服务端上完成，所有的链接都带值，也就是说，静态页面很难传值。</p>
<h2 id="隐藏域"><a href="#隐藏域" class="headerlink" title="隐藏域"></a>隐藏域</h2><p>使用隐藏域来保持状态类似于URL重写技术，但不是将值附加到URL上，而是放到HTML表单的隐藏域中(post方法提交)。当表单提交时，隐藏域的值也同时提交到服务器，同样也不适合跨越多个界面。</p>
<h2 id="cookies"><a href="#cookies" class="headerlink" title="cookies"></a>cookies</h2><p>URL重写和隐藏域仅适合保存无须跨越太多页面的信息。如果需要在多个页面间传递，我们可以适用cookies，cookies作为HTTP header的一部分，其传输有HTTP协议控制。</p>
<p>要适用cookies，需要熟悉javax.servlet.http.Cookie类。我们可以通过传递name和value两个参数给Cookie类的构造函数，创建一个cookies：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Cookie cookie = new Cookie(name,value);</div></pre></td></tr></table></figure>
<p>创建完一个cookies之后，我们还可以设置cookies的有效时间maxAge，和domain，path等特性。</p>
<p>要将cookies发送给浏览器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">httpServletResponse.addCookie(cookie);</div></pre></td></tr></table></figure>
<p>服务器通过HttpServletReq的getCookies方法读取cookies，该方法返回一个Cookie数组，遍历查找所需要的cookies即可。</p>
<h2 id="HTTPSession"><a href="#HTTPSession" class="headerlink" title="HTTPSession"></a>HTTPSession</h2><p>HTTPSession对象在用户第一次访问网站的时候自动被创建，可以通过HttpServletRequest的getSession方法获取该对象，一个用户可以有且最多有一个HttpSession，放入到HttpSession的值，是存储在内存中的，也可以在服务器端转储到二级存储中。放到HttpSession的值不限于String类型，可以是任意实现java.io.Serializable的java对象，因为在内存不够用的时候，要将这些值放入文件或者数据库中。</p>
<p>大部分情况下，应该设置会话过期时间或者主动销毁无用的会话，以便释放相应的内存。</p>
<p>所有保存在HttpSession的数据不会被发送到客户端，Servlet容器为每个HttpSession生成唯一的标识，并将该标识发送给浏览器，或创建一个名为JSESSIONID的cookie，或者在URL后面附加一个名为jsessionid的参数，在后续的请求中，浏览器只需要将标识id发给服务器即可。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/13/MySQL的锁问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lujunqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qiu homepage">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/13/MySQL的锁问题/" itemprop="url">MySQL的锁问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-13T15:18:42+08:00">
                2017-10-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>MySQL的锁机制最显著的特点就是不同的存储引擎支持不同的锁机制。比如，MyISAM存储引擎采用的是表级锁；InnoDB存储引擎既支持行级锁，也支持表级锁，但默认情况下采用行级锁。</p>
<p>上述的2种锁的特性如下：</p>
<ul>
<li>表级锁：开销小，加锁快；不会出现死锁，锁定粒度大，发生锁冲突的概率最高，并发度最低。</li>
<li>行级锁：开销大，加锁慢；会出现死锁，锁定粒度小，发生锁冲突的概率最低，并发度最高。</li>
</ul>
<h1 id="MyISAM表锁"><a href="#MyISAM表锁" class="headerlink" title="MyISAM表锁"></a>MyISAM表锁</h1><p>MySQL的表级锁有2种：表共享锁(Table Read Lock)和表独占锁(Table Write Lock)。这2种之间的兼容性：对MyISAM表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写操作；对MyISAM表的写操作，则会阻塞其他用户对同一表的读和写请求；</p>
<p>MyISAM在执行查询语句(select)之前，会自动给涉及的所有表加读锁，在执行更新操作(updata,delete,insert等)之前，会自动给涉及的表加写锁，这个过程并不需要用户干预。给MyISAM表显示加锁，一般是为了在一定程度模拟事物操作，实现对某一时间点多个表的一致性读取。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Lock tables orders read local, order_detail read local;</div><div class="line">select sum(total) from orders;</div><div class="line">select sum(subtotal) from order_detail;</div><div class="line">unlock tables;</div></pre></td></tr></table></figure>
<ul>
<li>在用lock tables给表显式加表锁时，必须同时取得所有涉及表的锁，并且不支持表升级。也就是说，在执行lock tables后，只能访问显式加锁的这些表，不能访问未加锁的表；MyISAM总是一次获得SQL语句所需要的全部锁，所以不会出现死锁。</li>
<li>在上面read锁后加了local选项，作用就是在满足MyISAM表并发插入条件的情况下，允许其他用户在表尾并发插入记录。</li>
</ul>
<p>MyISAM存储引擎有一个系统变量concurrent_insert，专门用以控制其并发插入的行为：</p>
<ul>
<li>concurrent_insert = 0，不运行并发插入</li>
<li>concurrent_insert = 1，如果MyISAM表中没有空洞(即表的中间没有被删除的行)，MyISAM允许在一个进程读表的同时，另一个进程从表尾插入记录，这是默认的设置。我们可以使用 optimize table table_name 命令来进行表优化，可以将表中的空间碎片进行合并，消除由于删除或者更新造成的空间浪费。</li>
<li>concurrent_insert = 2,无论是否有空洞，都运行在表尾并发插入记录</li>
</ul>
<p>关于MyISAM的锁调度问题，MySQL认为写请求一般比读请求要重要，所以一般写进程会优先获得锁，如果有大量更新操作和查询操作，那么大量的更新操作会造成查询操作难获取读锁，从而降低查询效率。</p>
<h1 id="InnoDB锁问题"><a href="#InnoDB锁问题" class="headerlink" title="InnoDB锁问题"></a>InnoDB锁问题</h1><p>InnoDB与MyISAM的最大不同有两点：一是支持事务(transaction)；二是采用了行级锁。</p>
<h2 id="事务属性"><a href="#事务属性" class="headerlink" title="事务属性"></a>事务属性</h2><p>事务是由一组SQL语句组成的逻辑处理单元，具有以下属性(ACID属性)：</p>
<ul>
<li>原子性(Atomicity):事务是一个原子操作单元，其对数据的修改，要么全部执行，要么全部都不执行。</li>
<li>一致性(Consistent)：在事务开始和完成时，数据都必须保持一致性状态。</li>
<li>隔离性(Isolation)：事务可以在不受外部并发操作影响的“独立”环境执行，也就是说事务处理过程中的中间状态对外部是不可见的。</li>
<li>持久性(Durable)：事务完成之后，对于数据的修改是永久性的。</li>
</ul>
<h2 id="事物隔离级别"><a href="#事物隔离级别" class="headerlink" title="事物隔离级别"></a>事物隔离级别</h2><ul>
<li>脏读：一个事务正在对一条记录做修改，在修改未提交之前，这些数据就处于不一致的状态，如果这时其他事务也来读取这些记录，就产生了脏读。</li>
<li>不可重复读：一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，发现读出的数据已经发生了改变或者某些记录已经被删除了。所以不可重复读重点在于update和delete操作。</li>
<li>幻读：一个事务按相同的查询条件重新读取以前检索过的数据，发现其他事务插入了满足其查询条件的新数据。所以幻读的重点在于insert操作。</li>
</ul>
<p>“脏读”，“不可重复读”和“幻读”都是数据库读一致性的问题，可以由数据库提供的一定的事务隔离机制来解决，数据库实现事务隔离的方式，有以下两种：</p>
<ul>
<li>在读取数据前，对其加锁，阻止其他事务对数据修改</li>
<li>不加任何锁，通过一定机制生成一个数据请求时间点的一致性数据快照，并用这个快照来提供一定级别的一致性读取。从用户的角度来看，好像是数据库可以提供一个数据的多个版本，称为数据多版本并发控制(MultiVersion Concurrency Control,简称MVCC)。</li>
</ul>
<p>在不同的隔离级别下，InnoDB处理SQL时采用的一致性读策略和需要的锁是不同的。</p>
<p><img src="../../../../img/mysql/geli.png" alt=""></p>
<h2 id="InnoDB的锁"><a href="#InnoDB的锁" class="headerlink" title="InnoDB的锁"></a>InnoDB的锁</h2><p>在介绍InnoDB的锁之前，我们先学习并发控制的机制，分为两种：悲观锁和乐观锁。</p>
<h3 id="悲观锁与乐观锁"><a href="#悲观锁与乐观锁" class="headerlink" title="悲观锁与乐观锁"></a>悲观锁与乐观锁</h3><ul>
<li>悲观锁:它会在获取资源前对资源进行加锁，确保同一时刻只有有限的线程能够访问该资源，其他想要尝试获取资源的操作都会进入等待状态，直到该线程完成了对资源的操作并且释放了锁后，其他线程才能重新操作资源。</li>
<li>乐观锁：它其实并不是一种真正的锁，是一种思想。它会先尝试对资源进行修改，在写回时判断资源是否进行了改变，如果没有发生改变就会写回，否则就会进行重试，在整个的执行过程中其实都没有对数据库进行加锁。比如Java的并发包底层实现用到的CAS操作，就是乐观锁的例子。</li>
</ul>
<p>关于悲观锁和乐观锁的优劣在于，乐观锁不会存在死锁的问题，但是由于更新后验证，所以当冲突频率和重试成本较高时更推荐使用悲观锁，而需要非常高的响应速度并且并发量非常大的时候使用乐观锁就能较好的解决问题，在这时使用悲观锁就可能出现严重的性能问题。</p>
<h3 id="InnoDB的行锁模式"><a href="#InnoDB的行锁模式" class="headerlink" title="InnoDB的行锁模式"></a>InnoDB的行锁模式</h3><p>InnoDB存储引擎中使用的就是悲观锁，而按照锁的粒度划分，也可以分成行锁和表锁。</p>
<p>InnoDB实现以下两种行锁：</p>
<ul>
<li>共享锁：允许一个事务去读一行，阻止其他事务获取相同数据集的排他锁</li>
<li>排他锁：允许获取排他锁的事务更新数据，阻止其他事务取得相同数据集的共享锁和排他锁</li>
</ul>
<p>事务可以通过以下语句给记录集加共享锁或排他锁：</p>
<ul>
<li>共享锁：select * from table_name where … lock in share mode</li>
<li>排他锁：select * from table_name where … for update</li>
</ul>
<p>为了支持多粒度锁定，InnoDB存储引擎引入了意向锁，意向锁就是一种表级锁。而且意向锁是InnoDB自动加的，不需用户干预。</p>
<ul>
<li>意向共享锁：事务想要在获得表中某些记录的共享锁，需要在表上先加意向共享锁；</li>
<li>意向互斥锁：事务想要在获得表中某些记录的互斥锁，需要在表上先加意向互斥锁；</li>
</ul>
<p>关于意向锁的作用，可以举一个例子：如果没有意向锁，当已经有人使用行锁对表中的某一行进行修改时，如果另外一个请求要对全表进行修改，那么就需要对所有的行是否被锁定进行扫描，在这种情况下，效率是非常低的；不过，在引入意向锁之后，当有人使用行锁对表中的某一行进行修改之前，会先为表添加意向互斥锁，再为行记录添加互斥锁，在这时如果有人尝试对全表进行修改就不需要判断表中的每一行数据是否被加锁了，只需要通过等待意向互斥锁被释放就可以了。</p>
<h3 id="InnoDB行锁实现方式"><a href="#InnoDB行锁实现方式" class="headerlink" title="InnoDB行锁实现方式"></a>InnoDB行锁实现方式</h3><p>InnoDB行锁是通过给索引上的索引项加锁来实现的，如果没有索引，InnoDB将通过隐藏的聚簇索引来对记录加锁。InnoDB行锁分为3种情形。</p>
<ul>
<li>Record lock：对索引项加锁</li>
<li>Gap lock：对索引之间的“间隙”加锁</li>
<li>Next-key lock：对记录以及记录的两侧的间隙加锁</li>
</ul>
<p>InnoDB这种行锁实现特点意味着：如果不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，实际效果和表锁一样。</p>
<p>下面介绍Next-key锁：当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙”，同样InnoDB也会给这个“间隙”加锁。</p>
<p>举个例子：</p>
<p><img src="../../../../img/mysql/next-key.png" alt=""></p>
<p>当我们更新一条记录，比如”SELECT * FROM users WHERE age = 30 FOR UPDATE;” ，InnoDB 不仅会在范围 (21, 30] 上加 Next-Key 锁，还会在这条记录后面的范围 (30, 40] 加间隙锁，所以插入 (21, 40] 范围内的记录都会被锁定。</p>
<p>虽然间隙锁中也分为共享锁和互斥锁，不过它们之间并不是互斥的，也就是不同的事务可以同时持有一段相同范围的共享锁和互斥锁，它唯一阻止的就是其他事务向这个范围中添加新的记录。并且间隙锁是存储引擎对于性能和并发做出的权衡，并且只用于某些事务隔离级别，防止幻读。</p>
<h3 id="MVCC在MySQl中的实现"><a href="#MVCC在MySQl中的实现" class="headerlink" title="MVCC在MySQl中的实现"></a>MVCC在MySQl中的实现</h3><p>MVCC属于乐观锁的思想，它的实现没有固定的规范，每个数据库都会有不同的实现方式。在InnoDB中，会在每行数据后添加两个额外的隐藏的值来实现MVCC，这两个值一个记录这行数据何时被创建，另外一个记录这行数据何时过期。 在实际操作中，存储的并不是时间，而是事务的版本号，每开启一个新事务，事务的版本号就会递增。通过MVCC，虽然每行记录都需要额外的存储空间，更多的行检查工作以及一些额外的维护工作，但可以减少锁的使用，大多数读操作都不用加锁，读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行，也只锁住必要行。</p>
<p>在RR级别中，通过MVCC机制，虽然让数据变得可重复读，但我们读到的数据可能是历史数据，是不及时的数据，不是数据库当前的数据。这在一些对于数据的时效特别敏感的业务中，就很可能出问题。对于这种读取历史数据的方式，我们叫它快照读，而读取数据库当前版本数据的方式，叫当前读。</p>
<p>快照读：</p>
<ul>
<li>selece * from table_name … </li>
</ul>
<p>当前读：特殊的读操作，插入/更新/删除操作，属于当前读，处理的都是当前的数据，需要加锁</p>
<ul>
<li>select * from table_name where…lock in share mode;</li>
<li>select * from table_name where…for update;</li>
<li>insert into table_name …</li>
<li>update table_name set …</li>
<li>delete from table_name …</li>
</ul>
<p>事务的隔离级别实际上都是定义了当前读的级别，MySQL为了减少锁处理的时间，提升并发能力，引入了快照读的概念，使得select不用加锁。</p>
<p>在RR级别也消除了一部分的幻读问题，行锁防止别的事务修改或删除，GAP锁防止别的事务新增，行锁和GAP锁结合形成的的Next-Key锁共同解决了RR级别在写数据时的幻读问题。</p>
<p>但是在Serializable级别来消除幻读就很简单，读加共享锁，写加排他锁，读写互斥。使用的悲观锁的理论，实现简单，数据更加安全，但是并发能力非常差。如果你的业务并发的特别少或者没有并发，同时又要求数据及时可靠的话，可以使用这种模式。所以在Serializable这个级别，会给select操作加锁。</p>
<h3 id="复制和恢复对锁机制的影响"><a href="#复制和恢复对锁机制的影响" class="headerlink" title="复制和恢复对锁机制的影响"></a>复制和恢复对锁机制的影响</h3><p>MySQL的恢复和复制和InnoDB锁机制和一致性读策略也有较大影响。例如，对于  “insert into target_tab select <em> from source_tab where …”和”create table new_tab … select … from source_tab where …”这种SQL语句，MySQL没有使用对并发影响最小的多版本数据来实现一致性读，而是给source_tab加锁，阻止对source_tab的更新，就是为了保证恢复和复制的正确性。<br>当然，我们如果使用基于行的binlog日志来恢复和复制就不会存在上述问题，或者使用”select </em> from source_tab … into outfile…” 和 “ load data infile …”语句组来实现上述功能，不会对source_tab加锁。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>MyISAM表锁是deadlock free的，因为MyISAM总是一次获取所需的全部锁，要么全部满足，要么等待，因此不会出现死锁。但是在InnoDB中，除了单个SQL组成的事务外，锁是逐步获取的，并且InnoDB中实现的锁是悲观的，那么不同事务之间就可能会互相等待对方释放锁造成死锁。</p>
<p>如果出现死锁，可以用<code>show innodb status \G</code>命令来确定最后一个死锁产生的原因。</p>
<p>在了解锁机制后，我们可以调整SQL来减少锁冲突，包括以下几项：</p>
<ul>
<li>在符合业务要求的情况下，尽量使用低的事务隔离级别</li>
<li>尽量使用索引来访问数据，加锁更加精确</li>
<li>给记录集加锁时，一次性请求足够级别的锁。</li>
<li>不同的程序访问一组表时，尽量约定用相同的顺序访问各表；对单个表而言，尽量用以固定的顺序存钱表中的行</li>
<li>尽量使用相等条件访问数据，避免Next-key锁对并发插入的影响</li>
<li>对于特定的事务，可以使用表锁来避免死锁</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/01/Mysql学习笔记-索引/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lujunqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qiu homepage">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/01/Mysql学习笔记-索引/" itemprop="url">Mysql学习笔记---索引</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-01T09:11:20+08:00">
                2017-10-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Mysql索引的数据结构"><a href="#Mysql索引的数据结构" class="headerlink" title="Mysql索引的数据结构"></a>Mysql索引的数据结构</h1><p>查询功能是数据库最为常用的功能之一，为了提高查询的效率，我们学习了很多查询算法。最基本的查询算法是顺序查找，这种复杂度为O(n)的算法在数据量很大时显然是不合适的。除了顺序查找我们还了解其他查询算法，例如二分查找、二叉树查找等。但是每种查找算法都只能应用于特定的数据结构之上，例如二分查找要求被检索数据有序，而二叉树查找只能应用于二叉查找树上，数据本身的组织结构不可能完全满足各种数据结构。所以在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p>
<h2 id="B-Tree和B-Tree"><a href="#B-Tree和B-Tree" class="headerlink" title="B-Tree和B+Tree"></a>B-Tree和B+Tree</h2><p><em>B-Tree:</em></p>
<ol>
<li>非叶子结点的关键字个数=指向儿子的指针个数-1，关键字和指针互相间隔，关键字两端是指针</li>
<li>非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]</li>
<li>非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树</li>
<li>所有叶子结点位于同一层</li>
</ol>
<p>如图所示：</p>
<p><img src="../../../../img/mysql/b-tree.png" alt=""></p>
<p>B-Tree的搜索：从根节点开始，对节点内有序的关键字序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点；</p>
<p>通过上图的示例，B-Tree区别于B+Tree有如下特点：</p>
<ol>
<li>关键字集合分布在整颗树中</li>
<li>搜索有可能在非叶子结点结束</li>
<li>任何一个关键字出现且只出现在一个结点中 </li>
</ol>
<p><em>B+Tree:</em></p>
<p>B+Tree是B-Tree的变体，也是一种多路搜索树，其定义基本与B-Tree相同，除了：</p>
<ol>
<li>非叶子结点的子树指针与关键字个数相同</li>
<li>非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-Tree是开区间）</li>
<li>所有关键字都在叶子结点出现</li>
<li>为所有叶子结点增加一个链指针</li>
</ol>
<p>如图所示：</p>
<p><img src="../../../../img/mysql/b+tree.png" alt=""></p>
<p>B+Tree的搜索与B-Tree基本相同，区别是B+Tree只有达到叶子结点才命中(B-Tree可以在非叶子结点命中),其性能也等价于在关键字全集做一次二分查找。</p>
<p>B+Tree的特点:</p>
<ol>
<li>所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的</li>
<li>非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层</li>
<li>更适合文件索引系统</li>
<li>在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree.做这个优化的目的是为了提高区间访问的性能，例如上图中如果要查询key为从20到90的所有数据记录，当找到20后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。</li>
</ol>
<h2 id="为什么要使用B-Tree和B-Tree"><a href="#为什么要使用B-Tree和B-Tree" class="headerlink" title="为什么要使用B-Tree和B+Tree?"></a>为什么要使用B-Tree和B+Tree?</h2><p>MySQL在执行读操作时，会先从数据库的缓冲区中读取，如果不存在与缓冲区中就会尝试从内存中加载页面，如果前面的两个步骤都失败了，最后就只能执行随机IO从磁盘中获取对应的数据页。</p>
<p>我们知道内存存取的时间仅与存取次数呈线性关系(因为地址总线和数据总线配合存取)，因为不存在机械操作，两次存取的数据的“距离”不会对时间有任何影响，例如，先取A0再取A1和先取A0再取D3的时间消耗是一样的。但是一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。</p>
<h3 id="磁盘存取原理"><a href="#磁盘存取原理" class="headerlink" title="磁盘存取原理"></a>磁盘存取原理</h3><p>与主存不同，磁盘I/O存在机械运动耗费，因此磁盘I/O的时间消耗是巨大的。</p>
<p>磁盘的整体结构如图：</p>
<p><img src="../../../../img/mysql/cipan.png" alt=""></p>
<p>一个磁盘由大小相同且同轴的圆形盘片组成，磁盘可以转动（各个磁盘必须同步转动）。在磁盘的一侧有磁头支架，磁头支架固定了一组磁头，每个磁头负责存取一个磁盘的内容。磁头不能转动，但是可以沿磁盘半径方向运动。</p>
<p>磁盘的俯视视角如图：</p>
<p><img src="../../../../img/mysql/cipan2.png" alt=""></p>
<p>磁头（head）：对磁盘的数据进行读写<br>磁道（track）：当磁盘旋转时，磁头若保持在一个位置上，则每个磁头都会在磁盘表面划出一个圆形轨迹，这些圆形轨迹就叫做磁道<br>扇区（sector）：磁盘上的每个磁道被等分为若干个弧段，这些弧段便是硬盘的扇区，扇区是磁盘的最小存储单元</p>
<p>当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间。</p>
<h3 id="磁盘预读"><a href="#磁盘预读" class="headerlink" title="磁盘预读"></a>磁盘预读</h3><p>数据库对数据的读取并不是以行为单位进行的，无论是读取一行还是多行，都会将该行或者多行所在的页全部加载进来，然后再读取对应的数据记录；也就是说，读取所耗费的时间与行数无关，只与页数有关。所以磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。因为我们推测当一个数据被用到时，其附近的数据也通常会马上被使用。由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。</p>
<p>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p>
<h3 id="B-Tree与磁盘结合"><a href="#B-Tree与磁盘结合" class="headerlink" title="B-/+Tree与磁盘结合"></a>B-/+Tree与磁盘结合</h3><p>首先，我们可以分析红黑树这类平衡二叉查找树是否适合磁盘存储。红黑树的树高h一般很大，而且逻辑很近的节点（父子）物理上可能相距很远，无法利用局部性，增加了磁头寻道和磁盘旋转的时间，所以不适合磁盘存储。</p>
<p>而我们使用B＋Tree的时候，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入，所以B＋Tree作为磁盘的存储结构是合适的。</p>
<h2 id="Mysql索引实现"><a href="#Mysql索引实现" class="headerlink" title="Mysql索引实现"></a>Mysql索引实现</h2><p>在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的。</p>
<h3 id="MyISAM索引实现"><a href="#MyISAM索引实现" class="headerlink" title="MyISAM索引实现"></a>MyISAM索引实现</h3><p>MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。</p>
<p><img src="../../../../img/mysql/myisam.png" alt=""></p>
<p>如上图所示表一共有三列，假设我们以Col1为主键，则这是一个MyISAM表的主索引示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p>
<h3 id="InnoDB索引实现"><a href="#InnoDB索引实现" class="headerlink" title="InnoDB索引实现"></a>InnoDB索引实现</h3><p>虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。第一个重大区别是InnoDB的数据文件本身就是索引文件。在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p>
<p>InnoDB索引叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。所以我们不建议用非单调的字段作为InnoDB表的主键，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</p>
<p>第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。</p>
<p>聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p>
<p>MySQL使用InnoDB存储表时，会将表的定义和数据索引等信息分开存储，其中前者存储在.frm文件中，后者存储在.ibd文件中。</p>
<h2 id="索引使用优化"><a href="#索引使用优化" class="headerlink" title="索引使用优化"></a>索引使用优化</h2><h3 id="索引片（Index-Slices）"><a href="#索引片（Index-Slices）" class="headerlink" title="索引片（Index Slices）"></a>索引片（Index Slices）</h3><p>索引片其实就是 SQL 查询在执行过程中扫描的一个索引片段，在这个范围中的索引将被顺序扫描，根据索引片包含的列数不同将索引分为宽索引和窄索引：</p>
<p><img src="../../../../img/mysql/suoyin1.png" alt=""></p>
<p>宽索引能够避免二次的随机IO，而窄索引就需要在对索引进行顺序读取之后再根据主键id从主键索引中查找对应的数据，对于窄索引，每一个在索引中匹配到的记录行最终都需要执行另外的随机读取从聚集索引中获得剩余的数据，如果结果集非常大，那么就会导致随机读取的次数过多进而影响性能。</p>
<h3 id="过滤因子"><a href="#过滤因子" class="headerlink" title="过滤因子"></a>过滤因子</h3><p>一个 SQL 查询扫描的索引片大小其实是由过滤因子决定的，也就是满足查询条件的记录行数所占的比例。比如users表中sex=’male’占50%，age＝’21’占12%，name=’jack’占0.1%。对于users表来说，sex=”male” 就不是一个好的过滤因子，它会选择整张表中一半的数据，所以在一般情况下我们最好不要使用sex列作为整个索引的第一列；而name=”draven”的使用就可以得到一个比较好的过滤因子了，它的使用能过滤整个数据表中99.9%的数据。</p>
<p>当三个过滤条件都是等值谓词时，几个索引列的顺序其实是无所谓的，索引列的顺序不会影响同一个SQL语句对索引的选择，也就是索引 (name, age, sex) 和 (age, sex, name) 在执行查询时都有着完全相同的效果。</p>
<p>这里我们还可以介绍一下MySQL的一个查询优化的措施，当需要读取的数据超过一个临界值时，优化器会放弃从索引中读取而改为进行全表扫描，这是为了避免过多的随机磁盘读取。因为根据索引进行的查询可以认为是随机磁盘读，索引里的顺序，和磁盘上的顺序不同，按索引的顺序读，就会不断要求访问磁盘里不同位置的数据，这对Cache不友好。比如，如果添加了索引的字段重复率很高,比如性别,不是男就是女。这时使用索引(随机读)的效率,还不如直接进行全表扫描(顺序读).</p>
<h3 id="最左前缀原理"><a href="#最左前缀原理" class="headerlink" title="最左前缀原理"></a>最左前缀原理</h3><ol>
<li>仅仅使用索引中的最左边列进行查找，比如在col1+col2+col3 字段上的联合索引能够被包含col1，(col1+col2),(col1+col2+col3)的等值查询利用到，可是不能够被col2，(col2+col3)的等值查询利用到；</li>
<li>仅仅对索引进行查询，当查询的列都在索引的字段中的，查询的效率更高。这个时候我们用explain语句输出的Extra部分变成了Using index，也就意味着，直接访问索引就足够获取到所需要的数据，不需要通过索引回表(Using where)，Using index也就是平常说的覆盖索引扫描；</li>
<li>字段的范围列可以用到索引（必须是最左前缀），但是范围列后面的列无法用到索引。同时，索引最多用于一个范围列，因此如果查询条件中有两个范围列则无法全用到索引。</li>
</ol>
<h3 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h3><p>以下图表中的(name,cid)的复合索引为例，从逻辑上来看内部结构应该是这样的：</p>
<p><img src="../../../../img/mysql/suoyin2.png" alt=""></p>
<p>mysql创建复合索引的规则是首先会对复合索引的最左边，也就是第一个name字段的数据进行排序，在第一个字段排序的基础上，然后再对第二个字段cid进行排序。所以，第一个name字段是绝对有序的，而第二个字段就是无序的，直接使用第二个字段cid进行调解判断是用不到索引的。</p>
<p>那么什么时候可以用到第二个字段的索引呢？还是上面的例子，当第一个字段name是等值匹配的情况下，cid才是有序的。这也就是为什么mysql索引规则中要求复合字段想要用到第二个索引，必须先使用第一个索引的原因，而且第一个索引必须是等值匹配。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/16/Java多线程学习笔记-五/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lujunqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qiu homepage">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/16/Java多线程学习笔记-五/" itemprop="url">Java多线程学习笔记(五)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-16T22:01:22+08:00">
                2017-09-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaSE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaSE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java内存模型基础"><a href="#Java内存模型基础" class="headerlink" title="Java内存模型基础"></a>Java内存模型基础</h1><p>在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。Java的并发采用的就是共享内存模型，线程之间共享程序的公共状态，通过写－读内存中的公共状态进行隐式通信。</p>
<p>Java线程之间的通信由Java内存模型(JMM)控制，JMM通过控制主内存与每个线程的本地内存之间的交互来决定了一个线程对共享变量的写入何时对另一个线程可见。</p>
<p>JMM定义了线程和主内存之间的抽象关系:线程之间的共享变量存储在主内存中,每个线程都有一个私有的本地内存,本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念,并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。但是这里需要说明的是，由于写缓存仅对自己的处理器可见，它会导致处理器执行内存操作的顺序与内存实际的操作顺序不一致，因为只有在JMM将缓存区数据刷新到内存中，才算完成了对内存的实际的操作。<br><img src="../../../../img/bingfa/3-1.png" alt=""></p>
<h1 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h1><p>重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。从Java源代码到最终实际执行的指令序列，会分别经历3种重排序。<br><img src="../../../../img/bingfa/3-3.png" alt=""></p>
<ol>
<li>编译器优化的重排序：编译器在不改变单线程程序语义的前提下,可以重新安排语句的执行顺序。</li>
<li>指令级并行的重排序：如果不存在数据依赖性,处理器可以改变语句对应机器指令的执行顺序，将多条指令重叠执行。</li>
<li>内存系统的重排序：使用了读／写缓存区，导致加载和存储的顺序改变。</li>
</ol>
<p>编译器和处理器在重排序的时候，会遵守数据依赖性(仅针对单个处理器和单个线程的操作指令)，也就是说不会改变存在数据依赖关系的两个操作的执行顺序。同样，为了提高并行度，编译器和处理器不管怎么重排序，单线程的执行结果不会改变，这就是内存模型中as-if-serial语义的内容。</p>
<p>但是在并发编程中，如果不理会这些重排序优化则很可能出现内存可见性问题。我们可以通过JMM来禁止特定类型的编译器重排序和处理器重排序(通过插入特定类型的内存屏障指令，实现对内存操作的顺序限制)，来保证多线程情况下的内存可见性。</p>
<p>这里我们补充说明一点，JMM不保证对64位的long型和double型变量的写操作具有原子性(分为2个32位的写总线事物)，但是在JDK5之后，保证其读操作是具有原子性的。</p>
<h1 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h1><p>happens-before：在JMM中，如果一个操作执行的结果需要对另一个操作操作可见，那么这两个操作之间必须要存在happens-before关系。</p>
<p>需要说明的是，上面提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间的，而且并不意味着前一个操作必须要在后一个操作之前执行，仅仅要求前一个操作(执行结果)对后一个操作可见。</p>
<p>happens-before规则如下:</p>
<ul>
<li>程序顺序规则：单个线程中的每个操作，happens-before于该线程中的任意后续操作</li>
<li>监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁</li>
<li>volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读</li>
<li>传递性：如果A happens-before B ，且B happens-before C，那么A happens-before C</li>
<li>join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回</li>
</ul>
<h1 id="volatile的内存语义"><a href="#volatile的内存语义" class="headerlink" title="volatile的内存语义"></a>volatile的内存语义</h1><p>volatile变量自身具有以下特性：</p>
<ul>
<li>可见性：对一个volatile变量的读，总是能看到(任意线程)对这个volatile变量最后的写入</li>
<li>原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性</li>
</ul>
<p>从内存语义的角度来说，volatile的写-读与锁的释放-获取有相同的内存效果：</p>
<ul>
<li>volatile写：当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存</li>
<li>volatile读：当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来将从主内存中读取共享变量</li>
</ul>
<p>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</p>
<p><img src="../../../../img/bingfa/3-16.png" alt=""></p>
<p>在上图中，黑色箭头表示happens－before的程序顺序规则，橙色箭头表示volatile规则，蓝色箭头表示happens－before关系的传递性。</p>
<p>另外，Java的CAS操作同时具有volatile读和volatile写的内存语义，是整个concurrent包得以实现的基石。</p>
<h1 id="锁的内存语义"><a href="#锁的内存语义" class="headerlink" title="锁的内存语义"></a>锁的内存语义</h1><p>锁是Java并发编程中最重要的同步机制，除了让临界区互斥执行外，还可以让释放锁的线程向获取同一个锁的线程发送消息。</p>
<p>从内存语义的角度来说：</p>
<ul>
<li>释放锁：先线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中</li>
<li>获取锁：JMM会把该线程对应的本地内存置为无效，从而使得被监视器保护的临界区代码必须从主内存中读取共享变量</li>
</ul>
<h1 id="final域的内存语义"><a href="#final域的内存语义" class="headerlink" title="final域的内存语义"></a>final域的内存语义</h1><p>对于final域，编译器和处理器要遵守两个重排序规则：</p>
<ol>
<li>在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序</li>
<li>初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序，确保在读一个对象域之间，一定会先读包含这个final域的对象引用</li>
</ol>
<p>从上面两个规则我们可以知道，写final域的重排序规则禁止把final域的写重排序到构造函数之外，编译器会在final域的写之后，构造函数return之前，插入一个StoreStore屏障。我们可以确保，在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域不具有这个保障。</p>
<p><img src="../../../../img/bingfa/3-29.png" alt=""></p>
<p>同时我们需要保证在构造函数内部，不能让这个被构造对象的引用为其他线程所见，也就是对象引用不能在构造函数中“逸出”。</p>
<p>于是JMM提供了初始化安全保证：只要对象是正确构造的(被构造对象的引用在构造函数中没有“逸出”)，那么不需要使用同步，就可以保证任意线程都能看到这个final域在构造函数中被初始化之后的值。</p>
<h1 id="双重检查锁定解决多线程中的单例"><a href="#双重检查锁定解决多线程中的单例" class="headerlink" title="双重检查锁定解决多线程中的单例"></a>双重检查锁定解决多线程中的单例</h1><p>在Java多线程程序中，有时候需要使用单例模式，并采用延迟初始化来降低初始化类和创建对象的开销，人们首先提出了双重锁定检查来降低使用synchronized来锁定方法的同步开销，示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> class <span class="title">DoubleCheckedLocking</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Instance instance;                  <span class="comment">//2</span></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span></span>&#123;              <span class="comment">//3</span></div><div class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;                          <span class="comment">//4:第一次检查</span></div><div class="line">            <span class="keyword">synchronized</span>(DoubleCheckedLocking.class)&#123;  <span class="comment">//5：加锁</span></div><div class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)                   <span class="comment">//6：第二次检查</span></div><div class="line">                    instance = <span class="keyword">new</span> Instance();         <span class="comment">//7</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先，上面的双重检查锁定代码示例是错误的，错误的地方在与第7行(instance = new Instance();)，这个语句可以分解为如下3行伪代码：</p>
<p>memory = allocate();  // 1:分配对象的内存空间<br>ctorInstance(memory);  // 2:初始化对象<br>instance = memory;   // 3:设置instance指向刚分配的内存地址</p>
<p>这里就有一个重排序的问题了，上面3行伪代码中的2和3之间,可能会被重排序，如果2,3被重排序了，在多线程环境中，就会有问题了。另外一个线程B在访问instance的时候，操作3已经执行了所有instance != null，但是操作2还未执行，这个时候线程B就去访问这个未被初始化的对象，于是出现了脏读的问题。</p>
<p>上述问题的解决方案也很简单，在JDK5增强了volatile的内存语义之后，我们只需一点小小的修改就行了，声明instance为volatile即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> class <span class="title">DoubleCheckedLocking</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Instance instance;                    </div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span></span>&#123;                </div><div class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;                            </div><div class="line">            <span class="keyword">synchronized</span>(DoubleCheckedLocking.class)&#123;    </div><div class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)                     </div><div class="line">                    instance = <span class="keyword">new</span> Instance();           </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="类初始化解决多线程中的单例"><a href="#类初始化解决多线程中的单例" class="headerlink" title="类初始化解决多线程中的单例"></a>类初始化解决多线程中的单例</h1><p>JVM在类初始化阶段(即在Class被加载后，且被线程使用之前)，会执行类的初始化。初始化一个类，包含执行这个类的静态初始化和初始化在这个类中声明的静态字段。JVM在执行类的初始化期间，会去获取一个锁，这个锁可以同步多个线程对同一个类的初始化。Java语言规范规定，对于每一个类或接口C，都有一个唯一的初始化锁LC与之对应。JVM在类初始化期间会获取这个初始化锁，确保每一个线程至少获取一次锁来确保这个类已经被初始化过了(获取Class对象锁之后，若类或者接口没有初始化则开始初始化，若已经被标记为初始化过了，则开始访问)。</p>
<p><img src="../../../../img/bingfa/3-40.png" alt=""></p>
<p>基于这个特性，可以实现另一种线程安全的延迟初始化方案：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceFactory</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceHolder</span></span>&#123;</div><div class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Instance instance = <span class="keyword">new</span> Instance();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> InstanceHolder.instance;   <span class="comment">//导致InstanceHolder类被初始化</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/22/Java多线程学习笔记-四/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lujunqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qiu homepage">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/22/Java多线程学习笔记-四/" itemprop="url">Java多线程学习笔记(四)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-22T14:17:38+08:00">
                2017-08-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaSE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaSE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Lock的使用"><a href="#Lock的使用" class="headerlink" title="Lock的使用"></a>Lock的使用</h1><h2 id="使用ReentrantLock类"><a href="#使用ReentrantLock类" class="headerlink" title="使用ReentrantLock类"></a>使用ReentrantLock类</h2><p>在Java多线程中，可以使用synchronized关键字来实现线程之间同步互斥，但在JDK1.5中新增了ReentrantLock类也能达到同样的效果，并且在扩展功能上也更加强大，比如嗅探锁定，多路分支通知等功能，而且在使用上也比synchronized更加的灵活。</p>
<h3 id="使用ReentrantLock实现同步"><a href="#使用ReentrantLock实现同步" class="headerlink" title="使用ReentrantLock实现同步"></a>使用ReentrantLock实现同步</h3><p>ReentrantLock类的使用用例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            lock.lock();<span class="comment">//获取锁</span></div><div class="line">            System.out.println(<span class="string">"methodA begin ThreadName="</span> + Thread.currentThread().getName() + <span class="string">" time="</span> + System.currentTimeMillis());</div><div class="line">            Thread.sleep(<span class="number">5000</span>);</div><div class="line">            System.out.println(<span class="string">"methodA end ThreadName="</span> + Thread.currentThread().getName() + <span class="string">" time="</span> + System.currentTimeMillis());</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            lock.unlock();<span class="comment">//释放锁</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            lock.lock();</div><div class="line">            System.out.println(<span class="string">"methodB begin ThreadName="</span> + Thread.currentThread().getName() + <span class="string">" time="</span> + System.currentTimeMillis());</div><div class="line">            Thread.sleep(<span class="number">5000</span>);</div><div class="line">            System.out.println(<span class="string">"methodB end ThreadName="</span> + Thread.currentThread().getName() + <span class="string">" time="</span> + System.currentTimeMillis());</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        MyService service = <span class="keyword">new</span> MyService();</div><div class="line">        ThreadA a = <span class="keyword">new</span> ThreadA(service);</div><div class="line">        a.setName(<span class="string">"A"</span>);</div><div class="line">        a.start();</div><div class="line">        ThreadB b = <span class="keyword">new</span> ThreadB(service);</div><div class="line">        b.setName(<span class="string">"B"</span>);</div><div class="line">        b.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：<br>methodA begin ThreadName=A time=1503279665595<br>methodA end ThreadName=A time=1503279670595<br>methodB begin ThreadName=B time=1503279670596<br>methodB end ThreadName=B time=1503279675596</p>
<h3 id="使用Condition实现等待-通知"><a href="#使用Condition实现等待-通知" class="headerlink" title="使用Condition实现等待/通知"></a>使用Condition实现等待/通知</h3><p>在使用notify()/notifyAll()方法进行通知时，被通知的线程却是由JVM随机选择的。但使用ReentrantLock结合Condition类是可以实现选择性通知的，也就是在一个Lock对象里面可以创建多个Condition(即对象监视器)实例，线程对象可以注册在指定的Condition中，从而可以有选择性地进行线程通知，在调度线程上更加灵活。</p>
<p>而synchronized就相当于整个Lock对象中只有一个单一的Condition对象，所有的线程都注册在它的一个对象上。线程开始notifyAll()时，需要通知所有的WAITING对象，没有选择权，会出现相当大的效率问题。</p>
<p>使用多个Condition实现通知部分线程代码实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line">    <span class="keyword">public</span> Condition conditionA = lock.newCondition();</div><div class="line">    <span class="keyword">public</span> Condition conditionB = lock.newCondition();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">awaitA</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            lock.lock();</div><div class="line">            System.out.println(<span class="string">"begin awaitA 时间为"</span> + System.currentTimeMillis() + <span class="string">"ThreadName="</span> + Thread.currentThread().getName());</div><div class="line">            conditionA.await();</div><div class="line">            System.out.println(<span class="string">"end awaitA　时间为"</span> + System.currentTimeMillis() + <span class="string">"ThreadName="</span> + Thread.currentThread().getName());</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">awaitB</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            lock.lock();</div><div class="line">            System.out.println(<span class="string">"begin awaitB 时间为"</span> + System.currentTimeMillis() + <span class="string">"ThreadName="</span> + Thread.currentThread().getName());</div><div class="line">            conditionB.await();</div><div class="line">            System.out.println(<span class="string">"end awaitB　时间为"</span> + System.currentTimeMillis() + <span class="string">"ThreadName="</span> + Thread.currentThread().getName());</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signalAll_A</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            lock.lock();</div><div class="line">            System.out.println(<span class="string">"signalAll_A　时间为"</span> + System.currentTimeMillis() + <span class="string">"ThreadName="</span> + Thread.currentThread().getName());</div><div class="line">            conditionA.signalAll();</div><div class="line">        &#125;<span class="keyword">finally</span> &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signalAll_B</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            lock.lock();</div><div class="line">            System.out.println(<span class="string">"signalAll_B　时间为"</span> + System.currentTimeMillis() + <span class="string">"ThreadName="</span> + Thread.currentThread().getName());</div><div class="line">            conditionB.signalAll();</div><div class="line">        &#125;<span class="keyword">finally</span> &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        MyService service = <span class="keyword">new</span> MyService();</div><div class="line">        ThreadA a = <span class="keyword">new</span> ThreadA(service);</div><div class="line">        a.setName(<span class="string">"A"</span>);</div><div class="line">        a.start();</div><div class="line">        ThreadB b = <span class="keyword">new</span> ThreadB(service);</div><div class="line">        b.setName(<span class="string">"B"</span>);</div><div class="line">        b.start();</div><div class="line">        Thread.sleep(<span class="number">3000</span>);</div><div class="line">        service.signalAll_A();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> MyService service;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadA</span><span class="params">(MyService service)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.service = service;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        service.awaitA();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadB</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> MyService service;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadB</span><span class="params">(MyService service)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.service = service;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        service.awaitB();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：<br>begin awaitA 时间为1503282953886ThreadName=A<br>begin awaitB 时间为1503282953889ThreadName=B<br>signalAll_A　时间为1503282956889ThreadName=main<br>end awaitA　时间为1503282956890ThreadName=A</p>
<p>我们成功实现等待/通知模式:<br>Object类中的wait()方法相当于Condition类中的await()方法。<br>Object类中的notify()方法相当于Condition类中的signal()方法。<br>Object类中的notifyAll()方法相当于Condition类中的signalAll()方法。</p>
<h3 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h3><p>公平与非公平锁：锁Lock分为”公平锁”和”非公平锁”，公平锁表示线程获取锁的顺序是按照线程加锁的顺序来分配的，即先来先得的FIFO先进先出顺序。而非公平锁就是一种获取锁的抢占机制，是随机获得锁的，和公平锁不一样的就是先来的不一定先得到锁，这个方式可能造成某些线程一直拿不到锁，结果就是不公平的了。默认情况下，ReentrantLock类使用的是非公平锁。</p>
<p>代码实例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Lock lock;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">(<span class="keyword">boolean</span> isFair)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.lock = <span class="keyword">new</span> ReentrantLock(isFair);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            lock.lock();</div><div class="line">            System.out.println(<span class="string">"Thread Name="</span> + Thread.currentThread().getName() + <span class="string">"获得锁定"</span>);</div><div class="line">        &#125;<span class="keyword">finally</span> &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        MyService service = <span class="keyword">new</span> MyService(<span class="keyword">true</span>);<span class="comment">//公平锁</span></div><div class="line"><span class="comment">//        MyService service = new MyService(false);//非公平锁</span></div><div class="line">        Thread[] threads = <span class="keyword">new</span> Thread[<span class="number">10</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">            threads[i] = <span class="keyword">new</span> ThreadA(service);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">            threads[i].start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> MyService service;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadA</span><span class="params">(MyService service)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.service = service;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"*线程"</span> + Thread.currentThread().getName() + <span class="string">"运行了"</span>);</div><div class="line">        service.service();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="其他方法接口"><a href="#其他方法接口" class="headerlink" title="其他方法接口"></a>其他方法接口</h3><p>关于ReentrantLock类的使用，有很多辅助方法接口，我们在实际编程使用的时候以Java官方的API为主，这里列举一些简单的方法。</p>
<ol>
<li>方法　int getHoldCount() 的作用是查询当前线程保持此锁定的个数，也就是调用lock()方法的次数。</li>
<li>方法　int getQueueLength()的作用是返回正等待获取此锁定的线程估计数。</li>
<li>方法　int getWaitQueueLength(Condition condition)的作用是返回等待与此锁定相关的给定条件Condition的线程估计数。</li>
<li>方法　boolean hasQueuedThread(Thread thread)的作用是查询指定的线程是否正在等待获取此锁定。</li>
<li>方法　boolean hasWaiters(Condition condition)的作用是查询是否有线程正在等待与此锁定有关的condition条件。</li>
<li>方法　boolean isFair()的作用是判断是不是公平锁。</li>
<li>方法　boolean isHeldByCurrentThread()的作用是查询当前线程是否保持此锁定。</li>
<li>方法　boolean isLocked(0的作用是查询此锁定是否由任意线程保持。</li>
</ol>
<h2 id="使用ReentrantReadWriteLock类"><a href="#使用ReentrantReadWriteLock类" class="headerlink" title="使用ReentrantReadWriteLock类"></a>使用ReentrantReadWriteLock类</h2><p>类ReentrantLock具有完全互斥排他的效果，即同一时间只有一个线程在执行ReentrantLock.lock()方法后面的任务。这样做虽然保证了实例变量的线程安全性，但效率却是非常低下的。所以在JDK中提供了一种读写锁ReentrantReadWriteLock类，使用它可以加快运行效率。</p>
<p>读写锁表示也有两个锁，一个是读操作相关的锁，也称为共享锁；另一个是写操作相关的锁，也叫排他锁。也就是多个读锁之间不互斥，读锁与写锁互斥，写锁与写锁互斥。在没有线程Thread进行写入操作时，进行读取操作的多个Thread都可以获取读锁，而进行写入操作的线程Thread只有在获取写锁后才能进行写入操作。即多个Thread可以同时进行读取操作，但是同一时刻只允许一个Thread进行写入操作。</p>
<p>代码实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            lock.readLock().lock();</div><div class="line">            System.out.println(<span class="string">"获得读锁="</span> + System.currentTimeMillis() );</div><div class="line">        &#125;<span class="keyword">finally</span> &#123;</div><div class="line">            lock.readLock().unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            lock.writeLock().lock();</div><div class="line">            System.out.println(<span class="string">"获得写锁="</span> + System.currentTimeMillis());</div><div class="line">        &#125;<span class="keyword">finally</span> &#123;</div><div class="line">            lock.writeLock().unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        MyService service = <span class="keyword">new</span> MyService();</div><div class="line">        ThreadA threadA = <span class="keyword">new</span> ThreadA(service);</div><div class="line">        ThreadA threadB = <span class="keyword">new</span> ThreadA(service);</div><div class="line">        </div><div class="line">        threadA.start();</div><div class="line">        threadB.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> MyService service;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadA</span><span class="params">(MyService service)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.service = service;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        service.read();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadB</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> MyService service;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadB</span><span class="params">(MyService service)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.service = service;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        service.write();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/30/Java多线程学习笔记-三/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lujunqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qiu homepage">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/30/Java多线程学习笔记-三/" itemprop="url">Java多线程学习笔记(三)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-30T22:09:52+08:00">
                2017-07-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaSE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaSE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h1><p>线程是操作系统中独立的个体，但这些个体如果不经过特殊处理就不能成为一个整体。在线程间进行通信后，系统之间的交互性会更加强大，在大大提高CPU利用率的同时还会使程序员对各线程任务在处理的过程中进行有效的把控与监督。</p>
<h2 id="等待／通知机制"><a href="#等待／通知机制" class="headerlink" title="等待／通知机制"></a>等待／通知机制</h2><p>wait():使当前执行代码的线程进行等待,该方法是Object类的方法，可以将当前线程置入”预执行队列”中，并且在wait()所在的代码行停止执行，直到接到通知或被中断为止。在调用wait()之前，线程必须获得该对象的对象级别锁，也就是说只能在同步方法或同步块中调用wait()方法。在执行wait()方法后，当前线程释放对象锁。如果调用wait()时没有持有适当的锁，则抛出IllagalMonitorStateException，这是RuntimeException的一个子类，不需要try-catch语句进行捕捉。</p>
<p>notify()/notifyAll():在调用notify()之前，线程也必须获得该对象的对象级别锁，也就是说要在同步方法或同步块中调用。同样，如果调用notify()时没有持有适当的锁，也会抛出IllagalMonitorStateException。notify()方法用来通知那些可能等待该对象的对象锁的其他线程，如果有多个线程等待，则由线程规划器随机挑选出一个呈wait状态的线程，对其发出notify，并使得它等待获取该对象的对象锁。但是需要说明的是，在执行notify()方法后，当前线程不会马上释放该对象锁，要等到执行notify()方法的线程将程序执行完，也就是退出synchronized代码后，当前线程才会释放锁。总而言之，notify()方法随机唤醒等待队列中的等待同一共享资源(同一对象锁)的线程，进入可运行状态。如果发出notify操作时没有处于阻塞状态中的线程，那么该命令可以忽略。</p>
<p>关键字synchronized可以将任何一个Object对象作为同步对象来看待，而Java为每个Object都实现了wait()和notify()方法，它们必须用在被synchronized同步的Object的临界区内。通过调用wait()方法可以使处于临界区内的线程进入等待状态，同时释放被同步对象的锁。而notify操作可以唤醒一个因调用了wait操作而处于等待状态的线程，使其进入就绪状态，重新试图获得对象锁，等待CPU的调用，执行wait()方法之后的代码。</p>
<p>我们需要注意的是，sleep()方法是不释放对象锁的。同时，每个锁对象都有两个队列，一个是就绪队列，一个是阻塞队列。就绪队列存储了将要获得锁的线程，阻塞队列存储了被阻塞的线程。一个线程被唤醒后，才会进入就绪队列，等待CPU的调度；反之，一个线程被wait后，就会进入阻塞队列，等待下一次被唤醒。</p>
<p>总结一下，对象锁何时会被释放：</p>
<ul>
<li>执行完同步代码块</li>
<li>在执行同步代码块的过程中，遇到异常而导致线程终止</li>
<li>在执行同步代码块的过程中，执行了锁所属对象的wait()方法，这个线程会释放锁，进行对象的等待池</li>
</ul>
<p>这里介绍一个结束线程的方法:对某一线程调用interrupt()时，如果该线程正在执行普通的代码，那么该线程根本就不会抛出InterruptedException。但是，一旦该线程进入到wait()/sleep()/join()后，就会立刻抛出InterruptedException。那么，如果线程A希望立即结束线程B，则可以对线程B对应的Thread实例调用interrupt方法。如果此刻线程B正在wait/sleep /join，则线程B会立刻抛出InterruptedException，在catch() {} 中直接return即可安全地结束线程。</p>
<p>多线程实例代码：通过管道进行线程之间数据通信</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PipeInputOutputTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            WriteData writeData = <span class="keyword">new</span> WriteData();</div><div class="line">            ReadData readData = <span class="keyword">new</span> ReadData();</div><div class="line"></div><div class="line">            PipedInputStream inputStream = <span class="keyword">new</span> PipedInputStream();</div><div class="line">            PipedOutputStream outputStream = <span class="keyword">new</span> PipedOutputStream();</div><div class="line">            </div><div class="line">            <span class="comment">//将输入管道和输出管道连接起来</span></div><div class="line">            outputStream.connect(inputStream);</div><div class="line">            </div><div class="line">            <span class="comment">//注意：首先读取线程启动，由于当时没有数据写入，会有I/O阻塞，直到数据被写入，才继续运行下去</span></div><div class="line">            ThreadRead threadRead = <span class="keyword">new</span> ThreadRead(readData, inputStream);</div><div class="line">            threadRead.start();</div><div class="line">            Thread.sleep(<span class="number">1000</span>);</div><div class="line">            ThreadWrite threadWrite = <span class="keyword">new</span> ThreadWrite(writeData, outputStream);</div><div class="line">            threadWrite.start();</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WriteData</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeMethod</span><span class="params">(PipedOutputStream outputStream)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            System.out.println(<span class="string">"write:"</span>);</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">                String outData = <span class="string">""</span> + i;</div><div class="line">                outputStream.write(outData.getBytes());</div><div class="line">                System.out.print(outData);</div><div class="line">            &#125;</div><div class="line">            System.out.println();</div><div class="line">            outputStream.close();</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadData</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readMethod</span><span class="params">(PipedInputStream inputStream)</span></span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            System.out.println(<span class="string">"read:"</span>);</div><div class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>];</div><div class="line">            <span class="keyword">int</span> readLength = inputStream.read(bytes);</div><div class="line">            <span class="keyword">while</span> (readLength != -<span class="number">1</span>) &#123;</div><div class="line">                String readData = <span class="keyword">new</span> String(bytes, <span class="number">0</span>, readLength);</div><div class="line">                System.out.print(<span class="string">" read : "</span>+readData);</div><div class="line">                readLength = inputStream.read(bytes);</div><div class="line">            &#125;</div><div class="line">            System.out.println();</div><div class="line">            inputStream.close();</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadWrite</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> WriteData writeData;</div><div class="line">    <span class="keyword">private</span> PipedOutputStream outputStream;</div><div class="line"></div><div class="line">    ThreadWrite(WriteData writeData, PipedOutputStream outputStream) &#123;</div><div class="line">        <span class="keyword">this</span>.writeData = writeData;</div><div class="line">        <span class="keyword">this</span>.outputStream = outputStream;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.run();</div><div class="line">        writeData.writeMethod(outputStream);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadRead</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> ReadData readData;</div><div class="line">    <span class="keyword">private</span> PipedInputStream inputStream;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadRead</span><span class="params">(ReadData readData, PipedInputStream inputStream)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.readData = readData;</div><div class="line">        <span class="keyword">this</span>.inputStream = inputStream;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.run();</div><div class="line">        readData.readMethod(inputStream);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="方法join的使用"><a href="#方法join的使用" class="headerlink" title="方法join的使用"></a>方法join的使用</h2><p>在很多情况下，主线程启动子线程，如果子线程中要进行大量的耗时运算，主线程往往将早于子线程之前结束。这时，如果主线程想等待子线程执行完成之后再结束，比如子线程处理一个数据，主线程要取得这个数据中的值，就要用到join()方法了。join()方法的作用是等待对象销毁。可以将两个交替执行的线程合并为顺序执行的线程。比如在线程B中调用了线程A的join()方法，直到线程A执行完毕后，才会继续执行线程B。join()方法内部实现是通过调用wait()方法实现的，比如当main线程调用t.join时候，main线程会获得线程对象t的锁（wait意味着拿到该对象的锁),调用该对象的wait(等待时间)。这就意味着main线程调用t.join时，必须能够拿到线程t对象的锁。同时，在调用join()方法的时候也会释放对象锁。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            MyThread thread = <span class="keyword">new</span> MyThread();</div><div class="line">            thread.start();</div><div class="line">            thread.join();</div><div class="line">            System.out.println(<span class="string">"在thread对象执行完之后再执行"</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.run();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">int</span> secondValue = (<span class="keyword">int</span>) (Math.random() * <span class="number">1000</span>);</div><div class="line">            System.out.println(secondValue);</div><div class="line">            Thread.sleep(secondValue);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="类ThreadLocal的使用"><a href="#类ThreadLocal的使用" class="headerlink" title="类ThreadLocal的使用"></a>类ThreadLocal的使用</h2><p>类ThreadLocal主要解决的就是每个线程绑定自己的值，可以将ThreadLocal类比喻成全局存放数据的盒子，盒子中可以存储每个线程的私有数据。</p>
<p>类Threadlocal解决的是变量在不同线程间的隔离性，也就是不同线程拥有自己的值，不同线程中的值是可以放入Threadlocal类中进行保存的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/29/内部类学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lujunqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qiu homepage">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/29/内部类学习笔记/" itemprop="url"> 内部类学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-29T10:40:17+08:00">
                2017-07-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaSE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaSE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="内部类讲解"><a href="#内部类讲解" class="headerlink" title="内部类讲解"></a>内部类讲解</h1><p>内部类有两种情况：</p>
<ul>
<li>在类中定义一个类（私有内部类，静态内部类）</li>
<li>在方法中定义一个类（局部内部类，匿名内部类）</li>
</ul>
<h2 id="私有内部类"><a href="#私有内部类" class="headerlink" title="私有内部类"></a>私有内部类</h2><p>1.在外部类的作用范围内可以任意创建内部类对象，即使内部类是私有的(私有内部类)。即内部类对包围它的外部类可见。</p>
<p>2.在内部类中可以访问其外部类的所有域，即使是私有域。即外部类对内部类可见。</p>
<p>问题来了：上面两个特点到底如何办到的呢？内部类的”内部”到底发生了什么？</p>
<p>其实，内部类是Java编译器一手操办的。虚拟机并不知道内部类与常规类有什么不同。对内部类进行编译后发现有两个class文件：Outer.class和Outer@Inner.class.这说明内部类Inner仍然被编译成一个独立的类(Outer@Inner.class),而不是Outer类的某一个域。虚拟机运行的时候，也是把Inner作为一个常规类来处理的。</p>
<p>那么，为什么外部类可以创建内部类的对象？</p>
<p>首先编译器将外、内部类编译后放在同一个包中。在内部类中附加一个包可见构造器。这样，虚拟机运行Outer类中Inner in=new Inner(); 实际上调用的是包可见构造： new   Outer@Inner(this,null)。因此即使是private内部类，也会通过隐含的包可见构造器成功的获得私有内部类的构造权限。再者，Outer@Inner类中有一个指向外部类Outer的引用this@0，那么通过这个引用就可以方便的得到外部类对象中可见成员。</p>
<p>但是Outer类中的private成员是如何访问到的呢？这就要看看下面Outer.class文件中的秘密了。那么，为什么内部类可以引用外部类的私有域？</p>
<p>原因的关键就在编译器在外围类中添加了静态方法access@0。它将返回值作为参数传递给他的对象域data。</p>
<p>这样内部类Inner中的打印语句： System.out.println(data);</p>
<p> 实际上运行的时候调用的是：System.out.println(this@0.access@0(Outer));</p>
<p> 总结一下编译器对类中内部类做的手脚：</p>
<ul>
<li>在内部类中偷偷摸摸的创建了包可见构造器，从而使外部类获得了创建权限。</li>
<li>在外部类中偷偷摸摸的创建了访问私有变量的静态方法，从而 使 内部类获得了访问权限。</li>
</ul>
<p>这样，类中定义的内部类无论私有，公有，静态都可以被包围它的外部类所访问。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name ;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line"></div><div class="line">    <span class="comment">/**省略getter和setter方法**/</span></div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InnerClass</span><span class="params">()</span></span>&#123;</div><div class="line">            name = <span class="string">"chenssy"</span>;</div><div class="line">            age = <span class="number">23</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</div><div class="line">            System.out.println(<span class="string">"name："</span> + getName() +<span class="string">"   ;age："</span> + getAge());</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">public</span> OuterClass <span class="title">getOuterClass</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">return</span> OuterClass.<span class="keyword">this</span>;</div><div class="line">        &#125;</div><div class="line">    </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        OuterClass outerClass = <span class="keyword">new</span> OuterClass();</div><div class="line">        OuterClass.InnerClass innerClass = outerClass.new InnerClass();</div><div class="line">        innerClass.display();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>静态内部类和私有内部类最大的区别在于，静态内部类中无法引用到其外围类的非静态成员.也就是说静态内部类只能访问其外围类的静态成员，除此之外与非静态内部类没有任何区别。</p>
<h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>局部内部类是在方法中定义的内部类，有两个特点：</p>
<ul>
<li>方法中的内部类没有修饰符号，就是说方法中的内部类对包围它的方法之外的任何东西都不可见。</li>
<li>方法内部类只能够访问该方法中的局部变量，所以也叫局部内部类。而且这些局部变量一定要是final修饰的常量。</li>
</ul>
<p>代码示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outter</span></span>&#123;   </div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outMethod</span><span class="params">()</span></span>&#123;   </div><div class="line">             <span class="keyword">final</span> <span class="keyword">int</span> beep=<span class="number">0</span>;   </div><div class="line">             <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;   </div><div class="line">                   <span class="comment">//使用beep   </span></div><div class="line">             &#125;   </div><div class="line">             Inner in=<span class="keyword">new</span> Inner();   </div><div class="line">      &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 我们可以这样解释Inner类中的这个备份常量域，首先当JVM运行到需要创建Inner对象之后，Outter类已经全部运行完毕，这是垃圾回收机制很有可能释放掉局部变量beep。那么Inner类到哪去找beep变量呢？</p>
<p>编译器又出来帮我们解决了这个问题，他在Inner类中创建了一个beep的备份 ，也就是说即使Ouuter中的beep被回收了，Inner中还有一个备份存在，自然就不怕找不到了。</p>
<p>但是问题又来了。如果Outter中的beep不停的在变化那。那岂不是也要让备份的beep变量无时无刻的变化。为了保持局部变量与局部内部类中备份域保持一致。 编译器不得不规定死这些局部域必须是常量，一旦赋值不能再发生变化了。</p>
<p>所以为什么局部内部类应用外部方法的域必须是常量域的原因所在了。</p>
<h2 id="总结内部类的特点"><a href="#总结内部类的特点" class="headerlink" title="总结内部类的特点"></a>总结内部类的特点</h2><p>(1)  在方法间定义的非静态内部类： </p>
<pre><code>● 外围类和内部类可互相访问自己的私有成员。

● 内部类中不能定义静态成员变量。
</code></pre><p>(2) 在方法间定义的静态内部类：</p>
<pre><code>● 只能访问外部类的静态成员。
</code></pre><p>(3) 在方法中定义的局部内部类：</p>
<pre><code>● 该内部类没有任何的访问控制权限

● 外围类看不见方法中的局部内部类的，但是局部内部类可以访问外围类的任何成员。

● 方法体中可以访问局部内部类，但是访问语句必须在定义局部内部类之后。

● 局部内部类只能访问方法体中的常量，即用final修饰的成员。
</code></pre><p>(4) 在方法中定义的匿名内部类：</p>
<pre><code>● 没有构造器，取而代之的是将构造器参数传递给超类构造器。
</code></pre><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="匿名内部类的作用"><a href="#匿名内部类的作用" class="headerlink" title="匿名内部类的作用"></a>匿名内部类的作用</h3><p>除了匿名只使用一次之外,当你想使用一个类的protected方法时，但是又不和这个类在同一个包下，你是没办法调用的。这时候匿名类就派上用场了，你可以声明一个匿名类继承该类，并定义一个方法，在这个方法内使用super调用你想调用的那个方法（其实你也可以写个类继承这个类，就能调用父类的protected方法了，但是匿名类更简洁，因为你只想调用这个方法而已）</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span></span>&#123;</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> test&#123;</div><div class="line">        System.out.println(<span class="string">"test"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个类有一个protected方法test，如果你在其他包下想调用这个protected方法是不行的，可以发现没有提示test方法.这时候你可以使用匿名类继承这个类，定义一个方法callParentTest()，在这个方法体内调用super.test()，最后调用这个callParentTest()即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">new</span> TestClass()&#123;</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">callParentTest</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">super</span>.test();</div><div class="line">        &#125;</div><div class="line">    &#125;.callParentTest();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/21/Java多线程学习笔记（二）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lujunqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qiu homepage">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/21/Java多线程学习笔记（二）/" itemprop="url">Java多线程学习笔记（二）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-21T22:39:39+08:00">
                2017-07-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaSE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaSE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="对象及变量的并发访问"><a href="#对象及变量的并发访问" class="headerlink" title="对象及变量的并发访问"></a>对象及变量的并发访问</h1><p>“非线程安全”其实会在多个线程对同一个对象中的实例变量进行并发访问时发生，产生的后果就是”脏读”，也就是取到的数据其实是被更改过的。而”线程安全”获得的实例变量的值是经过同步处理的，不会出现”脏读”的现象。</p>
<h2 id="synchronized同步方法"><a href="#synchronized同步方法" class="headerlink" title="synchronized同步方法"></a>synchronized同步方法</h2><h3 id="方法内的私有变量"><a href="#方法内的私有变量" class="headerlink" title="方法内的私有变量"></a>方法内的私有变量</h3><p>“非线程安全”问题存在于”实例变量”，如果是方法内部的私有变量，则不存在”非线程安全”问题，永远都是线程安全的，这是方法内部的变量是私有(作用域)的特性造成的。</p>
<h3 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h3><p>如果多个线程共同访问1个对象中的实例变量，则有可能出现”非线程安全”问题。我们需要在有可能产生”非线程安全”的方法前面加上synchronized关键字，将此方法变成同步方法。</p>
<p>关键字synchronized取得的锁都是对象锁，而不是把一段代码或者方法(函数)当作锁，哪个线程先执行带synchronized关键字的方法，哪个线程就持有该方法所属对象的锁Lock，那么其他线程只能呈现等待状态，前提是多个线程访问的是同一个对象。如果多个线程访问多个对象，则JVM会创建多个锁。</p>
<p>假设两个线程访问同一个对象的两个同步synchronized方法：</p>
<ol>
<li>A线程调用object对象加入synchronized关键字的X方法时，A线程就获得了X方法锁，准确的讲，是获得了对象的锁，所以其他线程必须等A线程执行完毕才可以调用X方法，但B线程可以随意调用其他的非synchronized同步方法。</li>
<li>A线程调用object对象加入synchronized关键字的X方法时，A线程就获得了X方法所在对象的锁，所以其他线程必须等A线程执行完毕才可以调用X方法，而B线程如果调用声明了synchronized关键字的非X方法时，必须等A线程将X方法执行完，也就是释放了对象锁后才可以调用。</li>
</ol>
<p>“可重入锁”:当有一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当这个线程再次想要获得这个对象的锁的时候还是可以获取的。特别的说明，当存在父子类继承关系时，子类是完全可以通过”可重入锁”调用父类的同步方法的。</p>
<p>但是，当一个线程执行的代码出现异常退出时，其所持有的锁会自动释放。</p>
<h2 id="synchronized-this-同步语句块"><a href="#synchronized-this-同步语句块" class="headerlink" title="synchronized(this)同步语句块"></a>synchronized(this)同步语句块</h2><p>用synchronized声明方法在时间效率上是有弊端的，比如A线程调用了同步方法执行一个长时间的任务，那么B线程则必须等待比较长的时间。</p>
<p>当两个并发线程访问同一个对象object中的synchronized(this)同步代码块时，一段时间内只能有一个线程被执行，另一个线程必须等待当前线程执行完这个代码块以后才能执行。并且当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object对象中的非synchronized(this)同步代码块。也就是说，不在synchronized(this)同步代码块就是异步执行，在synchronized块中就是同步执行。</p>
<p>当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对同一个object中所有其他synchronized(this)同步代码块的访问将被阻塞，这就说明synchronized使用的“对象监视器”是同一个。也就是说，和synchronized方法一样，synchronized(this)同步代码块也是锁定当前对象的。</p>
<h2 id="对象监视器"><a href="#对象监视器" class="headerlink" title="对象监视器"></a>对象监视器</h2><p>在前面的学习中，使用synchronized(this)格式来同步代码块，其实我们还可以用”任意对象”作为”对象监视器”来实现同步的功能，使用的格式为synchronized(非this对象x)。那么，在多个线程持有”对象监视器”为同一个对象时，同一时间只有一个线程可以执行synchronized(非this对象x)同步代码块中的代码。如果不是同一个对象监视器，则会异步运行。更多示例参考《Java多线程编程核心技术》2.2.8节。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyOneList</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> List list = <span class="keyword">new</span> ArrayList();</div><div class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String data)</span></span>&#123;</div><div class="line">        list.add(data);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> list.size();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> MyOneList list;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread1</span><span class="params">(MyOneList list)</span></span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="keyword">this</span>.list = list;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            <span class="keyword">if</span>(list.getSize() &lt; <span class="number">1</span>)&#123;</div><div class="line">                Thread.sleep(<span class="number">2000</span>);</div><div class="line">                list.add(<span class="string">"A"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e )&#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> MyOneList list;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread2</span><span class="params">(MyOneList list)</span></span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="keyword">this</span>.list = list;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            <span class="keyword">if</span>(list.getSize() &lt; <span class="number">1</span>)&#123;</div><div class="line">                Thread.sleep(<span class="number">2000</span>);</div><div class="line">                list.add(<span class="string">"B"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e )&#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        MyOneList list = <span class="keyword">new</span> MyOneList();</div><div class="line">        MyThread1 thread1 = <span class="keyword">new</span> MyThread1(list);</div><div class="line">        thread1.setName(<span class="string">"A"</span>);</div><div class="line">        thread1.start();</div><div class="line">        MyThread2 thread2 = <span class="keyword">new</span> MyThread1(list);</div><div class="line">        thread1.setName(<span class="string">"B"</span>);</div><div class="line">        thread1.start();</div><div class="line">        Thread.sleep(<span class="number">6000</span>);</div><div class="line">        System.out.println(<span class="string">"listSize = "</span> + list.getSize());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码就有可能出现”脏读”，导致输出结果为”listSize=2”，原因是２个线程以异步的方式返回list参数的size()大小，导致同时进入if判断语句中。</p>
<p>这个例子中如何解决”脏读”呢？由于list参数对象在项目中是一份实例，是单例的，而且也正需要对list参数的getSize()方法做同步调用，所以就对list参数进行同步处理。</p>
<p>更改代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> MyOneList list;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread1</span><span class="params">(MyOneList list)</span></span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="keyword">this</span>.list = list;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            <span class="keyword">synchronized</span>(list)&#123;</div><div class="line">                <span class="keyword">if</span>(list.getSize() &lt; <span class="number">1</span>)&#123;</div><div class="line">                    Thread.sleep(<span class="number">2000</span>);</div><div class="line">                    list.add(<span class="string">"A"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e )&#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="静态同步synchronized方法与synchronized-class-代码块"><a href="#静态同步synchronized方法与synchronized-class-代码块" class="headerlink" title="静态同步synchronized方法与synchronized(class)代码块"></a>静态同步synchronized方法与synchronized(class)代码块</h2><p>关键字synchronized还可以应用在static静态方法上，如果这样写，那是对当前的.java文件对应的Class类进行持锁。synchronized关键字加到static静态方法上是给Class类上锁，可以对类的所有对象实例起作用，而synchronized关键字加到非static静态方法上是给对象上锁，这2个锁不是同一个锁。synchronized(class)代码块的作用其实和synchronized static方法的作用一样。我们需要注意的是，synchronized(ClassName)与synchronized(ClassName的实例)，线程各自获取各自的锁，不会有等待。</p>
<p>注意:我们在将任何数据类型作为同步锁时，需要观察，是否有多个线程同时持有锁对象，如果同时持有相同的锁对象，则这些线程之间就是同步的；如果分别获得锁对象，就是异步的。</p>
<h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><p>并发专家建议我们远离它，尤其是在JDK6的synchronized关键字的性能被大幅优化之后，更是几乎没有使用它的场景，但这仍然是个值得研究的关键字，研究它的意义不在于去使用它，而在于理解它对理解Java的整个多线程的机制是很有帮助的。</p>
<p>关键字volatile的主要作用是使变量在多个线程间可见。简单地说就是当线程A对变量X进行了修改后，在线程A后面执行的其他线程能看到变量X的变动。同时关键字synchronized也可以同样的完成volatile关键字可见性的功能。</p>
<p>更详细地说是要符合以下两个规则：</p>
<ul>
<li>线程对变量进行修改之后，要立刻回写到主内存。</li>
<li>线程对变量读取的时候，要从主内存中读，而不是缓存。</li>
</ul>
<p>这里我们需要提到Java内存模型。在Java内存模型中，内存分为主内存和工作内存两个部分，其中主内存是所有线程所共享的，而工作内存则是每个线程分配一份，各线程的工作内存间彼此独立、互不可见，在线程启动的时候，虚拟机为每个内存分配一块工作内存，不仅包含了线程内部定义的局部变量，也包含了线程所需要使用的共享变量(非线程内构造的对象)的副本，即为了提高执行效率，读取副本比直接读取主内存更快(这里可以简单地将主内存理解为虚拟机中的堆，而工作内存理解为栈(或称为虚拟机栈)，栈是连续的小空间、顺序入栈出栈，而堆是不连续的大空间，所以在栈中寻址的速度比堆要快很多)。</p>
<p>对于共享普通变量来说，约定了变量在工作内存中发生变化了之后，必须要回写到工作内存(迟早要回写但并非马上回写)，但对于volatile变量则要求工作内存中发生变化之后，必须马上回写到工作内存，而线程读取volatile变量的时候，必须马上到工作内存中去取最新值而不是读取本地工作内存的副本，此规则保证了前面所说的“当线程A对变量X进行了修改后，在线程A后面执行的其他线程能看到变量X的变动”。</p>
<p>volatile虽然保证了线程之间共享变量的及时可见性，但是并没有保证同步。也就是说，volatile不能保证原子性。而synchronized关键字解决的是多个线程之间访问资源的同步性。</p>
<p>这里说明一下，如果真的需要使用volatile关键字，那么，在禁止指令重排序是一个很好的场景。具体volatile关键字的用法，参考这篇博客：<a href="https://www.ibm.com/developerworks/cn/java/j-jtp06197.html" target="_blank" rel="external">正确使用 Volatile 变量</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/30/模版方法模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lujunqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qiu homepage">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/30/模版方法模式/" itemprop="url">模版方法模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-30T10:01:34+08:00">
                2017-06-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h1><p><em>定义：规定一个操作中的算法的骨架，而将步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义算法的某些特定步骤。</em></p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>通过模板方法我们可以控制子类扩展，因为子类必须遵守算法规则(从父类继承而来)。在多个子类拥有相同的方法，并且这些方法逻辑相同时，可以考虑使用模版方法模式。在程序的主框架相同，细节不同的场合下，也比较适合使用这种模式。</p>
<h2 id="策略模式的结构："><a href="#策略模式的结构：" class="headerlink" title="策略模式的结构："></a>策略模式的结构：</h2><p><img src="../../../../img/moshi/moban.png" alt=""></p>
<p>图中的角色：</p>
<p>抽象类（AbstractClass）：在抽象类中定义了一系列基本操作，这些基本操作可以是具体的，也可以是抽象的，每一个基本操作对应算法的一个步骤，在其子类中可以重定义或实现这些步骤。同时，在抽象类中实现了一个模板方法，用于定义一个算法的框架，模板方法不仅可以调用在抽象类中实现的基本方法，也可以调用在抽象类的子类中实现的基本方法，还可以调用其他对象中的方法。</p>
<p>具体类（ConcreteClass)：它是抽象类的子类，用于实现在父类中声明的抽象基本操作以完成子类特定算法的步骤，也可以覆盖在父类中已经实现的具体基本操作</p>
<h2 id="进一步了解策略模式"><a href="#进一步了解策略模式" class="headerlink" title="进一步了解策略模式"></a>进一步了解策略模式</h2><p>关于钩子方法：</p>
<p>由抽象类声明并加以实现，但是子类可以去扩展，子类可以通过扩展钩子方法来影响模版方法的逻辑。最简单的钩子方法就是空方法，另一种钩子方法可以实现对其他方法进行约束，这种钩子方法通常返回一个bool类型，即返回true或false，用来判断是否执行某一个基本方法。同时我们也可以在钩子方法中定义一个默认的实现，如果子类不覆盖钩子方法，则执行父类的默认实现代码。</p>
<p>优点：</p>
<ul>
<li>模板方法模式通过把不变的行为搬移到超类，去除了子类中的重复代码</li>
<li>子类实现算法的某些细节，有助于算法的扩展。</li>
<li>通过一个父类调用子类实现的操作，通过子类扩展增加新的行为，符合“开放-封闭原则”</li>
</ul>
<h2 id="代码实例："><a href="#代码实例：" class="headerlink" title="代码实例："></a>代码实例：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doAnything</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isDoSomething</span><span class="params">()</span></span>&#123; <span class="comment">//父类方法返回真</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">templateMethod</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * 调用基本方法，完成相关的逻辑</div><div class="line">         */</div><div class="line">        <span class="keyword">this</span>.doAnything();</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.isDoSomething())</div><div class="line">            <span class="keyword">this</span>.doSomething();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteClass1</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isDoSth;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doAnything</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        <span class="comment">//子类实现具体</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub    </span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setDo</span><span class="params">(<span class="keyword">boolean</span> isDo)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.isDoSth = isDo;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isDoSomething</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> isDoSth;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/28/策略模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lujunqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qiu homepage">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/28/策略模式/" itemprop="url">策略模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-28T14:09:53+08:00">
                2017-06-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p><em>定义：针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以互相替换。</em></p>
<p>策略模式属于对象行为模式，可以使得算法在不影响到客户端(算法的调用者)的情况下发生变化。策略模式通常把一个系列的算法包装到一系列的策略类里面，作为一个抽象策略类的子类，可以将策略模式理解为相同行为的不同实现而已。</p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>在软件开发中也常常遇到类似的情况，实现某一个功能有多种算法或者策略，我们可以根据环境或者条件的不同选择不同的算法或者策略来完成该功能。如查找、排序等，一种常用的方法是硬编码(Hard Coding)。在一个类中，如需要提供多种查找算法，可以将这些算法写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的查找算法；当然也可以将这些查找算法封装在一个统一的方法中，通过if…else…或者case等条件判断语句来进行选择。这两种实现方法我们都可以称之为硬编码，如果需要增加一种新的查找算法，需要修改封装算法类的源代码；更换查找算法，也需要修改客户端调用代码。在这个算法类中封装了大量查找算法，该类代码将较复杂，维护较为困难。如果我们将这些策略包含在客户端，这种做法更不可取，将导致客户端程序庞大而且难以维护，如果存在大量可供选择的算法时问题将变得更加严重。这时候我们就需要使用到策略模式来设计我们的代码了。</p>
<h2 id="策略模式的结构："><a href="#策略模式的结构：" class="headerlink" title="策略模式的结构："></a>策略模式的结构：</h2><p><img src="../../../../img/moshi/celue.png" alt=""></p>
<p>以上结构涉及到三个角色：</p>
<ul>
<li>环境(Context):持有一个Strategy的引用,对策略进行二次封装，目的是避免高层模块对策略的直接调用</li>
<li>抽象策略类(Strategy):通常由一个接口或者抽象类实现，给出所有的具体策略类所需的接口,当各个实现类中存在着重复的逻辑时，则使用抽象类来封装这部分公共的代码</li>
<li>具体策略类(ConcreteStrategy):包装了相关算法的实现</li>
</ul>
<h2 id="进一步了解策略模式"><a href="#进一步了解策略模式" class="headerlink" title="进一步了解策略模式"></a>进一步了解策略模式</h2><p>策略模式仅仅封装算法，在什么情况下使用什么算法是由调用者决定的，而且策略模式的重心不是如何实现算法，而是如何组织、调用这些算法，从而让程序结构更灵活，具有更好的维护性和扩展性。</p>
<p>策略模式的优点：</p>
<ul>
<li>策略类之间可以自由切换，由于策略类实现自同一个抽象，所以他们之间可以自由切换</li>
<li>易于扩展，增加一个新的策略对策略模式来说非常容易，基本上可以在不改变原有代码的基础上进行扩展</li>
<li>使用策略模式可以避免使用多重条件(if-else)语句。多重条件语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重条件语句里面，比使用继承的办法还要原始和落后</li>
</ul>
<p>策略模式的缺点：</p>
<ul>
<li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道算法或行为的情况</li>
<li>由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观</li>
</ul>
<h2 id="代码实例："><a href="#代码实例：" class="headerlink" title="代码实例："></a>代码实例：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</div><div class="line">    <span class="comment">//持有一个具体策略的对象</span></div><div class="line">    <span class="keyword">private</span> Strategy strategy;        </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 构造函数，传入一个具体策略对象</div><div class="line">     * <span class="doctag">@param</span> strategy    具体策略对象</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(Strategy strategy)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.strategy = strategy;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 策略方法</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInterface</span><span class="params">()</span></span>&#123;</div><div class="line">        strategy.strategyInterface();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 策略方法</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyInterface</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyA</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyInterface</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//相关的业务</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyB</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyInterface</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//相关的业务</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Lujunqiu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">25</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lujunqiu</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
