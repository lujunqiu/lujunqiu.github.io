
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>Qiu‘s homepage</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Lujunqiu">
    

    
    <meta property="og:type" content="website">
<meta property="og:title" content="Qiu‘s homepage">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Qiu‘s homepage">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Qiu‘s homepage">

    
    <link rel="alternative" href="/atom.xml" title="Qiu‘s homepage" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="Qiu‘s homepage" title="Qiu‘s homepage"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Qiu‘s homepage">Qiu‘s homepage</a></h1>
				<h2 class="blog-motto">大道唯有自成。</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/06/30/模版方法模式/" title="模版方法模式" itemprop="url">模版方法模式</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lujunqiu" target="_blank" itemprop="author">Lujunqiu</a>
		
  <p class="article-time">
    <time datetime="2017-06-30T02:01:34.000Z" itemprop="datePublished"> Published 2017-06-30</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h1><p><em>定义：规定一个操作中的算法的骨架，而将步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义算法的某些特定步骤。</em></p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>通过模板方法我们可以控制子类扩展，因为子类必须遵守算法规则(从父类继承而来)。在多个子类拥有相同的方法，并且这些方法逻辑相同时，可以考虑使用模版方法模式。在程序的主框架相同，细节不同的场合下，也比较适合使用这种模式。</p>
<h2 id="策略模式的结构："><a href="#策略模式的结构：" class="headerlink" title="策略模式的结构："></a>策略模式的结构：</h2><p><img src="../../../../img/moshi/moban.png" alt=""></p>
<p>图中的角色：</p>
<p>抽象类（AbstractClass）：在抽象类中定义了一系列基本操作，这些基本操作可以是具体的，也可以是抽象的，每一个基本操作对应算法的一个步骤，在其子类中可以重定义或实现这些步骤。同时，在抽象类中实现了一个模板方法，用于定义一个算法的框架，模板方法不仅可以调用在抽象类中实现的基本方法，也可以调用在抽象类的子类中实现的基本方法，还可以调用其他对象中的方法。</p>
<p>具体类（ConcreteClass)：它是抽象类的子类，用于实现在父类中声明的抽象基本操作以完成子类特定算法的步骤，也可以覆盖在父类中已经实现的具体基本操作</p>
<h2 id="进一步了解策略模式"><a href="#进一步了解策略模式" class="headerlink" title="进一步了解策略模式"></a>进一步了解策略模式</h2><p>关于钩子方法：</p>
<p>由抽象类声明并加以实现，但是子类可以去扩展，子类可以通过扩展钩子方法来影响模版方法的逻辑。最简单的钩子方法就是空方法，另一种钩子方法可以实现对其他方法进行约束，这种钩子方法通常返回一个bool类型，即返回true或false，用来判断是否执行某一个基本方法。同时我们也可以在钩子方法中定义一个默认的实现，如果子类不覆盖钩子方法，则执行父类的默认实现代码。</p>
<p>优点：</p>
<ul>
<li>模板方法模式通过把不变的行为搬移到超类，去除了子类中的重复代码</li>
<li>子类实现算法的某些细节，有助于算法的扩展。</li>
<li>通过一个父类调用子类实现的操作，通过子类扩展增加新的行为，符合“开放-封闭原则”</li>
</ul>
<h2 id="代码实例："><a href="#代码实例：" class="headerlink" title="代码实例："></a>代码实例：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doAnything</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isDoSomething</span><span class="params">()</span></span>&#123; <span class="comment">//父类方法返回真</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">templateMethod</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * 调用基本方法，完成相关的逻辑</div><div class="line">         */</div><div class="line">        <span class="keyword">this</span>.doAnything();</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.isDoSomething())</div><div class="line">            <span class="keyword">this</span>.doSomething();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteClass1</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isDoSth;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doAnything</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">        <span class="comment">//子类实现具体</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub    </span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setDo</span><span class="params">(<span class="keyword">boolean</span> isDo)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.isDoSth = isDo;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isDoSomething</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> isDoSth;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/设计模式/">设计模式</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/模版方法模式/">模版方法模式</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/06/28/策略模式/" title="策略模式" itemprop="url">策略模式</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lujunqiu" target="_blank" itemprop="author">Lujunqiu</a>
		
  <p class="article-time">
    <time datetime="2017-06-28T06:09:53.000Z" itemprop="datePublished"> Published 2017-06-28</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p><em>定义：针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以互相替换。</em></p>
<p>策略模式属于对象行为模式，可以使得算法在不影响到客户端(算法的调用者)的情况下发生变化。策略模式通常把一个系列的算法包装到一系列的策略类里面，作为一个抽象策略类的子类，可以将策略模式理解为相同行为的不同实现而已。</p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>在软件开发中也常常遇到类似的情况，实现某一个功能有多种算法或者策略，我们可以根据环境或者条件的不同选择不同的算法或者策略来完成该功能。如查找、排序等，一种常用的方法是硬编码(Hard Coding)。在一个类中，如需要提供多种查找算法，可以将这些算法写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的查找算法；当然也可以将这些查找算法封装在一个统一的方法中，通过if…else…或者case等条件判断语句来进行选择。这两种实现方法我们都可以称之为硬编码，如果需要增加一种新的查找算法，需要修改封装算法类的源代码；更换查找算法，也需要修改客户端调用代码。在这个算法类中封装了大量查找算法，该类代码将较复杂，维护较为困难。如果我们将这些策略包含在客户端，这种做法更不可取，将导致客户端程序庞大而且难以维护，如果存在大量可供选择的算法时问题将变得更加严重。这时候我们就需要使用到策略模式来设计我们的代码了。</p>
<h2 id="策略模式的结构："><a href="#策略模式的结构：" class="headerlink" title="策略模式的结构："></a>策略模式的结构：</h2><p><img src="../../../../img/moshi/celue.png" alt=""></p>
<p>以上结构涉及到三个角色：</p>
<ul>
<li>环境(Context):持有一个Strategy的引用,对策略进行二次封装，目的是避免高层模块对策略的直接调用</li>
<li>抽象策略类(Strategy):通常由一个接口或者抽象类实现，给出所有的具体策略类所需的接口,当各个实现类中存在着重复的逻辑时，则使用抽象类来封装这部分公共的代码</li>
<li>具体策略类(ConcreteStrategy):包装了相关算法的实现</li>
</ul>
<h2 id="进一步了解策略模式"><a href="#进一步了解策略模式" class="headerlink" title="进一步了解策略模式"></a>进一步了解策略模式</h2><p>策略模式仅仅封装算法，在什么情况下使用什么算法是由调用者决定的，而且策略模式的重心不是如何实现算法，而是如何组织、调用这些算法，从而让程序结构更灵活，具有更好的维护性和扩展性。</p>
<p>策略模式的优点：</p>
<ul>
<li>策略类之间可以自由切换，由于策略类实现自同一个抽象，所以他们之间可以自由切换</li>
<li>易于扩展，增加一个新的策略对策略模式来说非常容易，基本上可以在不改变原有代码的基础上进行扩展</li>
<li>使用策略模式可以避免使用多重条件(if-else)语句。多重条件语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重条件语句里面，比使用继承的办法还要原始和落后</li>
</ul>
<p>策略模式的缺点：</p>
<ul>
<li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道算法或行为的情况</li>
<li>由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观</li>
</ul>
<h2 id="代码实例："><a href="#代码实例：" class="headerlink" title="代码实例："></a>代码实例：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</div><div class="line">    <span class="comment">//持有一个具体策略的对象</span></div><div class="line">    <span class="keyword">private</span> Strategy strategy;        </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 构造函数，传入一个具体策略对象</div><div class="line">     * <span class="doctag">@param</span> strategy    具体策略对象</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(Strategy strategy)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.strategy = strategy;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 策略方法</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInterface</span><span class="params">()</span></span>&#123;</div><div class="line">        strategy.strategyInterface();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 策略方法</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyInterface</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyA</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyInterface</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//相关的业务</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyB</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strategyInterface</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//相关的业务</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/设计模式/">设计模式</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/策略模式/">策略模式</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/06/24/Java多线程学习笔记/" title="Java多线程学习笔记" itemprop="url">Java多线程学习笔记</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lujunqiu" target="_blank" itemprop="author">Lujunqiu</a>
		
  <p class="article-time">
    <time datetime="2017-06-24T15:38:47.000Z" itemprop="datePublished"> Published 2017-06-24</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="Java多线程入门"><a href="#Java多线程入门" class="headerlink" title="Java多线程入门"></a>Java多线程入门</h1><h2 id="进程和多线程的概念"><a href="#进程和多线程的概念" class="headerlink" title="进程和多线程的概念"></a>进程和多线程的概念</h2><p>什么是进程？</p>
<p>进程是操作系统结构的基础，是一次程序的执行；是一个程序及其数据在处理机上顺序执行时所发生的活动；是程序在一个数据集合上运行的过程；它是系统进行资源分配和调度的一个独立单位；是受操作系统管理的基本运行单元。</p>
<p>什么是线程？</p>
<p>线程是在进程中独立运行的子任务。我们也要记住，多线程是异步的，线程被调用的时机是随机的，与CPU的调度有关，代码的执行顺序(代码的书写顺序)与代码的调用顺序无关。</p>
<p>线程的状态：</p>
<ul>
<li>新建状态(New):新创建了一个线程对象</li>
<li>就绪状态(Runnable):线程对象调用了start()方法后，该线程处于可运行线程池中，等待CPU的调度</li>
<li>运行状态(Running):CPU调度可运行池中的线程，执行线程的代码</li>
<li>阻塞状态(Blocked):线程因某种原因放弃CPU的使用权</li>
</ul>
<h2 id="使用多线程"><a href="#使用多线程" class="headerlink" title="使用多线程"></a>使用多线程</h2><h3 id="创建多线程对象"><a href="#创建多线程对象" class="headerlink" title="创建多线程对象"></a>创建多线程对象</h3><p>我们在运行Java代码的时候，有一个最基本的线程，就是在调用public static void main()方法的时候，我们其实在通过一个名为main的线程在执行main()方法，该线程由JVM创建。</p>
<p>创建多线程有２种方式，一种是继承Thread类，另一种是实现Runnable接口。这２种方式在工作时的性质是一样的，没有本质区别。</p>
<p><em>通过继承Thread类创建多线程：</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.run();</div><div class="line">        System.out.println(<span class="string">"Thread"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Thread thread = <span class="keyword">new</span> Thread();</div><div class="line">        thread.start();</div><div class="line">        System.out.println(<span class="string">"运行结束！"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<p>运行结束！</p>
<p>Thread</p>
<p>我们可以看到，继承Thread类的方式创建新线程时，最大的局限就是不支持多继承，所以为了支持多继承，完全可以实现Runnable接口的方式。</p>
<p>我们可以看到Thread类的源代码，如下：</p>
<p><em>public class Thread implements Runnable</em></p>
<p>从这里可以看出，Thread类实现了Runnbale接口，它们之间具有多态关系。</p>
<p>我们注意到Thread.java类中start()方法与run()方法都可以调用线程对象中的run()方法，这２个方法有什么区别呢？</p>
<p>Thread.java类中的start()方法通知”线程规划器”此线程已经准备就绪，等待调用线程对象的run()方法。这个过程其实就是让系统安排一个时间来调用Thread中的run()方法，也就是使线程得到运行，启动线程，具有异步执行的效果。如果调用代码的thread.run()方法就不是异步执行了，而是同步，那么此线程对象并不交给”线程规划器”来处理，而是由main主线程来调用run()方法，这个时候与多线程无关与普通调用方法一样，必须等run()方法中的代码执行完毕后才能执行main函数后面的代码。</p>
<p><em>通过实现Runnable接口创建多线程：</em></p>
<p>如果欲创建的线程类已经有一个父类了，这时就不能再继承Thread类了，所以我们需要实现Runnable接口来应对这样的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Runnable</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Runnable"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Runnable runnable = <span class="keyword">new</span> Runnable();</div><div class="line">        Thread thread = <span class="keyword">new</span> Thread(runnable);</div><div class="line">        thread.start();</div><div class="line">        System.out.println(<span class="string">"运行结束！"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<p>运行结束！</p>
<p>Runnable</p>
<p>另外需要说明的是，我们已经知道了Thread类实现了Runnbale接口，那也就意味着构造函数Thread(Runnable target)方法不光可以传入Runnable接口的对象，还可以传入一个Thread类对象，这样做完全可以将一个Thread对象中的run()方法交给其他的线程进行调用。</p>
<h3 id="多线程对象的常用函数"><a href="#多线程对象的常用函数" class="headerlink" title="多线程对象的常用函数"></a>多线程对象的常用函数</h3><ul>
<li>Thread.currentThread()方法返回代码段正在被哪个线程调用的信息</li>
<li><p>Thread对象实例.isAlive()方法的功能是判断当前线程是否处于活跃状态(正在运行状态或者准备开始运行状态)</p>
</li>
<li><p>Thread.sleep()方法的作用是在指定的毫秒数内让”当前执行的线程”休眠(暂停执行)</p>
</li>
<li><p>getId()方法可以获取线程的唯一标识</p>
</li>
<li><p>yield()方法的作用是放弃当前的CPU资源，将它让给其他的任务去占用CPU执行时间。当放弃的时间不确定，有可能刚刚放弃，马上又获取CPU时间片。</p>
</li>
</ul>
<p>接下来，我们重要讨论一下如何停止正在运行的线程。停止一个线程意味着在线程处理完任务之前停掉正在做的事情，也就是放弃当前的操作。</p>
<p>在Java中有３种方法可以终止正在运行的线程：</p>
<ol>
<li>使用退出标志，是线程正常退出，也就是run方法完成之后线程终止</li>
<li>使用stop方法强行终止线程，但是不推荐使用这个方法，因为stop和suspend以及resume一样，都是作废过期的方法，使用它们可能产生不可预料的结果</li>
<li>使用interrupt()方法中断线程</li>
</ol>
<p>接下来，介绍如何使用interrupt()方法来停止线程。</p>
<p>如何判断线程是否处于停止状态呢?</p>
<ol>
<li>Thread.interrupted():测试当前线程是否已经中断，static方法，调用这个方法后线程的中断状态被清除。换句话说，如果连续２次调用该方法，则第二次调用将返回false。</li>
<li>this.isInterrupted():测试线程Thread对象实例是否已经中断，非static方法，不清除状态标识</li>
</ol>
<p>调用interrupt()方法不会真的停止线程，而是在当前线程中打了一个停止的标记，还需要配合其他的代码来停止线程。</p>
<p>我们可以在线程对象的run()方法中加入判断语句，判断如果线程处于停止状态那么就可以通过异常来跳过后面的代码执行，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</div><div class="line">                <span class="keyword">if</span> (Thread.interrupted()) &#123;</div><div class="line">                    System.out.println(<span class="string">"停止状态"</span>);</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">                &#125;</div><div class="line">                System.out.println(<span class="string">"i = "</span> + i);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            System.out.println(<span class="string">"线程进入异常处理模块，停止运行run方法"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        MyThread thread = <span class="keyword">new</span> MyThread();</div><div class="line">        thread.start();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="number">1</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        thread.interrupt();</div><div class="line">        System.out.println(<span class="string">"end"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<p>…</p>
<p>i = 16</p>
<p>i = 17</p>
<p>end</p>
<p>i = 18</p>
<p>停止状态</p>
<p>线程进入异常处理模块，停止运行run方法</p>
<p>除了使用异常，我们还可以通过线程sleep的状态来停止线程以及通过interrupt方法与return结合来停止线程。不过，我们还是建议使用“抛异常”的方法来实现线程的停止，因为在catch快中还可以将异常向上抛，使线程停止的事件得到传播。</p>
<h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p>在操作系统中，线程可以划分优先级，优先级较高的线程得到的CPU资源较多，也就是CPU优先执行优先级较高的线程对象中的任务。</p>
<p>在Java中，线程的优先级分为１－１０这个１０个等级，如果超出范围，则JDK抛出异常。</p>
<p>优先级具有继承性质，比如A线程启动了B线程，则B线程的优先级与A是一样的。</p>
<p>但是，优先级具有随机性，高优先级的线程总是大部分先执行完，但不代表高优先级的线程全部都先执行完，CPU是<em>尽量</em>将执行资源让给优先级比较高的线程而已。</p>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>在Java中有２种线程：一种是用户线程，另一种是守护线程。</p>
<p>守护线程是一种特殊的线程，当进程中不存在非守护线程了，守护线程就自动销毁。典型的守护线程就是垃圾回收线程，当进程中没有非守护线程了，则垃圾回收线程也就没有存在的必要了，自动销毁。Deamon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是GC(垃圾回收器)。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaSE/">JavaSE</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/多线程/">多线程</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/06/22/编辑距离问题/" title="编辑距离问题" itemprop="url">编辑距离问题</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lujunqiu" target="_blank" itemprop="author">Lujunqiu</a>
		
  <p class="article-time">
    <time datetime="2017-06-22T01:37:41.000Z" itemprop="datePublished"> Published 2017-06-22</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="编辑距离问题"><a href="#编辑距离问题" class="headerlink" title="编辑距离问题"></a>编辑距离问题</h1><p>概念描述：编辑距离，又称Levenshtein距离，是指两个字串之间，由一个转成另一个所需的最少编辑操作次数。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。</p>
<p>问题解析：</p>
<p>计算编辑距离的问题，符合动态规划的几个特征：</p>
<p>最优子结构性质。如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。</p>
<p>无后效性。即子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。</p>
<p>子问题重叠性质。子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。</p>
<p>因此考虑用动态规划求解。</p>
<p>首先，我们可以定义一个函数——edit(i,j)，它表示第一个字符串的长度为i的子串到第二个字符串的长度为j的子串的编辑距离。这也就是动态规划过程中状态的定义，接下来我们就要探讨状态转移方程是如何描述的。</p>
<p>状态转移可以分为以下几个情况来讨论：</p>
<ul>
<li>if i == 0 &amp;&amp; j == 0 ,edit(i,j) = 0</li>
<li>if i == 0 &amp;&amp; j &gt; 0 ,edit(i,j) = j</li>
<li>if i &gt; 0 &amp;&amp; j == 0 ,edit(i,j) = i</li>
<li>if i &gt; 0 &amp;&amp; j &gt; 0 ,edit(i,j) = min{edit(i - 1,j) + 1 ,edit(i,j - 1) + 1 ,edit(i - 1,j - 1) + f(i,j)},当第一个字符串的第i个字符不等于第二个字符串的第j个字符的时候，f(i,j) = 1,否则 f(i,j) = 0</li>
</ul>
<p>根据状态的定义与状态转移方程的描述，我们在解决问题的过程中只需要完成一个二维数组作为DP表就行。</p>
<p>代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    System.out.println(getEditDistance(<span class="string">"ab"</span>, <span class="string">"abaaa"</span>));</div><div class="line">    System.out.println(getEditDistance(<span class="string">"abcca"</span>, <span class="string">"abaaa"</span>));</div><div class="line">    System.out.println(getEditDistance(<span class="string">"ab"</span>, <span class="string">"aba"</span>));</div><div class="line">    System.out.println(getEditDistance(<span class="string">"cafe"</span>, <span class="string">"coffee"</span>));</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getEditDistance</span><span class="params">(String s, String t)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> dp[][];</div><div class="line">    <span class="keyword">int</span> n;<span class="comment">//字符串s的长度</span></div><div class="line">    <span class="keyword">int</span> m;<span class="comment">//字符串t的长度</span></div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">int</span> j;</div><div class="line">    <span class="keyword">char</span> s_i;<span class="comment">//字符串s的第i个字符</span></div><div class="line">    <span class="keyword">char</span> t_j;<span class="comment">//字符串t的第j个字符</span></div><div class="line"></div><div class="line">    n = s.length();</div><div class="line">    m = t.length();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> m;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> n;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</div><div class="line">    <span class="comment">//初始化第一列</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n; i++) &#123;</div><div class="line">        dp[i][<span class="number">0</span>] = i;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//初始化第一行</span></div><div class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= m; j++) &#123;</div><div class="line">        dp[<span class="number">0</span>][j] = j;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//根据状态转移方程完成DP表</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</div><div class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= m; j++) &#123;</div><div class="line">            s_i = s.charAt(i - <span class="number">1</span>);</div><div class="line">            t_j = t.charAt(j - <span class="number">1</span>);</div><div class="line">            <span class="keyword">int</span> f;</div><div class="line">            <span class="keyword">if</span> (s_i == t_j) &#123;</div><div class="line">                f = <span class="number">0</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                f = <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">            dp[i][j] = mininum(dp[i - <span class="number">1</span>][j] + <span class="number">1</span>, dp[i][j - <span class="number">1</span>] + <span class="number">1</span>, dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + f);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dp[n][m];</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line">３个数取最小值方法</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mininum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> min = a &lt; b ? a : b;</div><div class="line">    <span class="keyword">return</span> min &lt; c ? min : c;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/算法/">算法</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/算法/">算法</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/06/21/Maven学习笔记/" title="Maven学习笔记" itemprop="url">Maven学习笔记</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lujunqiu" target="_blank" itemprop="author">Lujunqiu</a>
		
  <p class="article-time">
    <time datetime="2017-06-21T05:04:37.000Z" itemprop="datePublished"> Published 2017-06-21</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="什么是Maven"><a href="#什么是Maven" class="headerlink" title="什么是Maven"></a>什么是Maven</h2><p>maven这个单词的翻译为“专家”或“内行”。作为我们开发过程中使用的工具而言，Maven是一个跨平台的项目管理工具，并且是Apache组织中的开源项目之一，主要用于Java平台的项目构建，依赖管理和项目信息管理等。它是一个异常强大的构建工具，能够帮助我们自动化构建过程，从清理，编译，测试到生产报告，再到打包和部署，我们只需要使用maven配置好项目，然后输入简单的命令，maven会帮我们处理这些繁琐的任务。</p>
<p>maven是跨平台的，这意味着无论是windows上还是在linux,mac上的项目都可以使用同样的命令。同时，maven不仅仅是构建工具，还是一个依赖管理工具和项目信息管理个工具，可以帮助我们自动下载项目所需要的构件。</p>
<p>maven对于项目目录结构，测试用例命名方法等内容都有既定的规则，只要遵循了这些成熟的规则，我们在不同的项目切换的时候就免去了额外的学习成本，上手就容易许多，可以说是约定优于配置(Convention over Configuration)。</p>
<h2 id="Maven的安装-Ubantu"><a href="#Maven的安装-Ubantu" class="headerlink" title="Maven的安装(Ubantu)"></a>Maven的安装(Ubantu)</h2><ol>
<li><p>检查系统的java环境变量配置是否成功</p>
<p> qiu@qiu-qiu:~$ echo $JAVA_HOME</p>
<p> qiu@qiu-qiu:~$ java -version</p>
</li>
<li><p>java环境配置成功后，下载maven:<a href="http://maven.apache.org/download.cgi" target="_blank" rel="external">http://maven.apache.org/download.cgi</a></p>
</li>
<li><p>配置maven的环境变量:</p>
<p> 解压安装包后，到解压出来的maven文件的目录下创建一个符号链接，方便更新：</p>
<p> qiu@qiu-qiu:~$ ln -s apache-maven-3.5.0 apache-maven</p>
<p> 设置M2_HOME变量指向这个符号链接，然后将符号链接中的bin目录添加进系统的PATH变量:</p>
<p> qiu@qiu-qiu:~$ sudo vi /etc/profile</p>
<p> 添加以下几行：</p>
<p> export M2_HOME=/home/qiu/maven/apache-maven</p>
<p> export PATH=$PATH:$M2_HOME/bin</p>
<p> 最后更新配置文件:</p>
<p>　qiu@qiu-qiu:~$ source /etc/profile</p>
</li>
<li><p>检查是否安装成功</p>
<p>  qiu@qiu-qiu:~$ mvn -v</p>
</li>
</ol>
<p>输出：</p>
<p>Apache Maven 3.5.0 (ff8f5e7444045639af65f6095c62210b5713f426; 2017-04-04T03:39:06+08:00)<br>Maven home: /home/qiu/maven/apache-maven<br>Java version: 1.8.0_131, vendor: Oracle Corporation<br>Java home: /usr/jdk1.8.0_131/jre<br>Default locale: zh_CN, platform encoding: UTF-8<br>OS name: “linux”, version: “4.8.0-49-generic”, arch: “amd64”, family: “unix”</p>
<p>关于maven的升级：由于我们之前平行地创建了一个符号链接，然后在配置环境变量的时候使用的是这个符号链接，于是在升级的时候就可以利用这个符号链接了。我们只需要将符号链接指向新的maven版本即可。</p>
<p>在IDEA(版本：2017.1.2)开发环境中搭建maven：<br>在Settings—Build,Execution,Deployment—Build Tools—Maven中设置Maven home directory;   User settings file;   Local repository即可。</p>
<h1 id="maven的使用"><a href="#maven的使用" class="headerlink" title="maven的使用"></a>maven的使用</h1><h2 id="POM文件"><a href="#POM文件" class="headerlink" title="POM文件"></a>POM文件</h2><p>maven项目的核心是pom.xml。POM(Project Object Model，项目对象模型)定义了项目的基本信息，用于描述项目是如何构建的，声明项目依赖，等等。</p>
<p>pom.xml文件里面元素介绍：<br>首先是XML头，指定了该xml文件的版本以及编码方式。紧接着是project元素，project元素是所有pom.xml的根元素，它还声明了一些POM相关的命名空间以及xsd元素。根元素下的第一个子元素是modelVersion指定了当前POM模型的版本。接下来介绍３个重要的元素标签：<br>groupId,artifactId,version。这３个元素定义了一个项目的基本坐标，在maven世界中，任何的jar,pom或者war都是以基于这些基本的坐标进行区分的。</p>
<p>groupId定义了项目属于哪个组，这个组往往和项目所在的组织有关。artifactId定义了当前maven项目在组中唯一的ID。version，顾名思义，指定了当前项目的版本号。最后还可以为项目设定name元素，声明一个对于用户更为友好的项目名称。</p>
<p>dependencies元素声明项目的依赖(java代码中的import)，该元素下可以包含多个dependency元素，里面包含所依赖的构件的mavan坐标。</p>
<p>没有任何实际的java代码，我们就能够定义一个maven项目的POM，这体现了maven的一大优点，它能让项目对象模型最大程度地与实际代码相独立，也就是解耦。这样也避免了java代码与POM代码的相互影响。比如以后当项目需要升级版本的时候，我们只需要修改POM即可。</p>
<h2 id="主代码以及测试代码"><a href="#主代码以及测试代码" class="headerlink" title="主代码以及测试代码"></a>主代码以及测试代码</h2><p>项目的主代码和测试代码不用在于，主代码会被打包到最终的构件中(如jar)，而测试代码只是在运行测试时候用到，不会被打包。</p>
<p>一般来说，项目中的java类的包(package)都应该基于项目的groupId和artifactId，这样更加清晰，更加符合逻辑，也方便搜索构件或者java类。</p>
<p>主代码位于:/src/main/java目录下;测试代码位于:/src/test/java目录下；</p>
<h2 id="mvn命令"><a href="#mvn命令" class="headerlink" title="mvn命令"></a>mvn命令</h2><p>mvn clean　：清除maven的输出目录target</p>
<p>mvn compile :编译项目主代码，将项目主代码编译至target/classes目录中</p>
<p>mvn test-compile　：编译测试的内容</p>
<p>mvn test :运行测试(在运行测试之前会自动执行项目主资源处理，主代码编译，测试资源<br>处理，测试代码编译等工作)</p>
<p>mvn package :生成target目录，编译、测试代码，生成测试报告，生成jar/war文件；默认是jar文件，只打包主项目代码。</p>
<p>mvn install :在本地Repository中安装jar</p>
<p>mvn archetype:generate　：创建mvn项目(使用Archetype生成项目骨架)</p>
<p>mvn dependency:list :查看当前项目的已解析依赖</p>
<p>mvn dependency:tree :查看当前项目的依赖树(传递依赖的路径)</p>
<p>mvn dependency:analyze :帮助分析当前项目的依赖</p>
<h1 id="maven坐标"><a href="#maven坐标" class="headerlink" title="maven坐标"></a>maven坐标</h1><p>为了能够自动化解析任何一个java构件，maven就必须将他们唯一标识，这就依赖管理的底层基础－－坐标。maven定义了这样一组规则：世界上任何一个构件都可以使用maven坐标唯一标识，maven坐标的元素包括groupId,artifactId,version,packaging,classifier。</p>
<p>坐标元素介绍：</p>
<p>groupId:定义当前maven项目隶属的实际项目</p>
<p>artifactId：定义实际项目中的一个maven项目(模块)</p>
<p>version:定义maven项目的当前所处的版本</p>
<p>packaging:定义maven项目的打包方式，默认的打包方式是jar</p>
<p>classifier：用来帮助定义构建输出的一些附属构件。不能直接定义项目的classifier，因为附属构件不是项目默认生成的，而是由附件的插件帮助生成的</p>
<h1 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h1><p>根元素project下的dependencies可以包含一个或者多个dependency元素，以声明一个或者多个项目依赖。每个依赖可以包含的元素有：</p>
<p>groupId,artifactId和version:依赖的基本坐标，对于任何一个依赖来说，基本坐标是最重要的，maven根据坐标才能找到需要的依赖。</p>
<p>type:依赖的类型，对应于项目坐标定义的packaging。大部分情况下，该元素不必声明，默认为jar</p>
<p>scope:依赖的范围</p>
<p>optional:标记依赖是否可选</p>
<p>exclusions:用来排除传递性依赖</p>
<h2 id="依赖的范围"><a href="#依赖的范围" class="headerlink" title="依赖的范围"></a>依赖的范围</h2><p>依赖范围就是用来控制依赖与三种classpath(编译classpath,测试classpath,运行classpath)的关系:</p>
<p>compile:编译依赖范围。如果没有指定，就会默认是该范围。此范围的依赖对编译，测试，运行都有效。</p>
<p>test:测试依赖范围。只在测试是有效，在编译主代码或者运行项目的时候无法使用此类依赖。</p>
<p>provided:已提供依赖范围。对于编译和测试有效，但在运行时候无效。</p>
<p>runtime:运行时依赖范围。对于测试和运行时有效，但在编译主代码时无效。</p>
<h2 id="依赖的传递性"><a href="#依赖的传递性" class="headerlink" title="依赖的传递性"></a>依赖的传递性</h2><p>在使用其他依赖的构件的时候，不用去考虑它依赖了什么，也不用担心引入多余的依赖。maven会解析各个直接依赖的POM,将那些必要的间接依赖以传递性的形式引入到当前的项目中。</p>
<p>maven引入的传递性依赖机制，一方面大大简化和方便了依赖声明，另一方面，大部分情况下我们只需要关心项目的直接依赖是什么，而不用去考虑这些直接依赖会引入声明传递性依赖。</p>
<h2 id="依赖的调解"><a href="#依赖的调解" class="headerlink" title="依赖的调解"></a>依赖的调解</h2><p>比如，项目A有这样的依赖关系:A–B–C–X(1.0)，A–D–X(2.0)，这个时候X是A的传递性依赖。会选择哪个呢？根据maven的第一原则：路径最近者优先。选择X(2.0)；</p>
<p>那么，如果路径相同的呢？这时就用到了第二原则：第一声明者优先。也就是说，在依赖路径长度相等的时候，在POM中的依赖声明的顺序决定了谁会被使用。</p>
<h2 id="排除依赖"><a href="#排除依赖" class="headerlink" title="排除依赖"></a>排除依赖</h2><p>传递性依赖会给项目隐式地引入很多依赖，这极大地简化了项目依赖的管理，但是由于一些原因，不想引入某些传递性依赖。这个时候我们可以使用exclusions标签声明排除依赖，exclusions可以包含一个或者多个exclusion子元素，可以排除一个或者多个传递性依赖。</p>
<h1 id="maven仓库"><a href="#maven仓库" class="headerlink" title="maven仓库"></a>maven仓库</h1><h2 id="maven仓库简介"><a href="#maven仓库简介" class="headerlink" title="maven仓库简介"></a>maven仓库简介</h2><p>坐标和依赖是任何一个构件在maven世界中的逻辑表示方式，而构件的物理表示方式是文件，maven通过仓库来统一管理这些文件。实际的maven项目将不再各自存储其依赖文件，它们只需要声明这些依赖的坐标，在需要的时候,maven会自动根据坐标找到仓库中的构件，并使用它们。</p>
<h2 id="maven仓库分类"><a href="#maven仓库分类" class="headerlink" title="maven仓库分类"></a>maven仓库分类</h2><p>对于maven来说，仓库分为２大类：本地仓库与远程仓库。当maven根据坐标寻找构件的时候，它首先会查看本地仓库，如果本地仓库存在此构件，则直接使用。如果本地仓库不存在此构件，或者需要查看是否有更新的构件，maven就会去远程仓库查找，发现需要的构件之后，下载到本地仓库再使用。如果本地仓库与远程仓库都没有，则报错。</p>
<p>这里，需要说明私服。私服是一种特殊的远程仓库，为了节省带宽和时间，应该在局域网内架设一个私有的仓库服务器，用其代理所有外部的远程仓库。</p>
<p>如果默认的中央仓库无法满足项目的需求，可能项目需要的构件存在于另一个远程仓库中。这个时候可以在项目的POM文件中，repositories元素下使用repository子元素声明一个或者多个远程仓库。我们需要注意的是，maven默认的中央仓库的id是central。</p>
<h2 id="依赖坐标搜索"><a href="#依赖坐标搜索" class="headerlink" title="依赖坐标搜索"></a>依赖坐标搜索</h2><p>使用maven进行日常开发的时候，一个常见的问题就是如何寻找需要的依赖，我们可以通过需要使用的类库的名字来找到maven依赖所需的坐标。</p>
<p>我们可以直接去maven的官方网站的中央仓库搜索也可以通过其他的搜索服务，比如：</p>
<p>地址：<a href="http://repository.sonatype.org/" target="_blank" rel="external">http://repository.sonatype.org/</a></p>
<p>Nexus是当前流行的开源maven仓库管理软件，提供了关键字搜索，类名搜索，坐标搜索等功能。</p>
<h1 id="生命周期与插件"><a href="#生命周期与插件" class="headerlink" title="生命周期与插件"></a>生命周期与插件</h1><p>在maven的日常使用中，命令行的输入往往就对应了生命周期，如mvn package就表示执行默认生命周期阶段package。maven的生命周期是抽象的，其实际行为都由插件来完成，如package阶段的任务可能就就会由maven-jar-plugin完成。</p>
<p>maven的生命周期就是为了对所有的构建过程进行抽象统一，包含了项目的清理，初始化，编译，测试，打包，集成测试，验证，部署和站点生成等几乎所有的构建步骤。所有的项目构建都能够映射到这样一个生命周期上。在maven的设计中，实际的任务(如编译源代码)都交由插件了完成。</p>
<p>maven定义的生命周期和插件机制一方面保证了所有maven项目有一致的构建标准，另一方面又通过默认插件简化和稳定了实际项目的构建。此外，该机制还提供了足够的扩展空间，用户可以通过配置现有的插件或者自行编写插件来自定义构建行为。</p>
<h2 id="三套生命周期"><a href="#三套生命周期" class="headerlink" title="三套生命周期"></a>三套生命周期</h2><p>maven拥有三套互相独立的生命周期，分别是clean,default和site。需要注意的是，生命周期之间是互相独立的，生命周期中的各个阶段是前后依赖的。</p>
<h3 id="clean生命周期"><a href="#clean生命周期" class="headerlink" title="clean生命周期"></a>clean生命周期</h3><p>clean生命周期的目的是清理项目，它包含三个阶段：</p>
<ol>
<li><p>pre-clean 执行一些清理前需要完成的工作</p>
</li>
<li><p>clean 清理上一次构建生成的文件</p>
</li>
<li><p>post-clean 执行一些清理后需要完成的工作</p>
</li>
</ol>
<h3 id="default生命周期"><a href="#default生命周期" class="headerlink" title="default生命周期"></a>default生命周期</h3><p>default生命周期定义了真正构建时所需要执行的所有步骤，它是所有生命周期中最核心的部分。</p>
<p>这里只列举一些常见的阶段：(按照先后顺序)</p>
<p>compile:编译项目的主源码。一般来说，是编译src/main/java目录下的java文件至项目输出的主classpath目录中</p>
<p>test-compile:编译项目的测试代码。一般来说，是编译src/test/java目录下的java文件至项目输出的主classpath目录中</p>
<p>test:使用单元测试框架运行测试，测试代码不会被打包或部署</p>
<p>package:接受编译好的代码，打包成可发布的格式，如jar</p>
<p>install:将包安装到maven本地仓库</p>
<p>deploy:将最终的包复制到远程仓库</p>
<h3 id="site生命周期"><a href="#site生命周期" class="headerlink" title="site生命周期"></a>site生命周期</h3><p>site生命周期的目的是建立和发布项目站点，maven能够基于POM所包含的信息，自动生成一格友好的站点，方便团队交流和发布项目信息。</p>
<p>pre-site:执行一些在生成项目站点之前需要完成的工作</p>
<p>site:生成项目站点文档</p>
<p>post-site:执行一些在生成项目站点之后需要完成的工作</p>
<p>site-deploy:将生成的项目站点发布到服务器上</p>
<h2 id="插件目标"><a href="#插件目标" class="headerlink" title="插件目标"></a>插件目标</h2><p>我们知道，maven的核心仅仅定义了抽象的生命周期，具体的任务是交由插件完成的，插件以独立的构件形式存在。对于插件本身，为了能够复用代码，它往往能够完成多个任务，因此这些功能聚集在一个插件里，每个功能就是一个插件目标。</p>
<p>maven的生命周期与插件互相绑定，用以完成实际的构建任务。具体而言，是生命周期的阶段与插件的目标互相绑定，以完成某个具体的构建任务。</p>
<p>几乎所有maven插件的目标都有一些可配置的参数，可以通过POM文件的配置来调整参数。关于插件的文档信息，我们可以参考Apache的maven官方网站上去获取。</p>
<h1 id="聚合与继承"><a href="#聚合与继承" class="headerlink" title="聚合与继承"></a>聚合与继承</h1><p>在这个技术飞速发展的时代，各类用户对软件的要求越来越高，软件本身也变得越来越复杂。因此，软件设计人员往往会采用各种方式对软件划分模块，以得到更清晰的设计以及更高的重用性。当把maven应用到实际项目中的时候，也需要将项目分成不用的模块。maven的聚合特性能够把项目的各个模块聚合在一起构建，而maven的继承特性则能够帮助抽取各个模块中相同的　依赖和插件等配置，在简化POM的同时，还能促进各个模块配置的一致性。</p>
<h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><p>当我们希望一次性构建多个项目，而不是到多个模块的目录下分别运行mvn命令。这个时候，就需要maven的聚合。</p>
<p>为了能够使用一条命令就能构建多个模块，我们需要创建一个额外的模块(聚合模块)，然后通过该模块构建整个项目的所有模块。额外的聚合模块的POM特殊在于：</p>
<p>packaging标签的值为:POM。对于非聚合模块，他们的packaging默认为jar。</p>
<p>modules元素，这是实现聚合的核心配置。我们可以通过在一个打包方式为POM的maven项目中声明任意数量的module元素(需要被聚合的模块)来实现模块的聚合，每一个module的值都是一个当前的POM的相对目录(需要被聚合的模块的目录相对与当前聚合模块POM的相对目录)。</p>
<p>为了方便构建，通常将聚合模块放在项目目录的最顶层，其他模块则作为聚合模块的子目录存在。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>maven里面的继承，准确的说是POM文件的继承。我们可以创建POM文件的父子结构，然后在父POM中声明一些配置提供给子POM继承，以实现”一处声明，多处使用”的目的。父POM的packaging为pom，这一点与聚合模块一样。</p>
<p>由于父模块只是为了帮助消除配置的重复，因此它本身不包含除POM之外的项目文件。</p>
<p>有了父模块，就需要让其他模块来继承它。子模块的POM中，使用parent元素来声明父模块，parent下的子元素groupId,artifactId,version指定了父模块的坐标，元素relativePath表示父模块POM的相对路径。当项目构建时，maven首先会根据ralativePath检查父模块的POM,如果找不到，再从本地仓库中查找。relativePath的默认值是 ../pom.xml　也就是说，maven默认父POM在上一层目录中。</p>
<h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p>在POM文件中，依赖是可以被继承的。maven提供dependencyManagement元素既能让子模块继承到父模块的依赖配置，又能保证子模块依赖使用的灵活。在dependencyManagement元素下的依赖声明不会引入实际的依赖，不过它能够约束dependencies下依赖的使用。使用dependencyManagement声明的依赖，不会给子模块引入依赖，但是可以被继承。在子模块中只需要声明依赖的使用，如果子模块不声明依赖的使用，即使该依赖已经在父POM的dependencyManagement中声明了，也不会产生任何实际的效果。</p>
<p>在dependencyManagement元素中有import依赖范围，使用该范围的依赖通常指向一个POM,作用是将目标POM中的dependencyManagement配置导入并合并到当前POM的dependencyManagement元素中。这里import表示导入配置的意思。</p>
<h3 id="插件管理"><a href="#插件管理" class="headerlink" title="插件管理"></a>插件管理</h3><p>类似地，maven也提供了pluginManagement元素帮助管理插件，在该元素下配置的依赖不会造成实际的插件调用行为，当POM中配置了真正的plugin元素，并且其groupId,artifactId与pluginManagement中的插件匹配时，pluginManagement的配置才会影响实际的插件行为。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/工具/">工具</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Maven/">Maven</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/06/21/设计模式原则/" title="设计模式原则" itemprop="url">设计模式原则</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lujunqiu" target="_blank" itemprop="author">Lujunqiu</a>
		
  <p class="article-time">
    <time datetime="2017-06-21T01:39:19.000Z" itemprop="datePublished"> Published 2017-06-21</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="单一职责原则-Single-Responsibility-Principle"><a href="#单一职责原则-Single-Responsibility-Principle" class="headerlink" title="单一职责原则(Single Responsibility Principle)"></a>单一职责原则(Single Responsibility Principle)</h1><p>定义：就一个类而言，不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责。</p>
<p>例如：类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。</p>
<p>按照单一职责原则，我们做出如下的修改：分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险。</p>
<p>很多情况是，我们在设计之初是遵循单一职责原则的。随着需求的增加，类的职责被细化，被分为粒度更加小的职责。这个时候我们本应该是把原来的类分为2个类来写的，但是为了方便，我们大多数选择直接修改原来的类，这样就使原来的类拥有了不止1个职责。虽然这样做有悖于单一职责原则。但是这样做的风险在于职责扩散的不确定性，因为我们不会想到某个职责P，在未来可能会扩散为P1，P2，P3，P4……Pn。所以，在职责扩散到我们无法控制的程度之前，立刻对代码进行重构。</p>
<p>单一职责原则的特点：</p>
<ul>
<li>可以降低类的复杂度，一个类只负责一项职责，逻辑简单</li>
<li>提高类的可读性，提高系统的可维护性</li>
<li>降低了设计的耦合程度，变更引起的风险降低。</li>
</ul>
<h1 id="里氏替换原则-Liskov-Substitution-Principle"><a href="#里氏替换原则-Liskov-Substitution-Principle" class="headerlink" title="里氏替换原则(Liskov Substitution Principle)"></a>里氏替换原则(Liskov Substitution Principle)</h1><p>定义：所有引用父类的地方必须能透明地使用其子类的对象。也就是说子类可以扩展父类的功能，但不能改变父类原有的功能。</p>
<p>上述的定义可能很抽象。通俗来说，我们在使用到继承的时候：子类继承父类，除添加新的方法完成新增功能外，尽量不要重写父类的方法，也尽量不要重载父类的方法。因为父类中凡是已经实现好的方法，实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。而里氏替换原则就是表达了这一层含义。</p>
<p>在实际编程中，我们常常会通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的几率非常大。如果非要重写父类的方法，比较通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖、聚合，组合等关系代替。我们还希望在程序中尽量使用父类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。</p>
<p>里氏替换原则的特点：</p>
<ul>
<li>尽量把父类设计为抽象类或者接口，子类实现父类的抽象方法，但不能覆盖父类的非抽象方法</li>
<li>子类中可以增加自己特有的方法</li>
<li>当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松</li>
<li>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格</li>
</ul>
<h1 id="依赖倒置原则-Dependence-Inversion-Principle"><a href="#依赖倒置原则-Dependence-Inversion-Principle" class="headerlink" title="依赖倒置原则(Dependence Inversion Principle)"></a>依赖倒置原则(Dependence Inversion Principle)</h1><p>定义：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。核心思想还是面向接口编程，而不是面向实现编程。</p>
<p>在Java中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。</p>
<p>这就要求我们在程序代码中传递参数时或在关联关系（依赖关系）中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。</p>
<p>更加进一步来说，在实现依赖倒转原则时，我们需要针对抽象层编程，而将具体类的对象通过依赖注入(DependencyInjection,DI)的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。</p>
<p>常用的注入方式有三种，分别是：构造注入，设值注入（Setter注入）和接口注入。构造注入是指通过构造函数来传入具体类的对象，设值注入是指通过Setter方法来传入具体类的对象，而接口注入是指通过在接口中声明的业务方法来传入具体类的对象。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象。这些注入方式在Spring里面都有很好的体现。</p>
<p>在实际编程中，我们一般需要做到如下3点：</p>
<ul>
<li>低层模块尽量都要有抽象类或接口，或者两者都有。</li>
<li>变量的声明类型尽量是抽象类或接口。</li>
<li>使用继承时遵循里氏替换原则。</li>
</ul>
<h1 id="接口隔离原则-Interface-Segregation-Principle"><a href="#接口隔离原则-Interface-Segregation-Principle" class="headerlink" title="接口隔离原则(Interface  Segregation Principle)"></a>接口隔离原则(Interface  Segregation Principle)</h1><p>定义：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。也就是说我们要使用多个专门的接口，而不使用单一的总接口。</p>
<p>接口隔离原则的含义是：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。在程序设计中，依赖几个专用的接口要比依赖一个综合的接口更灵活。接口是设计时对外部设定的“契约”，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</p>
<p>一般而言，接口中仅包含为某一类用户定制的方法即可，不应该强迫客户依赖于那些它们不用的方法。</p>
<p>采用接口隔离原则对接口进行约束时，要注意以下几点：</p>
<ul>
<li>接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。</li>
<li>为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。</li>
<li>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</li>
</ul>
<h1 id="迪米特法则-Law-of-Demeter"><a href="#迪米特法则-Law-of-Demeter" class="headerlink" title="迪米特法则(Law of  Demeter)"></a>迪米特法则(Law of  Demeter)</h1><p>定义：一个对象应该对其他对象保持最少的了解。迪米特法则又叫做最少知道原则。”低耦合，高内聚“</p>
<p>通俗的来讲，就是一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类来说，无论逻辑多么复杂，都尽量地的将逻辑封装在类的内部，对外除了提供的public方法，不对外泄漏任何信息。      </p>
<p>如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易。迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。</p>
<p>迪米特法则还有一个更简单的定义：只与直接的朋友通信，直接的朋友有哪些：</p>
<ol>
<li>当前对象本身(this)；</li>
<li>以参数形式传入到当前对象方法中的对象；</li>
<li>当前对象的成员对象；</li>
<li>如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友；</li>
<li>当前对象所创建的对象。</li>
</ol>
<p>任何一个对象，如果满足上面的条件之一，就是当前对象的“朋友”，否则就是“陌生人”。在应用迪米特法则时，一个对象只能与直接朋友发生交互，不要与“陌生人”发生直接交互，出现在局部变量中的类则不是直接的朋友。也就是说，陌生的类最好不要作为局部变量的形式出现在类的内部。这样做可以降低系统的耦合度，一个对象的改变不会给太多其他对象带来影响。</p>
<p>迪米特法则要求我们在设计系统时，应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。</p>
<h1 id="开闭原则-Open-Closed-Principle"><a href="#开闭原则-Open-Closed-Principle" class="headerlink" title="开闭原则(Open-Closed Principle)"></a>开闭原则(Open-Closed Principle)</h1><p>定义：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。</p>
<p>开闭原则是面向对象设计中最基础的设计原则，它指导我们如何建立稳定灵活的系统。开闭原则可能是设计模式六项原则中定义最模糊的一个了，它只告诉我们对扩展开放，对修改关闭，可是到底如何才能做到对扩展开放，对修改关闭，并没有明确的告诉我们。</p>
<p>也就是说，只要我们对前面5项原则遵守的好了，设计出的软件自然是符合开闭原则的，这个开闭原则更像是前面五项原则遵守程度的“平均得分”，前面5项原则遵守的好，平均分自然就高，说明软件设计开闭原则遵守的好；如果前面5项原则遵守的不好，则说明开闭原则遵守的不好。</p>
<p>单一职责原则告诉我们实现类要职责单一；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合。而开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/设计模式/">设计模式</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/设计模式原则/">设计模式原则</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/05/07/命令行的使用/" title="命令行的使用" itemprop="url">命令行的使用</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lujunqiu" target="_blank" itemprop="author">Lujunqiu</a>
		
  <p class="article-time">
    <time datetime="2017-05-07T13:44:18.000Z" itemprop="datePublished"> Published 2017-05-07</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一提到Linux,许多人都会说到“自由”,但我不认为他们都知道“自由”的真正涵义。“自由”是一种权力,它意味着你能决定你的计算机能做什么,同时能够拥有这种“自由”的唯一方式就是知道计算机正在做什么。这个时候，我们就需要命令行来帮助我们与计算机交互获得“自由”。所以人们常说，“图形用户界面让简单的任务更容易完成，而命令行界面使完成复杂的任务成为可能”，到现在这句话仍然很正确。接下来的正文有点像是在做笔记的形式，没有成文，写这篇博客的目的也是为了方便查阅。</p>
<h1 id="什么是Shell"><a href="#什么是Shell" class="headerlink" title="什么是Shell?"></a>什么是Shell?</h1><p>管理整个计算机硬件的是操作系统的内核(kernel),一般用户只能通过Shell命令行工具来跟内核通信。那么为什么叫Shell？因为Shell给用户提供一个与操作系统通信的接口，就如同鸡蛋的外壳一样。</p>
<p>几乎所有的Linux 发行版都提供一个名为bash的来自GNU项目的Shell程序。“bash”是“Bourne Again SHell”的首字母缩写，所指的是这样一个事实，bash是最初Unix 上由Steve Bourne 写成Shell 程序sh 的增强版。</p>
<h2 id="关于Shell的常用知识"><a href="#关于Shell的常用知识" class="headerlink" title="关于Shell的常用知识"></a>关于Shell的常用知识</h2><h3 id="终端提示符"><a href="#终端提示符" class="headerlink" title="终端提示符"></a>终端提示符</h3><p>在Shell的终端输入提示符的最后会有一个符号分别表示：</p>
<p>$:表示普通用户权限</p>
<p>#:表示root用于权限</p>
<h3 id="命令历史"><a href="#命令历史" class="headerlink" title="命令历史"></a>命令历史</h3><p>当我们想要查询之前使用过的的命令时候，可以使用history命令来查看历史，用法如下：</p>
<p>history [n]：查找最近的n条命令</p>
<p>history [-c]：将目前的shell中的所有history命令删除</p>
<p>history [-raw] 文件名：将目前的命令保持到文件中去</p>
<p>终端输入ctrl + r ：搜索历史命令。从当前命令行开始，向上递增搜索。<br>搜索到之后可以直接Enter执行，也可以ctrl + j　复制到终端界面。</p>
<p>!的使用：</p>
<p>! 数字：执行第几条命令</p>
<p>! 命令：由最近的命令向前搜索开头为“命令”的那个命令执行</p>
<p>!? 字符串: 重复最近历史中，包含这个字符串的命令。</p>
<p>!!:执行上一个命令</p>
<h3 id="Shell终端复制字符"><a href="#Shell终端复制字符" class="headerlink" title="Shell终端复制字符"></a>Shell终端复制字符</h3><p>按下鼠标左键，沿着文本拖动鼠标（或者双击一个单词）高亮了一些文本，那么这些高亮的文本就被拷贝到了一个缓冲区里面，然后按下鼠标中键，这些文本就被粘贴到光标所在的位置。</p>
<p>注意：不要在一个终端窗口里使用Ctrl-c和Ctrl-v快捷键来执行拷贝和粘贴操作。它们不起作用。对于Shell来说，这两个控制代码有着不同的含义。</p>
<h3 id="关于Shell中常用的路径"><a href="#关于Shell中常用的路径" class="headerlink" title="关于Shell中常用的路径"></a>关于Shell中常用的路径</h3><p>绝对路径：由根目录(/)开始写起的文件名或者目录名称。</p>
<p>相对路径：相对于目前路径的文件名写法。</p>
<p>. 代表当前的目录，也可以使用./ 表示；</p>
<p>.. 代表上一层目录，也可以使用 ../表示；</p>
<h3 id="万能的man"><a href="#万能的man" class="headerlink" title="万能的man"></a>万能的man</h3><p>命令的使用说明帮助：</p>
<p>man + 命令名称 </p>
<p>比如输入：qiu@qiu-empty:~$ man date</p>
<p>会得到date命令的manual（操作说明）；</p>
<p>查看的输出结果man page时候，可以用”/word“查找关键词，操作类似less，more等命令查阅文本； </p>
<h3 id="重要的热键"><a href="#重要的热键" class="headerlink" title="重要的热键"></a>重要的热键</h3><p>Tab：</p>
<p>命令补全，文件补齐：按一次Tab自动补全，按2次Tab显示所有匹配的命令或者文件。</p>
<p>Ctrl + c：</p>
<p>如果在Linux下输入了错误的命令，导致系统一直在运行，按 Ctrl + c 来中断目前执行的命令。</p>
<p>Ctrl + z：</p>
<p>将任务中止（暂停的意思）,但是此任务并没有结束,他仍然在进程中他只是维持挂起的状态,用户可以使用fg/bg操作继续前台或后台的任务,fg命令重新启动前台被中断的任务,bg命令把被中断的任务放在后台执行</p>
<p>Ctrl + d：</p>
<p>表示一个特殊的二进制值，表示 EOF（End Of File）</p>
<p>注：在shell中，ctrl-d表示推出当前shell。相当于输入exit；</p>
<p>Ctrl + U:将整行命令删除</p>
<p>Ctrl + S:暂停屏幕的输出</p>
<p>Ctrl + Q:恢复屏幕的输出</p>
<h1 id="什么是命令？"><a href="#什么是命令？" class="headerlink" title="什么是命令？"></a>什么是命令？</h1><p>命令可以是下面四种形式之一：</p>
<ol>
<li>是一个可执行程序，就像我们所看到的位于目录/usr/bin 中的文件一样。属于这一类的程序，可以编译成二进制文件，诸如用C 和C++ 语言写成的程序, 也可以是由脚本语言写成的程序，比如说shell，perl，python，ruby，等等。</li>
<li>是一个内建于shell 自身的命令。bash 支持若干命令，内部叫shell 内部命令(builtins)。例如，cd 命令，就是一个shell 内部命令。</li>
<li>是一个shell 函数。这些是小规模的shell 脚本，它们混合到环境变量中。在后续的章节<br>里，我们将讨论配置环境变量以及书写shell 函数。但是现在，仅仅意识到它们的存在就<br>可以了。</li>
<li>是一个命令别名。我们可以定义自己的命令，建立在其它命令之上。</li>
</ol>
<h2 id="如何识别命令"><a href="#如何识别命令" class="headerlink" title="如何识别命令"></a>如何识别命令</h2><p>type + 命令名 ：显示命令的类型</p>
<p>which + 命令名 ：显示一个可执行程序的位置</p>
<p>help + 命令名 ：得到shell 内部命令的帮助文档</p>
<p>–help ： 显示用法信息，许多可执行程序支持一个–help参数选项，这个选项是显示命令所支持的语法和选项说明。</p>
<p><em>man + 命令名 ：显示程序手册页，所有的命令都可以使用man来详细查询使用的方法！</em></p>
<p>info + 命令名 ：显示程序Info 条目</p>
<h2 id="使用别名（alias"><a href="#使用别名（alias" class="headerlink" title="使用别名（alias)"></a>使用别名（alias)</h2><p>在创建别名之前，我们可以使用type命令查询我们想要的别名是否存在。在命令行中定义的别名，当你的shell会话结束时，它们会消失。我们要学会把自己的别名添加到文件中去，每次我们登录系统，这些文件会建立系统环境。</p>
<h1 id="文件的操作"><a href="#文件的操作" class="headerlink" title="文件的操作"></a>文件的操作</h1><h2 id="必须要知道的"><a href="#必须要知道的" class="headerlink" title="必须要知道的"></a>必须要知道的</h2><p>Linux文件能不能被执行与文件后缀名无关，是由是否具有”x“这个权限来决定的。”x“权限表示该文件具有可执行权限；</p>
<p>更改文件或目录的模式(权限),可以利用 chmod 命令。注意只有文件的所有者或者超级用户才能更改文件或目录的模式。chmod命令支持两种不同的方法来改变文件模式:八进制数字表示法,或符号表示法。</p>
<p>sudo命令给普通用户以超级用户的权限。</p>
<p>文件名和命令名是大小写敏感的。</p>
<p>在linux中所以设备都是文件！</p>
<h2 id="操作文件的命令"><a href="#操作文件的命令" class="headerlink" title="操作文件的命令"></a>操作文件的命令</h2><h3 id="切换目录，Change-Directory"><a href="#切换目录，Change-Directory" class="headerlink" title="切换目录，Change Directory"></a>切换目录，Change Directory</h3><p>关于cd 命令的快捷键：<br>cd           更改工作目录到你的家目录。</p>
<p>cd -        更改工作目录到先前的工作目录。</p>
<p>cd ..        去上一层目录</p>
<h3 id="显示当前目录"><a href="#显示当前目录" class="headerlink" title="显示当前目录"></a>显示当前目录</h3><p>pwd：显示当前目录，Print Working Directory</p>
<h3 id="创建新目录"><a href="#创建新目录" class="headerlink" title="创建新目录"></a>创建新目录</h3><p>mkdir：新建新目录，make directory</p>
<p>比如：qiu@qiu-empty:~$ mkdir [-mp] 目录名称</p>
<p>-m：配置文件的权限</p>
<p>-p：递归的创建文件</p>
<p>比如你要创建/test/test1/test2这个文件，你首先要先创建test以及test1，用-p参数可以直接递归的一次性全部创建完成。</p>
<h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><p>ls：查看文件与目录</p>
<p>-a：以 “.” 字符开头的文件名是隐藏文件。这仅表示，ls 命令不能列出它们， 用 ls -a 命令就可以了。</p>
<p>-d：仅列出目录本身，而不是列出目录内的文件数据</p>
<p>-l：列出长数据，包含文件的属性与权限等等</p>
<h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>cp(copy):复制文件或目录:</p>
<p>cp [-adfilprsu] source destination</p>
<p>-r:递归持续复制，用于目录的复制行为,目录属性可能会发生变化，想要使得复制之后的目录和原目录完全一样，可以使用cp -a </p>
<p>-s:复制成为符号链接文件，即”快捷方式”文件；</p>
<p>-i:若destination文件已经存在，在覆盖的时候会询问；</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>rm(remove):移除文件或目录</p>
<p>rm [-fir] filename</p>
<p>-f:force,强制执行；</p>
<p>-i:互动模式,Interaction,在操作前会询问；</p>
<p>-r:递归的删除,谨慎使用；</p>
<p>小贴士： 无论什么时候，rm 命令用到通配符（除了仔细检查输入的内容外！）， 用 ls 命令来测试通配符。这会让你看到要删除的文件列表。然后按下上箭头按键，重新调用刚刚执行的命令，用 rm 替换 ls。</p>
<h3 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h3><p>mv(move):移动文件或目录，或更名</p>
<p>mv [-fiu] source destination</p>
<h3 id="内容查阅"><a href="#内容查阅" class="headerlink" title="内容查阅"></a>内容查阅</h3><p>文件内容查阅：</p>
<p>cat：由第一行开始显示文件内容</p>
<p>tac：cat的倒写，由最后一行开始显示文件内容</p>
<p>nl：显示的时候，顺便输出行号</p>
<p>more：一页一页地显示文件内容</p>
<p>less：与more类似，但是可以往前翻页</p>
<p>head：只看头几行</p>
<p>tail：只看结尾几行</p>
<p>od：以二进制的方式读取文件内容</p>
<p><em>less查看的操作类似man：</em></p>
<p>space：向下翻页</p>
<p>b : 向上翻页</p>
<p>PageDown：向下翻页</p>
<p>PageUp：向上翻页</p>
<p>/字符串：向下查询字符串</p>
<p>?字符串：向上查询字符串</p>
<p>q：离开</p>
<h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><p>touch命令：</p>
<p>touch [-acdmt] filename</p>
<p>创建一个空的文件；也可以用于修改文件的日期；</p>
<p>关于文件的日期：mtime（modification time，内容修改日期），ctime（status time，状态修改日期），atime（access time，读取日期）</p>
<h3 id="文件的查询"><a href="#文件的查询" class="headerlink" title="文件的查询"></a>文件的查询</h3><p>查看文件类型：file命令</p>
<p>先用whereis，locate来检查（速度快一点），最后找不到了才用find(查找文件的复杂方式)来查询；locate只能依据文件名来查找文件，而find程序能基于各种各样的属性， 搜索一个给定目录（以及它的子目录），来查找文件。</p>
<p>locate命令：</p>
<p>locate [-ir] keyword</p>
<p>-i:忽略大小写</p>
<p>-r:后面可接正则表达式的显示方式</p>
<p>locate与whereis是经由数据库来查找的，当你新建文件后查找该文件有可能会找不到，需要用updatedb命令来手动更新数据库。</p>
<h3 id="压缩与解压文件"><a href="#压缩与解压文件" class="headerlink" title="压缩与解压文件"></a>压缩与解压文件</h3><p>tar -zcv -f filename.tar.gz 要被压缩的文件</p>
<p>tar -jcv -f filename.tar.bz2 要被压缩的文件</p>
<p>tar -zxv -f filename.tar.gz -C 欲解压缩的目录</p>
<p>tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录</p>
<h3 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h3><p>关于符号链接：（类似windows系统中的快捷方式）</p>
<p>在大多数“类 Unix” 系统中，有可能一个文件被多个文件名所指向，叫做符号链接（也称为软链接或者 symlink）。有利于文件的共享的操作，在文件名改动之后不需要修改其他程序。一个符号链接指向一个文件，而且这个符号链接本身与其它的符号链接几乎没有区别。例如，如果你往一个符号链接里面写入东西，那么相关联的文件也被写入。然而，当你删除一个符号链接时，只有这个链接被删除，而不是文件自身。如果先于符号链接删除文件，这个链接仍然存在，但是不指向任何东西。在这种情况下，这个链接被称为坏链接。</p>
<h1 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h1><p>“I/O” 代表输入/输出，通过I/O重定向，你可以重定向命令的输入输出，命令的输入来自文件，而输出也存到文件。也可以把多个命令连接起来组成一个强大的命令管道。</p>
<p>数据流的重定向：将某个命令执行后应该要出现在屏幕上的数据传输到其他的地方去，例如文件或者设备。</p>
<p>管道命令：</p>
<p>使用 | 界定符号，与连续执行命令不一样；</p>
<p>比如我们想知道/etc下文件，输入 ls -a /etc 导致一口气屏幕被塞满，这时我们可以用less命令来协助查看:</p>
<p>ls -a /etc | less</p>
<p>表示这个管道命令 | 仅能处理经由前面一个命令传来的正确的信息，也就是standard output，在管道后面接的第一个数据一定是命令，而且这个命令必须要能接受standard output，例如：（查看）less，more，head，tail，（选取）cut，grep，（排序）sort，wc，uniq，（双重定向）tee，等等</p>
<h1 id="Shell中的命令"><a href="#Shell中的命令" class="headerlink" title="Shell中的命令"></a>Shell中的命令</h1><p>echo ： 显示一行文本</p>
<p>花括号展开：你可以从一个包含花括号的模式中创建多个文本字符串。</p>
<p>花括号展开模式可能包含一个开头部分叫做报头，一个结尾部分叫做附言。花括号表达式本身可能包含一个由逗号分开的字符串列表，或者一系列整数，或者单个的字符串。这种模式不能嵌入空白字符。</p>
<p>例如：</p>
<p>echo Front-{A,B,C}-Back</p>
<p>输出：Front-A-Back Front-B-Back Front-C-Back</p>
<p>echo Number_{1..5}</p>
<p>输出：Number_1 Number_2 Number_3 Number_4 Number_5</p>
<p>echo {Z..A}</p>
<p>输出:Z Y X W V U T S R Q P O N M L K J I H G F E D C B A</p>
<h2 id="Shell中的变量："><a href="#Shell中的变量：" class="headerlink" title="Shell中的变量："></a>Shell中的变量：</h2><p>变量的定义：一组文字或者符号等，来替代一些设置或者一串保留的数据；</p>
<p>变量的显示：echo $变量名</p>
<p>比如：echo $PATH</p>
<p>取消变量的设置：unset 变量名</p>
<p>将变量设置为环境变量，提供子进场执行：export 变量名</p>
<p>?变量：上一个执行的命令所传回的值，一般来说，如果成功执行命令，则会回传一个0值。所以我们可以通过echo $？ 查看上一个命令是否成功执行；</p>
<p>双引号的作用：</p>
<p>如果你把文本放在双引号中，Shell使用的特殊字符，除了$，\ (反斜杠），和‘（倒引号）之外，则失去它们的特殊含义，被当作普通字符来看待。这意味着单词分割，路径名展开，波浪线展开，和花括号展开都被禁止，然而参数展开，算术展开，和命令替换仍然执行。使用双引号，我们可以处理包含空格的文件名。</p>
<p>比方说：我们是two words.txt文件的受害者。如果我们试图在命令行中使用这个文件，单词分割机制会导致这个文件名被看作两个独自的参数，而不是所期望的单个参数：</p>
<p>ls -l two words.txt</p>
<p>ls: cannot access two: No such file or directory</p>
<p>ls: cannot access words.txt: No such file or directory</p>
<p>使用双引号，我们可以阻止单词分割，得到期望的结果；进一步，我们甚至可以修复破损的文件名。</p>
<p>ls -l “two words.txt”</p>
<p>-rw-rw-r– 1 me me 18 2008-02-20 13:03 two words.txt</p>
<p>记住，在双引号中，参数展开，算术表达式展开，和命令替换仍然有效：</p>
<p>echo “$USER $((2+2)) $(cal)”</p>
<p>me 4 February 2008</p>
<p>Su Mo Tu We Th Fr Sa</p>
<p>….</p>
<p>转义字符的使用：</p>
<p>有时候我们只想引用单个字符。我们可以在字符之前加上一个反斜杠，在这个上下文中叫做转义字符。经常在双引号中使用转义字符，来有选择地阻止展开。</p>
<p>比如:（转义美元符$）</p>
<p>echo “The balance for user $USER is: \$5.00”</p>
<p>The balance for user me is: $5.00</p>
<p>还有一个场景：</p>
<p>命令的执行是从上到下，从左到右的，与命令的执行一样，只识别一个空白格，多个空白格会被忽略掉。如果读到Enter符号(CR)，就尝试执行该行的命令，但是可以使用\Enter来转义扩展到下一行输入。</p>
<h2 id="关于键盘的使用技巧"><a href="#关于键盘的使用技巧" class="headerlink" title="关于键盘的使用技巧"></a>关于键盘的使用技巧</h2><p>ctrl + a ：移动光标到行首</p>
<p>ctrl + e ：移动光标到行末</p>
<p>ctrl + d : 删除光标位置的字符</p>
<p>ctrl + u ：剪贴从光标到行首的文本</p>
<p>ctrl + k : 剪贴从光标到行尾的文本</p>
<p>ctrl + y : 把剪贴的文本复制粘贴到光标位置 </p>
<h1 id="软件包的管理"><a href="#软件包的管理" class="headerlink" title="软件包的管理"></a>软件包的管理</h1><p>一般而言，大多数发行版分别属于两大包管理技术阵营：Debian的”.deb”，和红帽的”.rpm”，他们分别对应的系统如下。</p>
<p>Debian Style (.deb)：Debian, Ubuntu, Xandros, Linspire</p>
<p>Red Hat Style (.rpm)：Fedora, CentOS, Red Hat Enterprise Linux, OpenSUSE, Mandriva, PCLinuxOS</p>
<p>软件包管理系统通常由两种工具类型组成：底层工具用来处理这些任务，比方说安装和删除软件包文件，和上层工具，完成元数据搜索和依赖解析。虽然所有基于 Red Hat风格的发行版都依赖于相同的底层程序（rpm）,但是它们却使用不同的上层工具。</p>
<p>如下所示：</p>
<p>Debian-Style：dpkg（底层工具）；apt-get, aptitude（上层工具）；</p>
<p>Fedora, Red Hat Enterprise Linux,CentOS：rpm（底层工具）；yum（上层工具）；</p>
<h2 id="如何操作软件包？"><a href="#如何操作软件包？" class="headerlink" title="如何操作软件包？"></a>如何操作软件包？</h2><p>1.从资源库中安装一个软件包：<br>上层工具允许从一个资源库中下载一个软件包，并经过完全依赖解析来安装它。</p>
<p>Debian：apt-get update; apt-get install package_name</p>
<p>Red Hat：yum install package_name</p>
<p>2.通过软件包文件来安装软件：<br>如果从某处而不是从资源库中下载了一个软件包文件，可以使用底层工具来直接（没有经过依赖解析）安装它。</p>
<p>Debian：dpkg –install package_file</p>
<p>Red Hat：rpm -i package_file</p>
<p>3.卸载软件：<br>可以使用上层或者底层工具来卸载软件。下面是可用的上层工具。</p>
<p>Debian：apt-get remove package_name</p>
<p>Red Hat：yum erase package_name</p>
<p>4.经过资源库来更新软件包：</p>
<p>Debian：apt-get update; apt-get upgrade</p>
<p>Red Hat：yum update</p>
<p>5.列出所安装的软件包：</p>
<p>Debian：dpkg –list</p>
<p>Red Hat：rpm -qa</p>
<p>6.确定是否安装了一个软件包：</p>
<p>Debian：dpkg –status package_name</p>
<p>Red Hat：rpm -q package_name</p>
<h1 id="关于Shell脚本"><a href="#关于Shell脚本" class="headerlink" title="关于Shell脚本"></a>关于Shell脚本</h1><h2 id="什么是Shell脚本"><a href="#什么是Shell脚本" class="headerlink" title="什么是Shell脚本"></a>什么是Shell脚本</h2><p>一个 Shell 脚本就是一个包含一系列命令的文件。Shell读取这个文件，然后执行 文件中的所有命令，就好像这些命令已经直接被输入到了命令行中一样。</p>
<h2 id="如何编写Shell脚本"><a href="#如何编写Shell脚本" class="headerlink" title="如何编写Shell脚本"></a>如何编写Shell脚本</h2><p>Shell脚本就是普通的文本文件。所以我们需要一个文本编辑器来书写它们。最好的文本编辑器都会支持语法高亮，这样我们就能够看到一个脚本关键字的彩色编码视图。语法高亮会帮助我们查看某种常见错误。</p>
<p>使脚本文件可执行。系统会相当挑剔不允许任何旧的文本文件被看作是一个程序，并且有充分的理由!所以我们需要设置脚本文件的权限来允许其可执行。<br>对于脚本文件，有两个常见的权限设置；权限为755的脚本，则每个人都能执行，和权限为700的脚本，只有文件所有者能够执行。注意为了能够执行脚本，脚本必须是可读的。</p>
<p>把脚本放置到 shell能够找到的地方.当没有指定可执行文件明确的路径名时，shell 会自动地搜索某些目录，来查找此可执行文件。为了最大程度的方便，我们会把脚本放到这些目录当中。</p>
<h2 id="脚本文件的位置"><a href="#脚本文件的位置" class="headerlink" title="脚本文件的位置"></a>脚本文件的位置</h2><p>我们知道，如果没有给出可执行程序的明确路径名，那么系统每次都会搜索一系列的目录，来查找此可执行程序。这个/bin目录就是其中一个系统会自动搜索的目录。 这个目录列表被存储在一个名为PATH的环境变量中。这个PATH变量包含一个由冒号分隔开的目录列表。</p>
<p>这里，如果我们要修改PATH变量添加目录的话，通过修改我们的.bashrc 文件，当做了这个修改之后，它会在每个新的终端会话中生效。为了把这个修改应用到当前的终端会话中， 我们必须让 shell 重新读取这个 .bashrc 文件。这可以通过 “sourcing”.bashrc 文件来完成。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Linux/">Linux</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Linux/">Linux</a><a href="/tags/Shell/">Shell</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/04/24/Https/" title="HTTPS" itemprop="url">HTTPS</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lujunqiu" target="_blank" itemprop="author">Lujunqiu</a>
		
  <p class="article-time">
    <time datetime="2017-04-24T11:51:07.000Z" itemprop="datePublished"> Published 2017-04-24</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们在享受互联网给我们带来的便利的同时也承受了互联网带来的伤害，比如上网的时候经常会遇到密码被盗，信息泄露等令人郁闷的事情。其中有一个原因为：互联网早期绝大部分网站使用的是<a href="http://lujunqiu.github.io/2017/04/08/http/" target="_blank" rel="external">HTTP协议</a>，我们在http协议下输入的任何信息都是不加密的。简单来说，这些密码以及个人隐私信息全都一字一句在网络传输中“裸奔”。</p>
<p>虽然http协议本身简单而且方便使用，但也存在一些安全性上不足，比如：</p>
<ul>
<li>通信使用明文（不加密），内容很可能被窃听 </li>
<li>不验证通信双方的身份，通信对象很可能被伪装</li>
<li>无法证明报文的完整性，通信内容很可能被修改</li>
</ul>
<p>其实这类问题，不仅仅会出现在http协议中，所有本身不涉及加密的协议都存在这些安全性的不足。</p>
<p>所谓互联网，是由能连通到全世界的网络组成的。无论哪个地方的服务器与客户端通信时，在通信线路上会经过很多网络设备，你无法保证这些设备的安全性，这些“坏蜀黍”就很有可能会泄露或者攥改你的通信内容，甚至伪装起来，而且你根本无法辨别。</p>
<p>但是不要慌，你可以发现我们现在浏览的大部分网页都是https开头的，也就是说它们已经升级为了https协议了。https到底是什么玩意呢？</p>
<h2 id="什么是HTTPS协议呢？"><a href="#什么是HTTPS协议呢？" class="headerlink" title="什么是HTTPS协议呢？"></a>什么是HTTPS协议呢？</h2><p>HTTPS（HTTP Secure）并非是一种新的协议，简单来说，https就是给http加了一个“安全套”，即使别人拿到了信息，也不知道里面到底是个什么。这个外加的“安全套”叫做SSL（Secure Socket Layer），所谓的HTTPS，其实也就是身披SSL协议这层外壳的HTTP罢了。</p>
<p><img src="../../../../img/https/1.png" alt=""></p>
<p>而且，SSL是独立HTTP的协议，采用了SSL之后，HTTP就拥有了加密，证书和完整性保护这些功能了。</p>
<p><img src="../../../../img/https/2.png" alt=""></p>
<h2 id="两种加密方式"><a href="#两种加密方式" class="headerlink" title="两种加密方式"></a>两种加密方式</h2><p>在讲SSL之前，先简单了解一下加密的知识。总体来说，加密分为2大类，对称密钥加密，非对称密钥加密。</p>
<p>加密和解密同用一个密钥的方式称为共享密钥加密（Common key crypto system），也就是我们所说的对称加密。</p>
<p>举个例子，客户想发送“12345”给服务器，又不想明文发送，于是他就用了一个简单的加密算法，不直接发送“12345”转而发送“do re mi fa so”给服务器。服务器一看，由于事先已经和客户商量好了，知道了客户是用音符加密，于是就同样的原理解密“do re mi fa so”得到“12345”。这个过程就是对称密钥加密，当然在实际运用过程中，加密解密算法肯定不会这么简单的。</p>
<p>这里有一个bug，我们如何将对称的密钥安全地传递给通信方呢？假设我使用了一种对称加密算法加密了通信报文，同时我希望将解密的密钥给对方，否则对方就无法解密报文。但是从现在来看我们没有办法保证把密钥传递给对方的通信的安全性。我们在互联网上转发密钥时，如果通信被监听那么密钥就会泄露，同时也就失去了加密的意义。</p>
<p>在上面的例子来看，客户端和服务器要事先商量好对称密钥，也就是使用音符来加密，但如果这个商量的过程是无法加密的，有可能被坏人监听泄露，那么后续的加密也就没有作用了。</p>
<p><img src="../../../../img/https/3.png" alt=""></p>
<p>那么，如果解决上面的问题呢？</p>
<p>答案就是使用两把密钥的公开密钥加密。</p>
<p>公开密钥加密使用一对非对称的密钥。一把叫做私有密钥，另一把叫做公开密钥。顾名思义，私有密钥不能让其他人知道，而公开密钥则可以随意发布。具体非对称密钥是如何操作的呢？</p>
<p>再举个例子，假设A想B发送一个报文，使用非对称密钥加密。那么，A首先去B的主页（qq空间朋友圈或者微博啥的）找到B发布的公开密钥，然后用B发布的公开密钥加密将要发送的报文信息。B在得到了使用自己的公开密钥加密的报文后，使用B的的私有密钥来解密报文就可以得到原文了。</p>
<p>这种加密和解密使用不同的密钥的方式就是非对称加密，利用这种方式，不需要发送用来解密的私有密钥，也就不必担心密钥被其他坏人窃听。</p>
<h2 id="HTTPS的安全通信机制"><a href="#HTTPS的安全通信机制" class="headerlink" title="HTTPS的安全通信机制"></a>HTTPS的安全通信机制</h2><p>HTTPS使用的是两种加密并用的混合加密机制。你可能会有个疑问，为什么不只使用非对称加密呢？相比于对称加密，非对称加密处理速度要慢很多，对于网络这种实时性要求高的应用，非对称加密的速度还是不够。</p>
<p>我们知道，对称加密方法（共享密钥加密）速度快，而且简单易行，但就是在交换共享密钥的时候无法保证其安全性。那么，我们可以在交换共享密钥的时候使用非对称加密（公开密钥加密）来保证交换过程的安全性，之后建立通信阶段则使用对称加密方式（共享密钥加密），如图所示。</p>
<p><img src="../../../../img/https/4.png" alt=""></p>
<p>很遗憾，上述机制仍然不完善，因为我们无法证明公开密钥本身的正确性。比如，我们正准备和某主机服务器通信，我们无法证明得到的公开密钥就是原本预想的那台服务器发行的公开密钥。因为有可能在公开密钥的传输过程中，真正的公开密钥已经被坏人篡改替换掉了，或者你访问的根本就是一台别人伪装的服务器。</p>
<p>这就涉及到在互联网上如何识别一个主机的身份的问题了。在现实生活中，如果有个人说自己是华科的某系的老师，你会怎么判断呢？很简单，我们找到这个系你信任的或者大家都信任的老师或者同学来问一问，如果他们说是，那你也就相信了。说白了，就是找一个公认靠谱的人来验证其他人靠不靠谱。在互联网中，也是这个逻辑，数字证书认证机构（CA，Certificate Authority）就是来解决这个工作的。</p>
<p>数字证书认证机构处于客户端与服务器双方都信赖的第三方机构的立场。具体如何运作的呢？首先，服务器的运营人员向数字证书认证机构提出认证申请。数字证书认证机构在判明了申请者的身份后，会给申请者的公开密钥（与申请者通信要使用的加密密钥）做数字签名，然后将数字签名以及公开密钥做成公钥证书发给申请者。</p>
<p>服务器得到公钥证书后，当有客户想要和服务器通信的时候，服务器将公钥证书发给客户。得到公钥证书的客户可以向数字证书认证机构确认证书上数字签名的正确性，从而可以确认服务器的真实身份。</p>
<h3 id="SSL通信过程"><a href="#SSL通信过程" class="headerlink" title="SSL通信过程"></a>SSL通信过程</h3><p><img src="../../../../img/https/5.png" alt=""><br><img src="../../../../img/https/6.png" alt=""></p>
<p>步骤1:首先由客户发起通信请求，通过发送Client Hello报文给服务器打个招呼，开始SSL通信。</p>
<p>步骤2:服务器收到了Client Hello后，出于礼貌也必须要回复Server Hello（大家都不高冷）。</p>
<p>步骤3:双方互相打完招呼后，服务器发送Certificate报文，其中包含我们之前讲的公开密钥证书。</p>
<p>步骤4:最后服务器发送Server Hello Done报文，告知客户端这次SSL握手协商顺利结束。</p>
<p>步骤5:握手协商阶段结束后，客户端发送Client Key Exchange报文，使用步骤3的公开密钥加密一种被称为pre－master secret的随机密码串。</p>
<p>步骤6:客户端继续发送Change Cipher Spec报文，提示服务器在后续的HTTP通信中使用pre－master secret密钥加密。</p>
<p>步骤7:客户端发送Finished报文。该报文包含对上述报文的整体校验值，用于服务器来判断是否协商成功的标准。</p>
<p>步骤8:服务器同样发送Change Cipher Spec报文。</p>
<p>步骤9:服务器发送Finished报文。</p>
<p>步骤10，11:服务器与客户端交换Finished报文之后，SSl安全通信建立完成。现在就可以开始HTTP通信了。</p>
<p>步骤12:最后通信结束，由客户端断开连接。</p>
<p>这里解释一下pre－master secret报文的含义：</p>
<p>我们只知道客户端生成随机数据，并且把这个随机数据用服务端发送过来的的公共密钥加密，此次加密过程产生本次握手中的pre－master secret，然后将它送回给服务端。</p>
<p>Server验证完client的身份之后，然后用自己的私有密钥解密得到Pre－master secret然后双方利用这个pre－master secret来共同协商，得到master secret。</p>
<p>双方用master secret一起产生真正的session key，这将是一个对称加密的key。这个key还可以用来验证数据完整性。双方再交换结束信息。握手结束。接下来双方就可以用协商好的算法和密钥key，采用对称加密算法来通信了。</p>
<h3 id="HTTPS协议的效率问题"><a href="#HTTPS协议的效率问题" class="headerlink" title="HTTPS协议的效率问题"></a>HTTPS协议的效率问题</h3><p>既然HTTPS相比于HTTP协议是安全可靠的协议，那为什么所有的网站不一直使用HTTPS呢？</p>
<p>这里就涉及到HTTPS的效率问题了，因为与纯文本通信相比，加密通信会消耗更多的CPU及内存资源。如果每次通信都加密，则会加大网络的负载，同时消耗更多服务器和客户端的硬件资源。</p>
<p>于是，如果是非敏感的信息我们可以考虑使用HTTP通信，只有在包含个人信息等敏感数据时，才使用HTTPS加密通信。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>我们到此简单介绍了HTTPS协议的由来以及SSL握手的过程，如果想要深入了解协议的细节（有点枯燥）可以参考《HTTPS权威指南》。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/计算机网络/">计算机网络</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/https协议/">https协议</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/04/08/http/" title="HTTP" itemprop="url">HTTP</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lujunqiu" target="_blank" itemprop="author">Lujunqiu</a>
		
  <p class="article-time">
    <time datetime="2017-04-08T09:31:54.000Z" itemprop="datePublished"> Published 2017-04-08</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前在学习javaEE相关的javaWeb技术的时候，发现自己对HTTP协议的了解太缺乏了，导致看起书来“香菇，难受”，于是花了一点时间学习了HTTP协议，当时也没有很详细去了解细节。现在过了几个星期，是时候写篇博客复习一下了。</p>
<h1 id="什么是http？"><a href="#什么是http？" class="headerlink" title="什么是http？"></a>什么是http？</h1><p>&nbsp;&nbsp;可以这么说，只要是上过网的人都接触过http协议。我们每天都会通过浏览器（Web browser）来访问网页的信息，过程再熟悉不过了：首先在浏览器地址栏输入URL(Uniform Resource Identifier)，也就是我们常说的网址，如果访问的网址是正确的且允许访问的，那么我们就可以得到网页信息了。<br><img src="../../../../img/http/1.png" alt=""></p>
<p>如图中所示的过程，客户端(Web browser)与所要访问的互联网资源(resource)所在的服务器(Server)是使用http协议来交换信息的。那么，什么是通信协议呢？打个比方，在中国人与人之间的“通信协议”是中文，在那些English speaking countries的人们则是用英文交流。中文与英文就好比是不同地区人们的“通信协议”。同样的道理，在互联网上每天都有大量的数据信息在交换，通信协议的重要性不言而喻。我们介绍的Http协议正是Web服务器与Web客服端之间的顶层通信协议之一，也是我们作为互联网使用者最常见的协议。</p>
<blockquote>
<p><em>HTTP:HyperText Transfer Protocol , 超文本传输协议</em></p>
</blockquote>
<p>什么是超文本?简单的说,超文本是一种可以链接到任何其他信息的文本。我们知道，网页本质来说就是一种超文本(HTML,HyperText Markup Language)，浏览器的作用就是解析并且渲染来自服务器端传来的HTML页面，最后呈现给我们看。顾名思义，http协议正是这个传输过程的关键所在。</p>
<h1 id="计算机网络协议体系"><a href="#计算机网络协议体系" class="headerlink" title="计算机网络协议体系"></a>计算机网络协议体系</h1><p>计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标，由哪一边先发起通信，使用哪种语言进行通信，怎样结束通信等规则都需要事先确定。不同的硬件，操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议(protocol)。</p>
<p>在介绍http协议之前，先要了解一下整个互联网的协议体系。我们通常使用的网络(包括互联网)是在TCP/IP协议族的基础上运行的，而http协议只是属于它内部的一个子集。</p>
<p>整个网络通信过程需要制定规则的内容太多了， 从电缆的规格到IP地址的选定方法，寻找异地用户的方法，双方建立通信的顺序，以及Web页面显示需要处理的步骤，等等。如果互联网只是由一个协议统筹，某个地方需要改变设计的时候，就必须把所遇部分整体替换掉。显然，这种设计很愚蠢。</p>
<p>TCP/IP协议族采用分层管理，通常按层次分别为以下4层：应用层，传输层，网络层和数据链路层。如果我们能把各层之间的接口部分规划合理，每个层次内部的设计就封装独立起来了。层次化之后，设计也变得相对简单了。比如，处于应用层上的协议可以只考虑分派给自己的任务，而不需要弄清通信对方在地球的哪个地方，通信过程的传输路线是怎样的，以及信息能否确保送达等问题。这些都是应用层以下其他层次需要考虑的问题，对应用层来说是透明的，直接调用结果就可以。</p>
<p><strong>TCP/IP协议族各层的作用如下：</strong></p>
<p>1.应用层</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;应用层决定了向用户提供应用服务时的通信的活动。比如，FTP(File Transfer Protocol,文件传输协议)和 DNS(Domain Name System,域名系统)。HTTP协议也位于应用层。</p>
<p>2.传输层</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。主要有两个性质不同的协议：TCP(Transmission Control Protocol,传输控制协议)和UDP(User Data Protocol,用户数据协议)。其中TCP协议提供可靠的数据传输，而UDP协议不提供可靠的数据传输。</p>
<p>3.网络层</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;网络层用来处理在网络上流动的数据包，该层规定了具体通过怎样的录像(所谓的传输路线)到达指定的计算机，并把数据包传送给对方。</p>
<p>4.数据链路层</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用来处理连接网络的硬件部分，硬件上的范畴均在数据链路层的作用范围之内。</p>
<p><strong>经典的TCP/IP通信传输过程：</strong></p>
<p><img src="../../../../img/http/2.png" alt=""></p>
<p>利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接受端则往应用层上走。</p>
<p>这里我们简单介绍了计算机网络协议体系，具体的TCP/IP协议族的内容可以参考《TCP/IP详解，卷1》。</p>
<h2 id="URI和URL的区别"><a href="#URI和URL的区别" class="headerlink" title="URI和URL的区别"></a>URI和URL的区别</h2><p>与URI(Uniform Resource Identifier,统一资源标识符)相比，我们其实更加熟悉URL(Uniform Resource Location,统一资源定位符)。URL正是使用的Web浏览器访问Web页面时需要输入的网页地址。比如，图中的<a href="https://lujunqiu.github.io" target="_blank" rel="external">https://lujunqiu.github.io</a>就是URL。</p>
<p><img src="../../../../img/http/3.png" alt=""></p>
<p>URI可以分为URL(uniform resource locator，统一资源定位器),URN(uniform resource name，统一资源命名)或同时具备locators 和names特性的一个东西。URN作用就好像一个人的名字，URL就像一个人的地址。换句话说：URN确定了东西的身份，URL提供了找到它的方式。</p>
<p>他们之间的关系：URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。如图所示，<br><img src="../../../../img/http/4.png" alt=""></p>
<h1 id="简单的http协议"><a href="#简单的http协议" class="headerlink" title="简单的http协议"></a>简单的http协议</h1><p>这里我们介绍的http协议是基于HTTP/1.1版本，可能与现行主流的版本不一致，但是大同小异。</p>
<p>http协议规定，请求从客服端发出，最后服务器端响应该请求并返回。换句话说，肯定是从客服端开始建立通信的，服务器端在没有接收到请求之前不会发送响应。<br><img src="../../../../img/http/5.png" alt=""></p>
<p>接下来，通过一个具体http通信示例来了解http协议。</p>
<p><img src="../../../../img/http/6.png" alt=""></p>
<p>客服端的发送的是请求报文，服务器端收到请求报文解析之后返回响应报文。</p>
<p>请求报文的起始行的GET表示请求访问服务器的类型，称为方法(method)。随后的HTTP/1.1，即HTTP的版本号，用来提示客服端使用的HTTP协议功能。最后的Host:hackr.jp表示客服端想要访问的服务器的域名。</p>
<p>响应报文的起始行的HTTP/1.1 表示服务器对应的HTTP版本。接着就是200 OK 表示请求的处理结果的状态码(status code)和原因短语，这个稍后会介绍。下一行显示了创建响应的时间，然后就是响应资源主体的长度以及响应内容的文本类型。</p>
<p>请求报文与响应报文各个字段功能介绍的过于繁琐，这里不再啰嗦拉，可以参考《HTTP权威指南》，绝对是经典中的经典。</p>
<h2 id="http是不保存状态的协议"><a href="#http是不保存状态的协议" class="headerlink" title="http是不保存状态的协议"></a>http是不保存状态的协议</h2><p>HTTP协议是一种不保存状态，即无状态(stateless)协议。HTTP协议自身不对请求和响应之间的通信状态进行保存，每当有新的请求发送时，就会有对应的新的响应产生。专业一点来说就是，在HTTP这个级别，协议对于发送过的请求或响应都不做持久化处理。不可否认，无状态协议有它的优点。由于不必保存状态，自然可减少服务器的CPU及内存资源的消耗。从另一个侧面来说，也正是因为HTTP协议本身是非常简答的，所以才会被应用在各种场景里。<br><img src="../../../../img/http/7.png" alt=""></p>
<p>这时候你可能要怀疑了，平时在浏览网页的时候，比如当你登录了淘宝，即使在你关闭浏览器一会之后再访问淘宝时，你的登录状态仍然正常，很明显这里保存了之前的登录状态啊。没错，HTTP协议的确是无状态协议，淘宝服务器的确保存了你的登录状态。这是如何做到的呢？答案就是Cookie技术，将Cookie技术与HTTP协议结合起来，就可以做到状态管理。</p>
<p>Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。Cookie会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。</p>
<p>服务器端发现客户端发送过来的Cookie厚，会去检查究竟是从哪个客户端发来的连接请求，然后对比服务器上的记录，最后就可以得到之前的状态信息。<br>如图所示：<br><img src="../../../../img/http/8.png" alt=""><br><img src="../../../../img/http/9.png" alt=""></p>
<h2 id="http的keep-alive方法"><a href="#http的keep-alive方法" class="headerlink" title="http的keep-alive方法"></a>http的keep-alive方法</h2><p>http的初始版本中，每进行一次http通信就要断开一次tcp连接。随着http的普及，在使用浏览器浏览一个包含多张图片的HTML网页时，在发送请求访问HTML网页资源的同时也会请求网页内包含的其他资源。因此，每次的请求都会造成无谓的tcp连接的建立和断开，增加通信量的开销。</p>
<p><img src="../../../../img/http/10.png" alt=""></p>
<p>在后续的HTTP版本中提出了持久连接的观点，也就是keep-alive方法，只要任意一端没有明确提出断开连接，则保持tcp连接状态。这样一来，减少了tcp连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载，提高了Web页面的访问速度。</p>
<h1 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h1><p>大家肯定遇到过在访问网页的时候返回一个404 not found。是的，每次看到这个东西就很生气。最后我们来看一看404这些状态码到底是什么意思。<br><img src="../../../../img/http/11.png" alt=""></p>
<p>状态码的职责是当客户端向服务器发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。</p>
<p>状态码的类别如图：</p>
<p><img src="../../../../img/http/12.png" alt=""></p>
<p>这里介绍几个常见的状态码：</p>
<ol>
<li>200 OK :表示从客户端发来的请求在服务器端被正常处理了；</li>
<li>301 Moved Permanently :永久性重定向，表示请求的资源已被分配了新的URI；</li>
<li>302 Found :临时性重定向，希望用户(本次)能使用新的URI访问；</li>
<li>403 Forbidden :表明对请求资源的访问被服务器拒绝了；</li>
<li>404 Not Found :表明服务器上无法找到请求的资源；</li>
<li>503 Service Unavailable :表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求；</li>
</ol>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>这篇文章只是简单的介绍了http协议，并没有深入。协议本身其实挺枯燥的，真是写者痛苦，看者难受。如果大家注意到了的话，近几年很多网站都在使用https协议，关于https协议我会在以后更新，说实话https协议的SSL握手过程还是有点意思的。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/计算机网络/">计算机网络</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/http协议/">http协议</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/03/22/蓄水池抽样/" title="蓄水池抽样" itemprop="url">蓄水池抽样</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lujunqiu" target="_blank" itemprop="author">Lujunqiu</a>
		
  <p class="article-time">
    <time datetime="2017-03-22T14:23:17.000Z" itemprop="datePublished"> Published 2017-03-22</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="等概率抽样"><a href="#等概率抽样" class="headerlink" title="等概率抽样"></a>等概率抽样</h2><p>在平时处理问题的时候，我们经常会遇到有关于概率问题的处理，比如我们在运用启发式算法的时候经常会加入一些随机因素来防止搜索解的过程在局部最优解无限循环。当然，遇到最多的还是抽样的问题，我们在处理海量数据集的时候，有时候是没有必要把所有数据拿来处理的，这时候我们就可以用抽样来用一部分数据集来代表整个海量数据。既然这样的话，我们就有必要保证抽样的过程是等概率的，否则抽样的结果就不正确了。</p>
<h2 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h2><p>这里，我们假设一种情况：从N个元素中随机的等概率的抽取k个元素，其中N是动态变化无法确定的，或者N很大无法将所有数据一次读入内存，只能用流的方式逐个读入数据。这样的话，我们是无法简单地用random函数来抽样的。</p>
<p>我们换一个比较准确的说法来描述我们要学习的蓄水池抽样问题：</p>
<p><em>“给出一个数据流，这个数据流的长度很大或者未知。并且对该数据流中数据只能访问一次。请写出一个随机选择算法，使得数据流中所有数据被选中的概率相等。”</em></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>问题：从N个元素中随机的等概率的抽取k个元素，N动态变化。（其中N个元素序号从1-N）</p>
<p>蓄水池取样算法的过程：首先，我们选择序号1-k的k个元素初始化容积为k的蓄水池。然后从序号k＋1开始的元素（这里假设该元素序号为x）我们对每个元素做如下处理：每个元素被选中进容积为k的蓄水池的概率为 k/x ，选中之后以1/k的概率在原蓄水池中抽取1个元素与之替换。这样我们就保证了蓄水池中的元素被选中的概率都是k／N了。</p>
<p>伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Init : a reservoir with the size： k  </div><div class="line">        <span class="keyword">for</span>    i= k+<span class="number">1</span> to N  </div><div class="line">            M=random(<span class="number">1</span>, i);  </div><div class="line">            <span class="keyword">if</span>( M &lt; k)  </div><div class="line">                 SWAP the Mth value and ith value  </div><div class="line">       end <span class="keyword">for</span></div></pre></td></tr></table></figure>
<h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><p>我们可以使用数学归纳法来证明其正确性，具体过程不再这里重复，但是需要我们注意的是，蓄水池中的元素不是固定不变的，在数据流的读取过程中池中的元素被选中的概率是会变的，也正是因为此我们才能保证N无法确定的情况时做到等概率抽样。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/算法/">算法</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/算法/">算法</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  


  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/JavaSE/" title="JavaSE">JavaSE<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/Linux/" title="Linux">Linux<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/一本正经/" title="一本正经">一本正经<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/工具/" title="工具">工具<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/算法/" title="算法">算法<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/计算机网络/" title="计算机网络">计算机网络<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/设计模式/" title="设计模式">设计模式<sup>3</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/学习笔记/" title="学习笔记">学习笔记<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/胡说八道/" title="胡说八道">胡说八道<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/算法/" title="算法">算法<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/http协议/" title="http协议">http协议<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/java8/" title="java8">java8<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/多线程/" title="多线程">多线程<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/模版方法模式/" title="模版方法模式">模版方法模式<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/https协议/" title="https协议">https协议<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/策略模式/" title="策略模式">策略模式<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/编程题/" title="编程题">编程题<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Maven/" title="Maven">Maven<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/设计模式原则/" title="设计模式原则">设计模式原则<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Linux/" title="Linux">Linux<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Shell/" title="Shell">Shell<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">Weibo</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=2831891302&verifier=a2b6ee82&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Lujunqiu.This is my blog. <br/>
			As Kobe said,Somebody has to win, so why not be me?</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/2831891302" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2017 
		
		<a href="/about" target="_blank" title="Lujunqiu">Lujunqiu</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
