
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>Qiu‘s homepage</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Lujunqiu">
    

    
    <meta property="og:type" content="website">
<meta property="og:title" content="Qiu‘s homepage">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Qiu‘s homepage">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Qiu‘s homepage">

    
    <link rel="alternative" href="/atom.xml" title="Qiu‘s homepage" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="Qiu‘s homepage" title="Qiu‘s homepage"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Qiu‘s homepage">Qiu‘s homepage</a></h1>
				<h2 class="blog-motto">大道唯有自成。</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/05/07/命令行的使用/" title="命令行的使用" itemprop="url">命令行的使用</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lujunqiu" target="_blank" itemprop="author">Lujunqiu</a>
		
  <p class="article-time">
    <time datetime="2017-05-07T13:44:18.000Z" itemprop="datePublished"> Published 2017-05-07</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一提到Linux,许多人都会说到“自由”,但我不认为他们都知道“自由”的真正涵义。“自由”是一种权力,它意味着你能决定你的计算机能做什么,同时能够拥有这种“自由”的唯一方式就是知道计算机正在做什么。这个时候，我们就需要命令行来帮助我们与计算机交互获得“自由”。所以人们常说，“图形用户界面让简单的任务更容易完成，而命令行界面使完成复杂的任务成为可能”，到现在这句话仍然很正确。接下来的正文有点像是在做笔记的形式，没有成文，写这篇博客的目的也是为了方便查阅。</p>
<h1 id="什么是Shell"><a href="#什么是Shell" class="headerlink" title="什么是Shell?"></a>什么是Shell?</h1><p>管理整个计算机硬件的是操作系统的内核(kernel),一般用户只能通过Shell命令行工具来跟内核通信。那么为什么叫Shell？因为Shell给用户提供一个与操作系统通信的接口，就如同鸡蛋的外壳一样。</p>
<p>几乎所有的Linux 发行版都提供一个名为bash的来自GNU项目的Shell程序。“bash”是“Bourne Again SHell”的首字母缩写，所指的是这样一个事实，bash是最初Unix 上由Steve Bourne 写成Shell 程序sh 的增强版。</p>
<h2 id="关于Shell的常用知识"><a href="#关于Shell的常用知识" class="headerlink" title="关于Shell的常用知识"></a>关于Shell的常用知识</h2><h3 id="终端提示符"><a href="#终端提示符" class="headerlink" title="终端提示符"></a>终端提示符</h3><p>在Shell的终端输入提示符的最后会有一个符号分别表示：</p>
<p>$:表示普通用户权限</p>
<p>#:表示root用于权限</p>
<h3 id="命令历史"><a href="#命令历史" class="headerlink" title="命令历史"></a>命令历史</h3><p>当我们想要查询之前使用过的的命令时候，可以使用history命令来查看历史，用法如下：</p>
<p>history [n]：查找最近的n条命令</p>
<p>history [-c]：将目前的shell中的所有history命令删除</p>
<p>history [-raw] 文件名：将目前的命令保持到文件中去</p>
<p>终端输入ctrl + r ：搜索历史命令。从当前命令行开始，向上递增搜索。<br>搜索到之后可以直接Enter执行，也可以ctrl + j　复制到终端界面。</p>
<p>!的使用：</p>
<p>! 数字：执行第几条命令</p>
<p>! 命令：由最近的命令向前搜索开头为“命令”的那个命令执行</p>
<p>!? 字符串: 重复最近历史中，包含这个字符串的命令。</p>
<p>!!:执行上一个命令</p>
<h3 id="Shell终端复制字符"><a href="#Shell终端复制字符" class="headerlink" title="Shell终端复制字符"></a>Shell终端复制字符</h3><p>按下鼠标左键，沿着文本拖动鼠标（或者双击一个单词）高亮了一些文本，那么这些高亮的文本就被拷贝到了一个缓冲区里面，然后按下鼠标中键，这些文本就被粘贴到光标所在的位置。</p>
<p>注意：不要在一个终端窗口里使用Ctrl-c和Ctrl-v快捷键来执行拷贝和粘贴操作。它们不起作用。对于Shell来说，这两个控制代码有着不同的含义。</p>
<h3 id="关于Shell中常用的路径"><a href="#关于Shell中常用的路径" class="headerlink" title="关于Shell中常用的路径"></a>关于Shell中常用的路径</h3><p>绝对路径：由根目录(/)开始写起的文件名或者目录名称。</p>
<p>相对路径：相对于目前路径的文件名写法。</p>
<p>. 代表当前的目录，也可以使用./ 表示；</p>
<p>.. 代表上一层目录，也可以使用 ../表示；</p>
<h3 id="万能的man"><a href="#万能的man" class="headerlink" title="万能的man"></a>万能的man</h3><p>命令的使用说明帮助：</p>
<p>man + 命令名称 </p>
<p>比如输入：qiu@qiu-empty:~$ man date</p>
<p>会得到date命令的manual（操作说明）；</p>
<p>查看的输出结果man page时候，可以用”/word“查找关键词，操作类似less，more等命令查阅文本； </p>
<h3 id="重要的热键"><a href="#重要的热键" class="headerlink" title="重要的热键"></a>重要的热键</h3><p>Tab：</p>
<p>命令补全，文件补齐：按一次Tab自动补全，按2次Tab显示所有匹配的命令或者文件。</p>
<p>Ctrl + c：</p>
<p>如果在Linux下输入了错误的命令，导致系统一直在运行，按 Ctrl + c 来中断目前执行的命令。</p>
<p>Ctrl + z：</p>
<p>将任务中止（暂停的意思）,但是此任务并没有结束,他仍然在进程中他只是维持挂起的状态,用户可以使用fg/bg操作继续前台或后台的任务,fg命令重新启动前台被中断的任务,bg命令把被中断的任务放在后台执行</p>
<p>Ctrl + d：</p>
<p>表示一个特殊的二进制值，表示 EOF（End Of File）</p>
<p>注：在shell中，ctrl-d表示推出当前shell。相当于输入exit；</p>
<p>Ctrl + U:将整行命令删除</p>
<p>Ctrl + S:暂停屏幕的输出</p>
<p>Ctrl + Q:恢复屏幕的输出</p>
<h1 id="什么是命令？"><a href="#什么是命令？" class="headerlink" title="什么是命令？"></a>什么是命令？</h1><p>命令可以是下面四种形式之一：</p>
<ol>
<li>是一个可执行程序，就像我们所看到的位于目录/usr/bin 中的文件一样。属于这一类的程序，可以编译成二进制文件，诸如用C 和C++ 语言写成的程序, 也可以是由脚本语言写成的程序，比如说shell，perl，python，ruby，等等。</li>
<li>是一个内建于shell 自身的命令。bash 支持若干命令，内部叫shell 内部命令(builtins)。例如，cd 命令，就是一个shell 内部命令。</li>
<li>是一个shell 函数。这些是小规模的shell 脚本，它们混合到环境变量中。在后续的章节<br>里，我们将讨论配置环境变量以及书写shell 函数。但是现在，仅仅意识到它们的存在就<br>可以了。</li>
<li>是一个命令别名。我们可以定义自己的命令，建立在其它命令之上。</li>
</ol>
<h2 id="如何识别命令"><a href="#如何识别命令" class="headerlink" title="如何识别命令"></a>如何识别命令</h2><p>type + 命令名 ：显示命令的类型</p>
<p>which + 命令名 ：显示一个可执行程序的位置</p>
<p>help + 命令名 ：得到shell 内部命令的帮助文档</p>
<p>–help ： 显示用法信息，许多可执行程序支持一个–help参数选项，这个选项是显示命令所支持的语法和选项说明。</p>
<p><em>man + 命令名 ：显示程序手册页，所有的命令都可以使用man来详细查询使用的方法！</em></p>
<p>info + 命令名 ：显示程序Info 条目</p>
<h2 id="使用别名（alias"><a href="#使用别名（alias" class="headerlink" title="使用别名（alias)"></a>使用别名（alias)</h2><p>在创建别名之前，我们可以使用type命令查询我们想要的别名是否存在。在命令行中定义的别名，当你的shell会话结束时，它们会消失。我们要学会把自己的别名添加到文件中去，每次我们登录系统，这些文件会建立系统环境。</p>
<h1 id="文件的操作"><a href="#文件的操作" class="headerlink" title="文件的操作"></a>文件的操作</h1><h2 id="必须要知道的"><a href="#必须要知道的" class="headerlink" title="必须要知道的"></a>必须要知道的</h2><p>Linux文件能不能被执行与文件后缀名无关，是由是否具有”x“这个权限来决定的。”x“权限表示该文件具有可执行权限；</p>
<p>更改文件或目录的模式(权限),可以利用 chmod 命令。注意只有文件的所有者或者超级用户才能更改文件或目录的模式。chmod命令支持两种不同的方法来改变文件模式:八进制数字表示法,或符号表示法。</p>
<p>sudo命令给普通用户以超级用户的权限。</p>
<p>文件名和命令名是大小写敏感的。</p>
<p>在linux中所以设备都是文件！</p>
<h2 id="操作文件的命令"><a href="#操作文件的命令" class="headerlink" title="操作文件的命令"></a>操作文件的命令</h2><h3 id="切换目录，Change-Directory"><a href="#切换目录，Change-Directory" class="headerlink" title="切换目录，Change Directory"></a>切换目录，Change Directory</h3><p>关于cd 命令的快捷键：<br>cd           更改工作目录到你的家目录。</p>
<p>cd -        更改工作目录到先前的工作目录。</p>
<p>cd ..        去上一层目录</p>
<h3 id="显示当前目录"><a href="#显示当前目录" class="headerlink" title="显示当前目录"></a>显示当前目录</h3><p>pwd：显示当前目录，Print Working Directory</p>
<h3 id="创建新目录"><a href="#创建新目录" class="headerlink" title="创建新目录"></a>创建新目录</h3><p>mkdir：新建新目录，make directory</p>
<p>比如：qiu@qiu-empty:~$ mkdir [-mp] 目录名称</p>
<p>-m：配置文件的权限</p>
<p>-p：递归的创建文件</p>
<p>比如你要创建/test/test1/test2这个文件，你首先要先创建test以及test1，用-p参数可以直接递归的一次性全部创建完成。</p>
<h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><p>ls：查看文件与目录</p>
<p>-a：以 “.” 字符开头的文件名是隐藏文件。这仅表示，ls 命令不能列出它们， 用 ls -a 命令就可以了。</p>
<p>-d：仅列出目录本身，而不是列出目录内的文件数据</p>
<p>-l：列出长数据，包含文件的属性与权限等等</p>
<h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>cp(copy):复制文件或目录:</p>
<p>cp [-adfilprsu] source destination</p>
<p>-r:递归持续复制，用于目录的复制行为,目录属性可能会发生变化，想要使得复制之后的目录和原目录完全一样，可以使用cp -a </p>
<p>-s:复制成为符号链接文件，即”快捷方式”文件；</p>
<p>-i:若destination文件已经存在，在覆盖的时候会询问；</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>rm(remove):移除文件或目录</p>
<p>rm [-fir] filename</p>
<p>-f:force,强制执行；</p>
<p>-i:互动模式,Interaction,在操作前会询问；</p>
<p>-r:递归的删除,谨慎使用；</p>
<p>小贴士： 无论什么时候，rm 命令用到通配符（除了仔细检查输入的内容外！）， 用 ls 命令来测试通配符。这会让你看到要删除的文件列表。然后按下上箭头按键，重新调用刚刚执行的命令，用 rm 替换 ls。</p>
<h3 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h3><p>mv(move):移动文件或目录，或更名</p>
<p>mv [-fiu] source destination</p>
<h3 id="内容查阅"><a href="#内容查阅" class="headerlink" title="内容查阅"></a>内容查阅</h3><p>文件内容查阅：</p>
<p>cat：由第一行开始显示文件内容</p>
<p>tac：cat的倒写，由最后一行开始显示文件内容</p>
<p>nl：显示的时候，顺便输出行号</p>
<p>more：一页一页地显示文件内容</p>
<p>less：与more类似，但是可以往前翻页</p>
<p>head：只看头几行</p>
<p>tail：只看结尾几行</p>
<p>od：以二进制的方式读取文件内容</p>
<p><em>less查看的操作类似man：</em></p>
<p>space：向下翻页</p>
<p>b : 向上翻页</p>
<p>PageDown：向下翻页</p>
<p>PageUp：向上翻页</p>
<p>/字符串：向下查询字符串</p>
<p>?字符串：向上查询字符串</p>
<p>q：离开</p>
<h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><p>touch命令：</p>
<p>touch [-acdmt] filename</p>
<p>创建一个空的文件；也可以用于修改文件的日期；</p>
<p>关于文件的日期：mtime（modification time，内容修改日期），ctime（status time，状态修改日期），atime（access time，读取日期）</p>
<h3 id="文件的查询"><a href="#文件的查询" class="headerlink" title="文件的查询"></a>文件的查询</h3><p>查看文件类型：file命令</p>
<p>先用whereis，locate来检查（速度快一点），最后找不到了才用find(查找文件的复杂方式)来查询；locate只能依据文件名来查找文件，而find程序能基于各种各样的属性， 搜索一个给定目录（以及它的子目录），来查找文件。</p>
<p>locate命令：</p>
<p>locate [-ir] keyword</p>
<p>-i:忽略大小写</p>
<p>-r:后面可接正则表达式的显示方式</p>
<p>locate与whereis是经由数据库来查找的，当你新建文件后查找该文件有可能会找不到，需要用updatedb命令来手动更新数据库。</p>
<h3 id="压缩与解压文件"><a href="#压缩与解压文件" class="headerlink" title="压缩与解压文件"></a>压缩与解压文件</h3><p>tar -zcv -f filename.tar.gz 要被压缩的文件</p>
<p>tar -jcv -f filename.tar.bz2 要被压缩的文件</p>
<p>tar -zxv -f filename.tar.gz -C 欲解压缩的目录</p>
<p>tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录</p>
<h3 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h3><p>关于符号链接：（类似windows系统中的快捷方式）</p>
<p>在大多数“类 Unix” 系统中，有可能一个文件被多个文件名所指向，叫做符号链接（也称为软链接或者 symlink）。有利于文件的共享的操作，在文件名改动之后不需要修改其他程序。一个符号链接指向一个文件，而且这个符号链接本身与其它的符号链接几乎没有区别。例如，如果你往一个符号链接里面写入东西，那么相关联的文件也被写入。然而，当你删除一个符号链接时，只有这个链接被删除，而不是文件自身。如果先于符号链接删除文件，这个链接仍然存在，但是不指向任何东西。在这种情况下，这个链接被称为坏链接。</p>
<h1 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h1><p>“I/O” 代表输入/输出，通过I/O重定向，你可以重定向命令的输入输出，命令的输入来自文件，而输出也存到文件。也可以把多个命令连接起来组成一个强大的命令管道。</p>
<p>数据流的重定向：将某个命令执行后应该要出现在屏幕上的数据传输到其他的地方去，例如文件或者设备。</p>
<p>管道命令：</p>
<p>使用 | 界定符号，与连续执行命令不一样；</p>
<p>比如我们想知道/etc下文件，输入 ls -a /etc 导致一口气屏幕被塞满，这时我们可以用less命令来协助查看:</p>
<p>ls -a /etc | less</p>
<p>表示这个管道命令 | 仅能处理经由前面一个命令传来的正确的信息，也就是standard output，在管道后面接的第一个数据一定是命令，而且这个命令必须要能接受standard output，例如：（查看）less，more，head，tail，（选取）cut，grep，（排序）sort，wc，uniq，（双重定向）tee，等等</p>
<h1 id="Shell中的命令"><a href="#Shell中的命令" class="headerlink" title="Shell中的命令"></a>Shell中的命令</h1><p>echo ： 显示一行文本</p>
<p>花括号展开：你可以从一个包含花括号的模式中创建多个文本字符串。</p>
<p>花括号展开模式可能包含一个开头部分叫做报头，一个结尾部分叫做附言。花括号表达式本身可能包含一个由逗号分开的字符串列表，或者一系列整数，或者单个的字符串。这种模式不能嵌入空白字符。</p>
<p>例如：</p>
<p>echo Front-{A,B,C}-Back</p>
<p>输出：Front-A-Back Front-B-Back Front-C-Back</p>
<p>echo Number_{1..5}</p>
<p>输出：Number_1 Number_2 Number_3 Number_4 Number_5</p>
<p>echo {Z..A}</p>
<p>输出:Z Y X W V U T S R Q P O N M L K J I H G F E D C B A</p>
<h2 id="Shell中的变量："><a href="#Shell中的变量：" class="headerlink" title="Shell中的变量："></a>Shell中的变量：</h2><p>变量的定义：一组文字或者符号等，来替代一些设置或者一串保留的数据；</p>
<p>变量的显示：echo $变量名</p>
<p>比如：echo $PATH</p>
<p>取消变量的设置：unset 变量名</p>
<p>将变量设置为环境变量，提供子进场执行：export 变量名</p>
<p>?变量：上一个执行的命令所传回的值，一般来说，如果成功执行命令，则会回传一个0值。所以我们可以通过echo $？ 查看上一个命令是否成功执行；</p>
<p>双引号的作用：</p>
<p>如果你把文本放在双引号中，Shell使用的特殊字符，除了$，\ (反斜杠），和‘（倒引号）之外，则失去它们的特殊含义，被当作普通字符来看待。这意味着单词分割，路径名展开，波浪线展开，和花括号展开都被禁止，然而参数展开，算术展开，和命令替换仍然执行。使用双引号，我们可以处理包含空格的文件名。</p>
<p>比方说：我们是two words.txt文件的受害者。如果我们试图在命令行中使用这个文件，单词分割机制会导致这个文件名被看作两个独自的参数，而不是所期望的单个参数：</p>
<p>ls -l two words.txt</p>
<p>ls: cannot access two: No such file or directory</p>
<p>ls: cannot access words.txt: No such file or directory</p>
<p>使用双引号，我们可以阻止单词分割，得到期望的结果；进一步，我们甚至可以修复破损的文件名。</p>
<p>ls -l “two words.txt”</p>
<p>-rw-rw-r– 1 me me 18 2008-02-20 13:03 two words.txt</p>
<p>记住，在双引号中，参数展开，算术表达式展开，和命令替换仍然有效：</p>
<p>echo “$USER $((2+2)) $(cal)”</p>
<p>me 4 February 2008</p>
<p>Su Mo Tu We Th Fr Sa</p>
<p>….</p>
<p>转义字符的使用：</p>
<p>有时候我们只想引用单个字符。我们可以在字符之前加上一个反斜杠，在这个上下文中叫做转义字符。经常在双引号中使用转义字符，来有选择地阻止展开。</p>
<p>比如:（转义美元符$）</p>
<p>echo “The balance for user $USER is: \$5.00”</p>
<p>The balance for user me is: $5.00</p>
<p>还有一个场景：</p>
<p>命令的执行是从上到下，从左到右的，与命令的执行一样，只识别一个空白格，多个空白格会被忽略掉。如果读到Enter符号(CR)，就尝试执行该行的命令，但是可以使用\Enter来转义扩展到下一行输入。</p>
<h2 id="关于键盘的使用技巧"><a href="#关于键盘的使用技巧" class="headerlink" title="关于键盘的使用技巧"></a>关于键盘的使用技巧</h2><p>ctrl + a ：移动光标到行首</p>
<p>ctrl + e ：移动光标到行末</p>
<p>ctrl + d : 删除光标位置的字符</p>
<p>ctrl + u ：剪贴从光标到行首的文本</p>
<p>ctrl + k : 剪贴从光标到行尾的文本</p>
<p>ctrl + y : 把剪贴的文本复制粘贴到光标位置 </p>
<h1 id="软件包的管理"><a href="#软件包的管理" class="headerlink" title="软件包的管理"></a>软件包的管理</h1><p>一般而言，大多数发行版分别属于两大包管理技术阵营：Debian的”.deb”，和红帽的”.rpm”，他们分别对应的系统如下。</p>
<p>Debian Style (.deb)：Debian, Ubuntu, Xandros, Linspire</p>
<p>Red Hat Style (.rpm)：Fedora, CentOS, Red Hat Enterprise Linux, OpenSUSE, Mandriva, PCLinuxOS</p>
<p>软件包管理系统通常由两种工具类型组成：底层工具用来处理这些任务，比方说安装和删除软件包文件，和上层工具，完成元数据搜索和依赖解析。虽然所有基于 Red Hat风格的发行版都依赖于相同的底层程序（rpm）,但是它们却使用不同的上层工具。</p>
<p>如下所示：</p>
<p>Debian-Style：dpkg（底层工具）；apt-get, aptitude（上层工具）；</p>
<p>Fedora, Red Hat Enterprise Linux,CentOS：rpm（底层工具）；yum（上层工具）；</p>
<h2 id="如何操作软件包？"><a href="#如何操作软件包？" class="headerlink" title="如何操作软件包？"></a>如何操作软件包？</h2><p>1.从资源库中安装一个软件包：<br>上层工具允许从一个资源库中下载一个软件包，并经过完全依赖解析来安装它。</p>
<p>Debian：apt-get update; apt-get install package_name</p>
<p>Red Hat：yum install package_name</p>
<p>2.通过软件包文件来安装软件：<br>如果从某处而不是从资源库中下载了一个软件包文件，可以使用底层工具来直接（没有经过依赖解析）安装它。</p>
<p>Debian：dpkg –install package_file</p>
<p>Red Hat：rpm -i package_file</p>
<p>3.卸载软件：<br>可以使用上层或者底层工具来卸载软件。下面是可用的上层工具。</p>
<p>Debian：apt-get remove package_name</p>
<p>Red Hat：yum erase package_name</p>
<p>4.经过资源库来更新软件包：</p>
<p>Debian：apt-get update; apt-get upgrade</p>
<p>Red Hat：yum update</p>
<p>5.列出所安装的软件包：</p>
<p>Debian：dpkg –list</p>
<p>Red Hat：rpm -qa</p>
<p>6.确定是否安装了一个软件包：</p>
<p>Debian：dpkg –status package_name</p>
<p>Red Hat：rpm -q package_name</p>
<h1 id="关于Shell脚本"><a href="#关于Shell脚本" class="headerlink" title="关于Shell脚本"></a>关于Shell脚本</h1><h2 id="什么是Shell脚本"><a href="#什么是Shell脚本" class="headerlink" title="什么是Shell脚本"></a>什么是Shell脚本</h2><p>一个 Shell 脚本就是一个包含一系列命令的文件。Shell读取这个文件，然后执行 文件中的所有命令，就好像这些命令已经直接被输入到了命令行中一样。</p>
<h2 id="如何编写Shell脚本"><a href="#如何编写Shell脚本" class="headerlink" title="如何编写Shell脚本"></a>如何编写Shell脚本</h2><p>Shell脚本就是普通的文本文件。所以我们需要一个文本编辑器来书写它们。最好的文本编辑器都会支持语法高亮，这样我们就能够看到一个脚本关键字的彩色编码视图。语法高亮会帮助我们查看某种常见错误。</p>
<p>使脚本文件可执行。系统会相当挑剔不允许任何旧的文本文件被看作是一个程序，并且有充分的理由!所以我们需要设置脚本文件的权限来允许其可执行。<br>对于脚本文件，有两个常见的权限设置；权限为755的脚本，则每个人都能执行，和权限为700的脚本，只有文件所有者能够执行。注意为了能够执行脚本，脚本必须是可读的。</p>
<p>把脚本放置到 shell能够找到的地方.当没有指定可执行文件明确的路径名时，shell 会自动地搜索某些目录，来查找此可执行文件。为了最大程度的方便，我们会把脚本放到这些目录当中。</p>
<h2 id="脚本文件的位置"><a href="#脚本文件的位置" class="headerlink" title="脚本文件的位置"></a>脚本文件的位置</h2><p>我们知道，如果没有给出可执行程序的明确路径名，那么系统每次都会搜索一系列的目录，来查找此可执行程序。这个/bin目录就是其中一个系统会自动搜索的目录。 这个目录列表被存储在一个名为PATH的环境变量中。这个PATH变量包含一个由冒号分隔开的目录列表。</p>
<p>这里，如果我们要修改PATH变量添加目录的话，通过修改我们的.bashrc 文件，当做了这个修改之后，它会在每个新的终端会话中生效。为了把这个修改应用到当前的终端会话中， 我们必须让 shell 重新读取这个 .bashrc 文件。这可以通过 “sourcing”.bashrc 文件来完成。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Linux/">Linux</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Linux/">Linux</a><a href="/tags/Shell/">Shell</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/04/24/Https/" title="HTTPS" itemprop="url">HTTPS</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lujunqiu" target="_blank" itemprop="author">Lujunqiu</a>
		
  <p class="article-time">
    <time datetime="2017-04-24T11:51:07.000Z" itemprop="datePublished"> Published 2017-04-24</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们在享受互联网给我们带来的便利的同时也承受了互联网带来的伤害，比如上网的时候经常会遇到密码被盗，信息泄露等令人郁闷的事情。其中有一个原因为：互联网早期绝大部分网站使用的是<a href="http://lujunqiu.github.io/2017/04/08/http/" target="_blank" rel="external">HTTP协议</a>，我们在http协议下输入的任何信息都是不加密的。简单来说，这些密码以及个人隐私信息全都一字一句在网络传输中“裸奔”。</p>
<p>虽然http协议本身简单而且方便使用，但也存在一些安全性上不足，比如：</p>
<ul>
<li>通信使用明文（不加密），内容很可能被窃听 </li>
<li>不验证通信双方的身份，通信对象很可能被伪装</li>
<li>无法证明报文的完整性，通信内容很可能被修改</li>
</ul>
<p>其实这类问题，不仅仅会出现在http协议中，所有本身不涉及加密的协议都存在这些安全性的不足。</p>
<p>所谓互联网，是由能连通到全世界的网络组成的。无论哪个地方的服务器与客户端通信时，在通信线路上会经过很多网络设备，你无法保证这些设备的安全性，这些“坏蜀黍”就很有可能会泄露或者攥改你的通信内容，甚至伪装起来，而且你根本无法辨别。</p>
<p>但是不要慌，你可以发现我们现在浏览的大部分网页都是https开头的，也就是说它们已经升级为了https协议了。https到底是什么玩意呢？</p>
<h2 id="什么是HTTPS协议呢？"><a href="#什么是HTTPS协议呢？" class="headerlink" title="什么是HTTPS协议呢？"></a>什么是HTTPS协议呢？</h2><p>HTTPS（HTTP Secure）并非是一种新的协议，简单来说，https就是给http加了一个“安全套”，即使别人拿到了信息，也不知道里面到底是个什么。这个外加的“安全套”叫做SSL（Secure Socket Layer），所谓的HTTPS，其实也就是身披SSL协议这层外壳的HTTP罢了。</p>
<p><img src="../../../../img/https/1.png" alt=""></p>
<p>而且，SSL是独立HTTP的协议，采用了SSL之后，HTTP就拥有了加密，证书和完整性保护这些功能了。</p>
<p><img src="../../../../img/https/2.png" alt=""></p>
<h2 id="两种加密方式"><a href="#两种加密方式" class="headerlink" title="两种加密方式"></a>两种加密方式</h2><p>在讲SSL之前，先简单了解一下加密的知识。总体来说，加密分为2大类，对称密钥加密，非对称密钥加密。</p>
<p>加密和解密同用一个密钥的方式称为共享密钥加密（Common key crypto system），也就是我们所说的对称加密。</p>
<p>举个例子，客户想发送“12345”给服务器，又不想明文发送，于是他就用了一个简单的加密算法，不直接发送“12345”转而发送“do re mi fa so”给服务器。服务器一看，由于事先已经和客户商量好了，知道了客户是用音符加密，于是就同样的原理解密“do re mi fa so”得到“12345”。这个过程就是对称密钥加密，当然在实际运用过程中，加密解密算法肯定不会这么简单的。</p>
<p>这里有一个bug，我们如何将对称的密钥安全地传递给通信方呢？假设我使用了一种对称加密算法加密了通信报文，同时我希望将解密的密钥给对方，否则对方就无法解密报文。但是从现在来看我们没有办法保证把密钥传递给对方的通信的安全性。我们在互联网上转发密钥时，如果通信被监听那么密钥就会泄露，同时也就失去了加密的意义。</p>
<p>在上面的例子来看，客户端和服务器要事先商量好对称密钥，也就是使用音符来加密，但如果这个商量的过程是无法加密的，有可能被坏人监听泄露，那么后续的加密也就没有作用了。</p>
<p><img src="../../../../img/https/3.png" alt=""></p>
<p>那么，如果解决上面的问题呢？</p>
<p>答案就是使用两把密钥的公开密钥加密。</p>
<p>公开密钥加密使用一对非对称的密钥。一把叫做私有密钥，另一把叫做公开密钥。顾名思义，私有密钥不能让其他人知道，而公开密钥则可以随意发布。具体非对称密钥是如何操作的呢？</p>
<p>再举个例子，假设A想B发送一个报文，使用非对称密钥加密。那么，A首先去B的主页（qq空间朋友圈或者微博啥的）找到B发布的公开密钥，然后用B发布的公开密钥加密将要发送的报文信息。B在得到了使用自己的公开密钥加密的报文后，使用B的的私有密钥来解密报文就可以得到原文了。</p>
<p>这种加密和解密使用不同的密钥的方式就是非对称加密，利用这种方式，不需要发送用来解密的私有密钥，也就不必担心密钥被其他坏人窃听。</p>
<h2 id="HTTPS的安全通信机制"><a href="#HTTPS的安全通信机制" class="headerlink" title="HTTPS的安全通信机制"></a>HTTPS的安全通信机制</h2><p>HTTPS使用的是两种加密并用的混合加密机制。你可能会有个疑问，为什么不只使用非对称加密呢？相比于对称加密，非对称加密处理速度要慢很多，对于网络这种实时性要求高的应用，非对称加密的速度还是不够。</p>
<p>我们知道，对称加密方法（共享密钥加密）速度快，而且简单易行，但就是在交换共享密钥的时候无法保证其安全性。那么，我们可以在交换共享密钥的时候使用非对称加密（公开密钥加密）来保证交换过程的安全性，之后建立通信阶段则使用对称加密方式（共享密钥加密），如图所示。</p>
<p><img src="../../../../img/https/4.png" alt=""></p>
<p>很遗憾，上述机制仍然不完善，因为我们无法证明公开密钥本身的正确性。比如，我们正准备和某主机服务器通信，我们无法证明得到的公开密钥就是原本预想的那台服务器发行的公开密钥。因为有可能在公开密钥的传输过程中，真正的公开密钥已经被坏人篡改替换掉了，或者你访问的根本就是一台别人伪装的服务器。</p>
<p>这就涉及到在互联网上如何识别一个主机的身份的问题了。在现实生活中，如果有个人说自己是华科的某系的老师，你会怎么判断呢？很简单，我们找到这个系你信任的或者大家都信任的老师或者同学来问一问，如果他们说是，那你也就相信了。说白了，就是找一个公认靠谱的人来验证其他人靠不靠谱。在互联网中，也是这个逻辑，数字证书认证机构（CA，Certificate Authority）就是来解决这个工作的。</p>
<p>数字证书认证机构处于客户端与服务器双方都信赖的第三方机构的立场。具体如何运作的呢？首先，服务器的运营人员向数字证书认证机构提出认证申请。数字证书认证机构在判明了申请者的身份后，会给申请者的公开密钥（与申请者通信要使用的加密密钥）做数字签名，然后将数字签名以及公开密钥做成公钥证书发给申请者。</p>
<p>服务器得到公钥证书后，当有客户想要和服务器通信的时候，服务器将公钥证书发给客户。得到公钥证书的客户可以向数字证书认证机构确认证书上数字签名的正确性，从而可以确认服务器的真实身份。</p>
<h3 id="SSL通信过程"><a href="#SSL通信过程" class="headerlink" title="SSL通信过程"></a>SSL通信过程</h3><p><img src="../../../../img/https/5.png" alt=""><br><img src="../../../../img/https/6.png" alt=""></p>
<p>步骤1:首先由客户发起通信请求，通过发送Client Hello报文给服务器打个招呼，开始SSL通信。</p>
<p>步骤2:服务器收到了Client Hello后，出于礼貌也必须要回复Server Hello（大家都不高冷）。</p>
<p>步骤3:双方互相打完招呼后，服务器发送Certificate报文，其中包含我们之前讲的公开密钥证书。</p>
<p>步骤4:最后服务器发送Server Hello Done报文，告知客户端这次SSL握手协商顺利结束。</p>
<p>步骤5:握手协商阶段结束后，客户端发送Client Key Exchange报文，使用步骤3的公开密钥加密一种被称为pre－master secret的随机密码串。</p>
<p>步骤6:客户端继续发送Change Cipher Spec报文，提示服务器在后续的HTTP通信中使用pre－master secret密钥加密。</p>
<p>步骤7:客户端发送Finished报文。该报文包含对上述报文的整体校验值，用于服务器来判断是否协商成功的标准。</p>
<p>步骤8:服务器同样发送Change Cipher Spec报文。</p>
<p>步骤9:服务器发送Finished报文。</p>
<p>步骤10，11:服务器与客户端交换Finished报文之后，SSl安全通信建立完成。现在就可以开始HTTP通信了。</p>
<p>步骤12:最后通信结束，由客户端断开连接。</p>
<p>这里解释一下pre－master secret报文的含义：</p>
<p>我们只知道客户端生成随机数据，并且把这个随机数据用服务端发送过来的的公共密钥加密，此次加密过程产生本次握手中的pre－master secret，然后将它送回给服务端。</p>
<p>Server验证完client的身份之后，然后用自己的私有密钥解密得到Pre－master secret然后双方利用这个pre－master secret来共同协商，得到master secret。</p>
<p>双方用master secret一起产生真正的session key，这将是一个对称加密的key。这个key还可以用来验证数据完整性。双方再交换结束信息。握手结束。接下来双方就可以用协商好的算法和密钥key，采用对称加密算法来通信了。</p>
<h3 id="HTTPS协议的效率问题"><a href="#HTTPS协议的效率问题" class="headerlink" title="HTTPS协议的效率问题"></a>HTTPS协议的效率问题</h3><p>既然HTTPS相比于HTTP协议是安全可靠的协议，那为什么所有的网站不一直使用HTTPS呢？</p>
<p>这里就涉及到HTTPS的效率问题了，因为与纯文本通信相比，加密通信会消耗更多的CPU及内存资源。如果每次通信都加密，则会加大网络的负载，同时消耗更多服务器和客户端的硬件资源。</p>
<p>于是，如果是非敏感的信息我们可以考虑使用HTTP通信，只有在包含个人信息等敏感数据时，才使用HTTPS加密通信。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>我们到此简单介绍了HTTPS协议的由来以及SSL握手的过程，如果想要深入了解协议的细节（有点枯燥）可以参考《HTTPS权威指南》。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/计算机网络/">计算机网络</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/https协议/">https协议</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/04/08/http/" title="HTTP" itemprop="url">HTTP</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lujunqiu" target="_blank" itemprop="author">Lujunqiu</a>
		
  <p class="article-time">
    <time datetime="2017-04-08T09:31:54.000Z" itemprop="datePublished"> Published 2017-04-08</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前在学习javaEE相关的javaWeb技术的时候，发现自己对HTTP协议的了解太缺乏了，导致看起书来“香菇，难受”，于是花了一点时间学习了HTTP协议，当时也没有很详细去了解细节。现在过了几个星期，是时候写篇博客复习一下了。</p>
<h1 id="什么是http？"><a href="#什么是http？" class="headerlink" title="什么是http？"></a>什么是http？</h1><p>&nbsp;&nbsp;可以这么说，只要是上过网的人都接触过http协议。我们每天都会通过浏览器（Web browser）来访问网页的信息，过程再熟悉不过了：首先在浏览器地址栏输入URL(Uniform Resource Identifier)，也就是我们常说的网址，如果访问的网址是正确的且允许访问的，那么我们就可以得到网页信息了。<br><img src="../../../../img/http/1.png" alt=""></p>
<p>如图中所示的过程，客户端(Web browser)与所要访问的互联网资源(resource)所在的服务器(Server)是使用http协议来交换信息的。那么，什么是通信协议呢？打个比方，在中国人与人之间的“通信协议”是中文，在那些English speaking countries的人们则是用英文交流。中文与英文就好比是不同地区人们的“通信协议”。同样的道理，在互联网上每天都有大量的数据信息在交换，通信协议的重要性不言而喻。我们介绍的Http协议正是Web服务器与Web客服端之间的顶层通信协议之一，也是我们作为互联网使用者最常见的协议。</p>
<blockquote>
<p><em>HTTP:HyperText Transfer Protocol , 超文本传输协议</em></p>
</blockquote>
<p>什么是超文本?简单的说,超文本是一种可以链接到任何其他信息的文本。我们知道，网页本质来说就是一种超文本(HTML,HyperText Markup Language)，浏览器的作用就是解析并且渲染来自服务器端传来的HTML页面，最后呈现给我们看。顾名思义，http协议正是这个传输过程的关键所在。</p>
<h1 id="计算机网络协议体系"><a href="#计算机网络协议体系" class="headerlink" title="计算机网络协议体系"></a>计算机网络协议体系</h1><p>计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标，由哪一边先发起通信，使用哪种语言进行通信，怎样结束通信等规则都需要事先确定。不同的硬件，操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议(protocol)。</p>
<p>在介绍http协议之前，先要了解一下整个互联网的协议体系。我们通常使用的网络(包括互联网)是在TCP/IP协议族的基础上运行的，而http协议只是属于它内部的一个子集。</p>
<p>整个网络通信过程需要制定规则的内容太多了， 从电缆的规格到IP地址的选定方法，寻找异地用户的方法，双方建立通信的顺序，以及Web页面显示需要处理的步骤，等等。如果互联网只是由一个协议统筹，某个地方需要改变设计的时候，就必须把所遇部分整体替换掉。显然，这种设计很愚蠢。</p>
<p>TCP/IP协议族采用分层管理，通常按层次分别为以下4层：应用层，传输层，网络层和数据链路层。如果我们能把各层之间的接口部分规划合理，每个层次内部的设计就封装独立起来了。层次化之后，设计也变得相对简单了。比如，处于应用层上的协议可以只考虑分派给自己的任务，而不需要弄清通信对方在地球的哪个地方，通信过程的传输路线是怎样的，以及信息能否确保送达等问题。这些都是应用层以下其他层次需要考虑的问题，对应用层来说是透明的，直接调用结果就可以。</p>
<p><strong>TCP/IP协议族各层的作用如下：</strong></p>
<p>1.应用层</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;应用层决定了向用户提供应用服务时的通信的活动。比如，FTP(File Transfer Protocol,文件传输协议)和 DNS(Domain Name System,域名系统)。HTTP协议也位于应用层。</p>
<p>2.传输层</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。主要有两个性质不同的协议：TCP(Transmission Control Protocol,传输控制协议)和UDP(User Data Protocol,用户数据协议)。其中TCP协议提供可靠的数据传输，而UDP协议不提供可靠的数据传输。</p>
<p>3.网络层</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;网络层用来处理在网络上流动的数据包，该层规定了具体通过怎样的录像(所谓的传输路线)到达指定的计算机，并把数据包传送给对方。</p>
<p>4.数据链路层</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用来处理连接网络的硬件部分，硬件上的范畴均在数据链路层的作用范围之内。</p>
<p><strong>经典的TCP/IP通信传输过程：</strong></p>
<p><img src="../../../../img/http/2.png" alt=""></p>
<p>利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接受端则往应用层上走。</p>
<p>这里我们简单介绍了计算机网络协议体系，具体的TCP/IP协议族的内容可以参考《TCP/IP详解，卷1》。</p>
<h2 id="URI和URL的区别"><a href="#URI和URL的区别" class="headerlink" title="URI和URL的区别"></a>URI和URL的区别</h2><p>与URI(Uniform Resource Identifier,统一资源标识符)相比，我们其实更加熟悉URL(Uniform Resource Location,统一资源定位符)。URL正是使用的Web浏览器访问Web页面时需要输入的网页地址。比如，图中的<a href="https://lujunqiu.github.io" target="_blank" rel="external">https://lujunqiu.github.io</a>就是URL。</p>
<p><img src="../../../../img/http/3.png" alt=""></p>
<p>URI可以分为URL(uniform resource locator，统一资源定位器),URN(uniform resource name，统一资源命名)或同时具备locators 和names特性的一个东西。URN作用就好像一个人的名字，URL就像一个人的地址。换句话说：URN确定了东西的身份，URL提供了找到它的方式。</p>
<p>他们之间的关系：URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。如图所示，<br><img src="../../../../img/http/4.png" alt=""></p>
<h1 id="简单的http协议"><a href="#简单的http协议" class="headerlink" title="简单的http协议"></a>简单的http协议</h1><p>这里我们介绍的http协议是基于HTTP/1.1版本，可能与现行主流的版本不一致，但是大同小异。</p>
<p>http协议规定，请求从客服端发出，最后服务器端响应该请求并返回。换句话说，肯定是从客服端开始建立通信的，服务器端在没有接收到请求之前不会发送响应。<br><img src="../../../../img/http/5.png" alt=""></p>
<p>接下来，通过一个具体http通信示例来了解http协议。</p>
<p><img src="../../../../img/http/6.png" alt=""></p>
<p>客服端的发送的是请求报文，服务器端收到请求报文解析之后返回响应报文。</p>
<p>请求报文的起始行的GET表示请求访问服务器的类型，称为方法(method)。随后的HTTP/1.1，即HTTP的版本号，用来提示客服端使用的HTTP协议功能。最后的Host:hackr.jp表示客服端想要访问的服务器的域名。</p>
<p>响应报文的起始行的HTTP/1.1 表示服务器对应的HTTP版本。接着就是200 OK 表示请求的处理结果的状态码(status code)和原因短语，这个稍后会介绍。下一行显示了创建响应的时间，然后就是响应资源主体的长度以及响应内容的文本类型。</p>
<p>请求报文与响应报文各个字段功能介绍的过于繁琐，这里不再啰嗦拉，可以参考《HTTP权威指南》，绝对是经典中的经典。</p>
<h2 id="http是不保存状态的协议"><a href="#http是不保存状态的协议" class="headerlink" title="http是不保存状态的协议"></a>http是不保存状态的协议</h2><p>HTTP协议是一种不保存状态，即无状态(stateless)协议。HTTP协议自身不对请求和响应之间的通信状态进行保存，每当有新的请求发送时，就会有对应的新的响应产生。专业一点来说就是，在HTTP这个级别，协议对于发送过的请求或响应都不做持久化处理。不可否认，无状态协议有它的优点。由于不必保存状态，自然可减少服务器的CPU及内存资源的消耗。从另一个侧面来说，也正是因为HTTP协议本身是非常简答的，所以才会被应用在各种场景里。<br><img src="../../../../img/http/7.png" alt=""></p>
<p>这时候你可能要怀疑了，平时在浏览网页的时候，比如当你登录了淘宝，即使在你关闭浏览器一会之后再访问淘宝时，你的登录状态仍然正常，很明显这里保存了之前的登录状态啊。没错，HTTP协议的确是无状态协议，淘宝服务器的确保存了你的登录状态。这是如何做到的呢？答案就是Cookie技术，将Cookie技术与HTTP协议结合起来，就可以做到状态管理。</p>
<p>Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。Cookie会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去。</p>
<p>服务器端发现客户端发送过来的Cookie厚，会去检查究竟是从哪个客户端发来的连接请求，然后对比服务器上的记录，最后就可以得到之前的状态信息。<br>如图所示：<br><img src="../../../../img/http/8.png" alt=""><br><img src="../../../../img/http/9.png" alt=""></p>
<h2 id="http的keep-alive方法"><a href="#http的keep-alive方法" class="headerlink" title="http的keep-alive方法"></a>http的keep-alive方法</h2><p>http的初始版本中，每进行一次http通信就要断开一次tcp连接。随着http的普及，在使用浏览器浏览一个包含多张图片的HTML网页时，在发送请求访问HTML网页资源的同时也会请求网页内包含的其他资源。因此，每次的请求都会造成无谓的tcp连接的建立和断开，增加通信量的开销。</p>
<p><img src="../../../../img/http/10.png" alt=""></p>
<p>在后续的HTTP版本中提出了持久连接的观点，也就是keep-alive方法，只要任意一端没有明确提出断开连接，则保持tcp连接状态。这样一来，减少了tcp连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载，提高了Web页面的访问速度。</p>
<h1 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h1><p>大家肯定遇到过在访问网页的时候返回一个404 not found。是的，每次看到这个东西就很生气。最后我们来看一看404这些状态码到底是什么意思。<br><img src="../../../../img/http/11.png" alt=""></p>
<p>状态码的职责是当客户端向服务器发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。</p>
<p>状态码的类别如图：</p>
<p><img src="../../../../img/http/12.png" alt=""></p>
<p>这里介绍几个常见的状态码：</p>
<ol>
<li>200 OK :表示从客户端发来的请求在服务器端被正常处理了；</li>
<li>301 Moved Permanently :永久性重定向，表示请求的资源已被分配了新的URI；</li>
<li>302 Found :临时性重定向，希望用户(本次)能使用新的URI访问；</li>
<li>403 Forbidden :表明对请求资源的访问被服务器拒绝了；</li>
<li>404 Not Found :表明服务器上无法找到请求的资源；</li>
<li>503 Service Unavailable :表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求；</li>
</ol>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>这篇文章只是简单的介绍了http协议，并没有深入。协议本身其实挺枯燥的，真是写者痛苦，看者难受。如果大家注意到了的话，近几年很多网站都在使用https协议，关于https协议我会在以后更新，说实话https协议的SSL握手过程还是有点意思的。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/计算机网络/">计算机网络</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/http协议/">http协议</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/03/22/蓄水池抽样/" title="蓄水池抽样" itemprop="url">蓄水池抽样</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lujunqiu" target="_blank" itemprop="author">Lujunqiu</a>
		
  <p class="article-time">
    <time datetime="2017-03-22T14:23:17.000Z" itemprop="datePublished"> Published 2017-03-22</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="等概率抽样"><a href="#等概率抽样" class="headerlink" title="等概率抽样"></a>等概率抽样</h2><p>在平时处理问题的时候，我们经常会遇到有关于概率问题的处理，比如我们在运用启发式算法的时候经常会加入一些随机因素来防止搜索解的过程在局部最优解无限循环。当然，遇到最多的还是抽样的问题，我们在处理海量数据集的时候，有时候是没有必要把所有数据拿来处理的，这时候我们就可以用抽样来用一部分数据集来代表整个海量数据。既然这样的话，我们就有必要保证抽样的过程是等概率的，否则抽样的结果就不正确了。</p>
<h2 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h2><p>这里，我们假设一种情况：从N个元素中随机的等概率的抽取k个元素，其中N是动态变化无法确定的，或者N很大无法将所有数据一次读入内存，只能用流的方式逐个读入数据。这样的话，我们是无法简单地用random函数来抽样的。</p>
<p>我们换一个比较准确的说法来描述我们要学习的蓄水池抽样问题：</p>
<p><em>“给出一个数据流，这个数据流的长度很大或者未知。并且对该数据流中数据只能访问一次。请写出一个随机选择算法，使得数据流中所有数据被选中的概率相等。”</em></p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>问题：从N个元素中随机的等概率的抽取k个元素，N动态变化。（其中N个元素序号从1-N）</p>
<p>蓄水池取样算法的过程：首先，我们选择序号1-k的k个元素初始化容积为k的蓄水池。然后从序号k＋1开始的元素（这里假设该元素序号为x）我们对每个元素做如下处理：每个元素被选中进容积为k的蓄水池的概率为 k/x ，选中之后以1/k的概率在原蓄水池中抽取1个元素与之替换。这样我们就保证了蓄水池中的元素被选中的概率都是k／N了。</p>
<p>伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Init : a reservoir with the size： k  </div><div class="line">        <span class="keyword">for</span>    i= k+<span class="number">1</span> to N  </div><div class="line">            M=random(<span class="number">1</span>, i);  </div><div class="line">            <span class="keyword">if</span>( M &lt; k)  </div><div class="line">                 SWAP the Mth value and ith value  </div><div class="line">       end <span class="keyword">for</span></div></pre></td></tr></table></figure>
<h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><p>我们可以使用数学归纳法来证明其正确性，具体过程不再这里重复，但是需要我们注意的是，蓄水池中的元素不是固定不变的，在数据流的读取过程中池中的元素被选中的概率是会变的，也正是因为此我们才能保证N无法确定的情况时做到等概率抽样。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/算法/">算法</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/算法/">算法</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/03/13/lambda/" title="lambda" itemprop="url">lambda</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lujunqiu" target="_blank" itemprop="author">Lujunqiu</a>
		
  <p class="article-time">
    <time datetime="2017-03-13T15:22:22.000Z" itemprop="datePublished"> Published 2017-03-13</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>函数式编程：没有共享的可变数据 + 将方法和函数（代码）作为一等值来传递</p>
<p>行为参数化：一个方法接收多个不同的行为作为参数，并在内部使用它们，完成不同行为的能力</p>
<p>名词解释：</p>
<ul>
<li><p>predicate（谓词）：函数以及方法引用。</p>
</li>
<li><p>lambda表达式：匿名函数</p>
</li>
</ul>
<p>java8主要的新特性：</p>
<ul>
<li>lambda表达式</li>
<li>方法引用</li>
<li>流（Collections用来存储和访问数据 ；Stream描述对数据的计算，用来并行的处理数据）</li>
<li>默认方法（扩展接口）</li>
</ul>
<h2 id="通过行为参数传递代码"><a href="#通过行为参数传递代码" class="headerlink" title="通过行为参数传递代码"></a>通过行为参数传递代码</h2><p>将行为参数化是可以帮助我们处理频繁变更的需求的一种软件开发模式，它能够轻松的适应不断变化的需要，可以把一个行为(一段代码)封装起来，并通过传递和使用创建的行为(创建实现谓词的接口的类的实例)将方法的行为参数化。</p>
<p>在java8之前，我们会定义一个接口(谓词)来将行为参数化。然后我们创建不同的实现类继承该接口来实现不同的行为，最后将不同实现类的实例对象传递给对应的函数就完成了行为(代码)传递工作。这种做法就类似于在内联”传递代码”，将需要传递的代码包裹在一个实现了接口的类里面传递给调用的方法。</p>
<p>同时为了改善代码，让它更加简洁，我们面对很多只要实例化一次的类，可以采用匿名类来同时声明和实例化一个类，也就是说匿名类允许我们随建随用。</p>
<p>但是使用匿名类还是不够好，代码不易读，我们还是需要创建一个对象，明确地实现一个方法来定义一个新的行为。为了更加契合软件工程中DPY原则(Don’t Repeat Yourself)，java8引人了lambda表达式（匿名函数）！</p>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>Lambda表达式：匿名的方法，可以作为参数传递或者存储在变量中</p>
<p>Lambda表达式语法结构：</p>
<ul>
<li>(parameters) -&gt; expression</li>
<li>(parameters) -&gt; {statements;}</li>
</ul>
<p>parameters是参数列表，后续是Lambda表达式的主体，主体内如果是表达式则不需要花括号和分号，如果是语句的化则需要花括号与分号。注意区分。</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Comparator&lt;Apple&gt; byWeight = <span class="keyword">new</span> Comparator&lt;Apple&gt;() &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Apple o1, Apple o2)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> o1.getWeight().compareTo(o2.getWeight());</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>我们使用Lambda表达式(直接赋值给变量)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Comparator&lt;Apple&gt; byWeight = (Apple a1,Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight());</div></pre></td></tr></table></figure>
<h2 id="在哪可以使用Lambda表达式"><a href="#在哪可以使用Lambda表达式" class="headerlink" title="在哪可以使用Lambda表达式"></a>在哪可以使用Lambda表达式</h2><p>函数式接口：只定义了一个抽象方法的接口；</p>
<p>在定义函数式接口时我们为该接口添加了@FunctionalInterface注解，用于标记该接口是函数式接口，不过这个接口是可选的，当添加了该接口之后，编译器就限制了该接口只允许有一个抽象方法，否则报错，所以推荐为函数式接口添加该注解。</p>
<p>Lambda表达式允许我们直接以内联的形式为函数式接口的抽象方法提供实现，并把整个表达式作为函数式接口的实例。(具体来说，是函数式接口的一个具体实现的实例)当然，我们使用匿名类同样可以完成这个操作，只不过是比较笨拙。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Runnable r1 = () -&gt; System.out.println(<span class="string">"Hello World 1"</span>) ;</div><div class="line">Runnable r2 = <span class="keyword">new</span> Runnable()&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"Hello World 2"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Runnable r)</span></span>&#123;</div><div class="line">    r.run();</div><div class="line">&#125;</div><div class="line">process(r1); <span class="comment">//打印Hello World1</span></div><div class="line">process(r2);<span class="comment">//打印Hello World 2</span></div><div class="line">process(() -&gt; System.out.println(<span class="string">"Hello World 3"</span>));<span class="comment">//打印Hello World3</span></div></pre></td></tr></table></figure>
<p>函数描述符：函数式接口的抽象方法的签名基本上就是Lambda表达式的签名，这种抽象方法叫作函数描述符。</p>
<p>JavaApi中常用的函数式接口(只列举了一部分，最终以java官方的javadoc为主)：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Evaluates this predicate on the given argument.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> t the input argument</div><div class="line">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the input argument matches the predicate,</div><div class="line">     * otherwise &#123;<span class="doctag">@code</span> false&#125;</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Performs this operation on the given argument.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> t the input argument</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Applies this function to the given argument.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> t the function argument</div><div class="line">     * <span class="doctag">@return</span> the function result</div><div class="line">     */</div><div class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BiFunction</span>&lt;<span class="title">T</span>, <span class="title">U</span>, <span class="title">R</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Applies this function to the given arguments.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> t the first function argument</div><div class="line">     * <span class="doctag">@param</span> u the second function argument</div><div class="line">     * <span class="doctag">@return</span> the function result</div><div class="line">     */</div><div class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t, U u)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Gets a result.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span> a result</div><div class="line">     */</div><div class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们知道java的类型，要不是引用类型，要不是原始数据类型(int,double等等)。但是由于历史原因，泛型只能绑定到引用类型。为了使用原始类型的数据，java引人了自动装箱和自动拆箱的优化，但是装箱和拆箱的过程是对性能有损失的。</p>
<p>于是，java8为了避免在使用函数式接口的时候发生装箱和拆箱的操作，专门定义了原始数据类型的接口，叫作原始类型的特化版本。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">pubic interface <span class="title">IntPredicate</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> t)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="关于Lambda表达式使用局部变量："><a href="#关于Lambda表达式使用局部变量：" class="headerlink" title="关于Lambda表达式使用局部变量："></a>关于Lambda表达式使用局部变量：</h4><p>Lambda表达式可以无限制的捕获(在其主体中引用)实例变量和静态变量，但是局部变量必须显式声明为final或事实上是final的。因为实例变量存储在堆中，局部变量保存在栈上，Lambda表达式在另一个线程里面执行，当线程试图访问该局部变量的时候，变量存在着被修改和收回的可能，所以用final修饰就不会存在线程安全的问题了。</p>
<h2 id="简单介绍方法引用"><a href="#简单介绍方法引用" class="headerlink" title="简单介绍方法引用"></a>简单介绍方法引用</h2><p>方法引用可以重复使用现有的方法定义，并像Lambda一样传递。方法引用相当于仅仅涉及单一方法的Lambda表达式的语法糖，是一种快捷的写法。</p>
<p>方法引用实例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJ8MethodReference</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// static method</span></div><div class="line">        Function&lt;Integer, Integer&gt; f1 = TestJ8MethodReference::add;</div><div class="line">        System.out.println(f1.apply(<span class="number">1</span>));</div><div class="line">        <span class="comment">// instance method</span></div><div class="line">        Function&lt;String, String&gt; f2 = String::trim;</div><div class="line">        System.out.println(f2.apply(<span class="string">"   abd b"</span>));</div><div class="line">        TestJ8MethodReference testJ8MethodReference = <span class="keyword">new</span> TestJ8MethodReference();</div><div class="line">        Function&lt;Integer, String&gt; f3 = testJ8MethodReference::getStr;</div><div class="line">        System.out.println(f3.apply(<span class="number">3</span>));</div><div class="line">        <span class="comment">// super</span></div><div class="line">        testJ8MethodReference.testSuper();</div><div class="line"></div><div class="line">        <span class="comment">// explicit type arguments for generic type</span></div><div class="line">        testJ8MethodReference.testExplicitType();</div><div class="line"></div><div class="line">        <span class="comment">// implicit type arguments for generic type</span></div><div class="line">        testJ8MethodReference.testImplicitType();</div><div class="line"></div><div class="line">        <span class="comment">// new</span></div><div class="line">        Supplier s1 = TestJ8MethodReference::<span class="keyword">new</span>;</div><div class="line">        System.out.println(s1.get());</div><div class="line"></div><div class="line">        <span class="comment">// type arguments inferred from context</span></div><div class="line">        Consumer&lt;<span class="keyword">int</span>[]&gt; c1 = Arrays::sort;</div><div class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</div><div class="line">        c1.accept(array);</div><div class="line"></div><div class="line">        <span class="comment">// explicit type arguments</span></div><div class="line">        Consumer&lt;<span class="keyword">int</span>[]&gt; c2 = Arrays::&lt;<span class="keyword">int</span>[]&gt;sort;<span class="comment">//泛型方法的运用:在方法名前面加泛型信息</span></div><div class="line">        c2.accept(array);</div><div class="line"></div><div class="line">        <span class="comment">// new array</span></div><div class="line">        Function&lt;Integer, <span class="keyword">int</span>[]&gt; f4 = (<span class="keyword">int</span>[]::<span class="keyword">new</span>);</div><div class="line">        <span class="keyword">int</span>[] a = f4.apply(<span class="number">10</span>);</div><div class="line">        System.out.println(a.length);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> x + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStr</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">""</span> + x;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSuper</span><span class="params">()</span> </span>&#123;</div><div class="line">        Supplier&lt;String&gt; f = <span class="keyword">super</span>::toString;</div><div class="line">        System.out.println(f.get());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExplicitType</span><span class="params">()</span> </span>&#123;</div><div class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        Function&lt;String, Boolean&gt; func = list::add;</div><div class="line">        System.out.println(func.apply(<span class="string">"a"</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testImplicitType</span><span class="params">()</span> </span>&#123;</div><div class="line">        List list = <span class="keyword">new</span> ArrayList();</div><div class="line">        Function&lt;String, Boolean&gt; func = list::add;</div><div class="line">        System.out.println(func.apply(<span class="string">"a"</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="复合Lambda表达式的有用方法"><a href="#复合Lambda表达式的有用方法" class="headerlink" title="复合Lambda表达式的有用方法"></a>复合Lambda表达式的有用方法</h2><ul>
<li><p>比较器复合：比较器链或者逆序。参考Comparator的Api</p>
</li>
<li><p>谓词复合：negate，and，or。可以重用已有的Predicate来创建新的谓词。negate表示一个Predicate的非；and用于把2个Lambda组合起来；or表示2个Lambda的或逻辑。</p>
</li>
<li><p>函数复合：把Function接口所代表的Lambda表达式复合。有andThen和compose2个默认方法。具体区别参考javadoc文档。</p>
</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaSE/">JavaSE</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/学习笔记/">学习笔记</a><a href="/tags/java8/">java8</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/03/12/i/" title="有意思的推理" itemprop="url">有意思的推理</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lujunqiu" target="_blank" itemprop="author">Lujunqiu</a>
		
  <p class="article-time">
    <time datetime="2017-03-11T16:03:05.000Z" itemprop="datePublished"> Published 2017-03-12</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>今天在网上看到了一道推理题，挺有意思的。题目如下：</p>
<p>P先生、Q先生都具有足够的推理能力。这天，他们正在接受推理面试。 他们知道桌子的抽屉里有如下16张扑克牌: 红桃 A、Q、4 ；黑桃 J、8、4、2、7、3 ；草花 K、Q、5、4、6 ；方块 A、5 </p>
<p>约翰教授从这16张牌中挑出一张牌来，并把这张牌的点数告诉P先生，把这张牌 的花色告诉Q先生。这时，约翰教授问P先生和Q先生:你们能从已知的点数或花色中推知这张牌是什么牌吗?</p>
<p>P先生:”我不知道这张牌。” Q先生:”我知道你不知道这张牌。” P先生:”现在我知道这张牌了。” Q先生:”我也知道了。” 请问:这张牌是什么牌? </p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>简单地翻译一下题目意思，总共有3个人玩一个游戏(我们处于吃瓜群众的视角来观察每个人的举动，推理结果)，其中一个人上帝视角知道答案并且告诉了P先生牌的点数，同时还告诉了Q先生牌的花色。Ps：所有人都知道所有16张牌的花色与点数的，最后的结果就是这16张牌的某一张。</p>
<p>首先P先生说话了，“我不知道这张牌。” P先生是知道牌的点数的，那么这句话的意思就是：P先生知道的点数是无法确定花色，那么这个点数对应的花色至少有2个。 我们观察所有的16张牌，符合上述条件的牌的点数只有： A，5，Q，4</p>
<p>Q先生说：”我知道你不知道这张牌。” 这个时候，Q先生已知的有用的信息只有牌的花色。那么，Q先生这句话的表明：在Q先生的视角，Q先生可以确定P先生在只知道牌的点数的情况下是无法知道这张牌的花色的。意思就是说，Q先生知道的牌的花色中每一张牌的点数都至少与其他牌重复一次。那么，我们在回头看看所有的16张牌，符合条件的只有红桃与方块。这里，我们知道了牌的花色是：红桃或者方块</p>
<p>P先生在分析了2句对话的信息后，说：”现在我知道这张牌了。” 很简单，P先生分析了Q先生上句话的意思，知道牌的花色不是红桃就是方块，然后再看看已知的点数，就可以确定了是哪张牌了。 这个时候，作为吃瓜群众的我们，是无法得知结果的。但是，我们可以确定牌的点数不是A，因为A在红桃，方块里面都存在，只有可能是 Q，4，5中的某一张。</p>
<p>然后，Q先生说：”我也知道了。”这个时候，在Q先生的视角，牌的点数只有可能是 Q，4，5中的某一张，不可能是A。然后Q先生得知了这个信息后，找到了牌的点数。作为吃瓜群众的我们只能认为，Q先生知道的牌的花色为方块，因为只有方块只有2个点数，排除了A。那么就只剩下5了。</p>
<p>最后，吃瓜群众也知道了结果：方块5.</p>
<p><em>之前本科考试数据结构的时候，就有一个海盗分赃的问题，也是类似的推理，但是比这个脑洞稍微大一点点，有兴趣可以google</em></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/一本正经/">一本正经</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/胡说八道/">胡说八道</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/03/09/Optional/" title="Optional" itemprop="url">Optional</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lujunqiu" target="_blank" itemprop="author">Lujunqiu</a>
		
  <p class="article-time">
    <time datetime="2017-03-09T14:57:47.000Z" itemprop="datePublished"> Published 2017-03-09</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="Null-带来的问题："><a href="#Null-带来的问题：" class="headerlink" title="Null 带来的问题："></a>Null 带来的问题：</h2><ul>
<li>它是错误之源<br> NullPointerException是目前java程序开发中最典型的异常</li>
<li>它会使代码膨胀<br> 它让你的代码充斥着深度嵌套的null检查，代码的可读性差</li>
<li>它自身没有任何的语义<br> 尤其是，它代表了在静态类型语言中一种错误的方式对缺失的变量值的建模</li>
</ul>
<h2 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h2><p>java8中引人了一个新的类java.util.Optional&lt; T &gt;。<br>代码示例 1：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</div><div class="line"><span class="keyword">private</span> Optional &lt; Car &gt; car;</div><div class="line"><span class="keyword">public</span> Optional&lt; Car&gt; getCar()&#123;<span class="keyword">return</span> car;&#125; </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</div><div class="line"><span class="keyword">private</span> Optional&lt; Insurance&gt; insurance;</div><div class="line"><span class="keyword">public</span> Optional&lt; Insurance&gt; getInsurance()&#123;<span class="keyword">return</span> insurance;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">pubic <span class="class"><span class="keyword">class</span> <span class="title">Insurance</span></span>&#123;</div><div class="line"><span class="keyword">private</span> String name;</div><div class="line"><span class="function">pulic String <span class="title">getName</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> name;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当变量存在的时候，Optional类只是对类的简单封装。变量不存在的时候，缺失的值会被建模成为一个”空”的Optional对象，该对象可以由方法Optional.empty()返回，同时解引用这个Optional类的有效的”空”对象是完全不会出事的。</p>
<p>上述的代码示例中:</p>
<ul>
<li>Person类表示某个人（实例）可能有车，也可能没车，因此将这个字段声明为Optional,表明Person是允许缺失的，通过Optional为缺失null安全建模；</li>
<li>Car类表示某台车可能买了保险，也有可能没有买保险；</li>
<li>Insurance类中，每个保险是肯定有名字的，所以无须声明为Optional；</li>
</ul>
<h2 id="使用Optional"><a href="#使用Optional" class="headerlink" title="使用Optional"></a>使用Optional</h2><ol>
<li><p>创建一个Optional对象</p>
<p>声明一个空的Optional：通过静态工厂方法Optional.empty()，创建一个空的Optional对象；<br>Optional<car> optCar = Optional.empty();<br>或者，使用静态工厂方法Optional.ofNullable，创建一个允许null值得Optional对象<br>Optional<car> optCar = Optional.ofNullable(car);</car></car></p>
</li>
<li>利用map，flatmap从Optional对象中提取值<br>参考java8中java.util.Optional函数Api可以得知map，flatmap的用法以及区别。借助上述的代码示例1，比较map方法与flatmap方法的用法。<br><code>Optional&lt;Insurance&gt; optInsurance =     Optional.ofNullable(insurance);</code><br><code>Optional&lt;String&gt; name = optInsurance.map(Insurance :: getName);</code><br>这里的map用方法和流中的map用法几乎一致，map操作会将提供的函数应用于流的每个元素，这里我们将Optional对象看作一种特殊的集合，至少包含一个元素。如果Optional包含一个值，那函数就将改值作为参数传递给map，最后对将得到的值用Optional类包装。如果Optional为空，那就什么都不做。<br>但是注意以下代码：<br> <code>Optional&lt;Person&gt; optPerson = Optional.of(person);</code><br>这里optPerson是Optional<person>类型的变量，调用map方法没有问题，但是其中包含的Person.getCar返回的是一个Optional<car>类型的对象，导致<code>optPerson.map(Person :: getCar);</code>的结果是返回一个Optional<optional<car>&gt;类型的变量。这个时候我们需要用到flatmap方法，可以将多层Optional包裹的值合并为一个Optional返回函数结果。</optional<car></car></person></li>
</ol>
<p><strong>注意：Optional类并没有实现Serializable接口</strong></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaSE/">JavaSE</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/学习笔记/">学习笔记</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/03/09/一道阿里招聘的编程题/" title="阿里实习生招聘的编程题" itemprop="url">阿里实习生招聘的编程题</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lujunqiu" target="_blank" itemprop="author">Lujunqiu</a>
		
  <p class="article-time">
    <time datetime="2017-03-08T16:33:32.000Z" itemprop="datePublished"> Published 2017-03-09</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>2017年阿里巴巴实习生在线测试编程题：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;对于一个长度为 N 的整型数组A，数组里所有的数都是正整数，对于两个满足0 &lt;= X &lt;= Y &lt; N 的整数，A[X],A[X+1]…A[Y]构成A的一个切片，记作(X,Y)。 用三个下标m1,m2,m3下标满足 0&lt;m1 ,m1 + 1 &lt; m2,m2 + 1 &lt; m3 &lt; N - 1。可以把这个整型数组分成(0,m1 - 1),(m1 + 1,m2),(m2 + 1,m3),(m3,N-1)四个切片。如果这个四个切片中的整数求和相等，称作“四等分”。编写一个函数，求一个给定的整形数组是否可以四等分，如果可以，返回一个布尔类型的true，如果不可以返回一个布尔类型的false。</p>
<p>  限制条件：数组A最多有1,000,000项，数组中整数的取值范围介于 -1,000,000到1,000,000之间。</p>
<p>  要求：函数计算的复杂度为O(n)，使用的额外存储空间(除了输入的数组之外)最多为O(n)。</p>
<p> 例子：</p>
<p>  对于数组A=[2,5,1,1,1,1,4,1,7,3,7]存在下标2,7,9使得数组分成4个分片[2,5],[1,1,1,4],[7],[7]，这3个分片内整数之和相等，所以对于这个数组，函数应该返回true</p>
<p>  对于数组A=[10,2,11,13,1,1,1,1,1]，找不到能把数组四等分的下标，所以函数应该返回false</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>题目要求的时间复杂度是O(n),额外的空间复杂度也是O(n).根据题目的描述，将一个数组四等分的3个切分点是不参与求和的，所以具体四等分结果的累加和我们是一开始无法确定的。但是，当我们确定了第一个切分点的时候，每个等分的累加和就确定了。也正是由于累加和的不确定性，我们无法运用动态规划来设计子问题，不满足后无效性。</p>
<p>由于一开始并不知道每个等分的累加和具体是多少，我们必须假设数组的每一个点都可能成为第一个切分点。这时就需要遍历一边数组，时间复杂度为O(n)，确定了累加和之后，要做的事情就是查找了，在后续的数组里查找累加和相等的切片。但是我们需要完成常数复杂度的查找操作，很自然要用到hashmap。设计hashmap的key为累加和，value为数组索引（数组下标0到该索引的所有元素的累加和），额外的空间复杂度为O(n).</p>
<p>这样一来，算法的大致思路就完成了。首先遍历数组，确定第一个切分点以及对应的每等分累加和，然后搜索hashmap在后续的数组中能否查找到相等的累加和切片。</p>
<p><em>注意：</em> </p>
<ul>
<li>这个算法只适用于数组元素是正整数的情况，如果有负数的话，累加和会有相同的情况，存入hashmap的时候需要处理冲突。</li>
<li>要写出来bugfree的代码，需要考虑到边界条件，避免数组越界访问的异常。</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://github.com/lujunqiu/Demo/blob/master/src/datastructure/Alibaba_OnlineTest.java" target="_blank" rel="external">代码链接</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/算法/">算法</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/编程题/">编程题</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/03/08/关于null/" title="关于java中的Null" itemprop="url">关于java中的Null</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lujunqiu" target="_blank" itemprop="author">Lujunqiu</a>
		
  <p class="article-time">
    <time datetime="2017-03-08T14:07:57.000Z" itemprop="datePublished"> Published 2017-03-08</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="关键字Null"><a href="#关键字Null" class="headerlink" title="关键字Null"></a>关键字Null</h2><p>Java中，Null是一个很有“意思”的关键字，设计之初用来标识一个不确定的对象或者一个缺失的对象。同时Null作为java中的关键字，如同public，static等等是大小写敏感的。但是Null说到底还是一个值，可以赋给任何引用变量但是不能将Null赋值给java的8种基本数据类型变量。如果在定义了变量类型之后，没有给变量赋值初始化，那么Null关键字是所有引用类型变量的默认初始值。在JVM的视线内，值为Null的引用变量是不会再被任何对象引用了，该变量将会被垃圾回收，从而释放内存。</p>
<h2 id="a-billion-dollar-mistake"><a href="#a-billion-dollar-mistake" class="headerlink" title="a billion-dollar mistake"></a>a billion-dollar mistake</h2><p>java语言的设计者曾经说过Null关键字的使用是billion-dollar mistake，为什么这么说？如果我们只是用Null作为一个值来传递是不会有任何问题的。可是一旦通过值为Null的引用变量来访问其引用对象(解引用操作)就会出问题，也就是我们时常会在写代码的时候遇到的空指针异常(java.lang.NullPointerException)<br>在编程的时候如果对Null不在意，甚至随意使用Null，后果是非常严重的。</p>
<h2 id="NullPointerException"><a href="#NullPointerException" class="headerlink" title="NullPointerException"></a>NullPointerException</h2><p>参考RednaxelaFX在知乎上的关于<a href="https://www.zhihu.com/question/47997295" target="_blank" rel="external">return Null是否安全的回答</a></p>
<p>在java中，对Null引用变量解引用就会抛出NPE异常。哪些操作包含了解引用呢？</p>
<ul><li>读字段（字节码 getfield）：x.y，当x为null时抛NPE；</li><li>写字段（字节码 putfield）：x.y = z，当x为null时抛NPE。注意：z的值是什么没关系；</li><li>读数组长度（字节码 arraylength）：a.length，当a为null时抛NPE；</li><li>读数组元素（字节码 &lt;x&gt;aload，&lt;x&gt;为类型前缀）：a[i]，当a为null时抛NPE；</li><li>写数组元素（字节码 &lt;x&gt;astore，&lt;x&gt;为类型前缀）：a[i] = x，当a为null时抛NPE。注意：x的值时什么没关系；</li><li>调用成员方法（字节码 invokevirtual、invokeinterface、invokespecial）：obj.foo(x, y, z)，当obj为null时抛NPE。注意：参数的值是什么没关系；</li><li>增强for循环（也叫foreach循环）：</li><ul><li>对数组时（实际隐含a.length操作）：for (E e : a) { … } ， 当a为null时抛NPE；</li><li>对Iterable时（实际隐含对Iterable.iterator()的调用）：for (E e : es) { … } ，当es为null时抛NPE；</li></ul><li>自动拆箱（实际隐含 &lt;XXX&gt;.&lt;xxx&gt;Value() 的调用，&lt;XXX&gt;为包装类型名，&lt;xxx&gt;为对应的原始类型名）： (int) integerObj，当integerObj为null时抛NPE；</li><li>对String做switch（实际隐含的操作包含对String.hashCode()的调用）：switch (s) { case “abc”: … } ，当s为null时抛NPE；</li><li>创建内部类对象实例（字节码 new，但这里特指创建内部类实例的情况）：outer.new Inner(x, y, z)，当outer为null时抛NPE；</li><li>抛异常（字节码 athrow）：throw obj，当obj（throw表达式的参数）为null时抛NPE；</li><li>用synchronized关键字给对象加锁（字节码 monitorenter / monitorexit）：synchronized (obj) { … }，当obj为null时抛NPE。</li></ul>

<h2 id="Avoid-Nulls"><a href="#Avoid-Nulls" class="headerlink" title="Avoid Nulls"></a>Avoid Nulls</h2><p>尽量避免使用空值。不要返回 Null 的集合，可以选择返回一个 empty 的集合。</p>
<p>如果你确实准备使用 Null，可以考虑使用 @Nullable注解。IntelliJ IDEA 内置支持 @Nullable 注解。</p>
<p>注解@Nullable和@NotNull的作用：用来标注方法是否能传入null值，如果可以传入Null值，则标记为Nullbale，如果不可以则标注为NotNull. 在我们做了一些不安全严谨的编码操作的时候,这些注释会给我们一些警告。</p>
<p>如果使用了Java 8，推荐优秀的 Optional 类型来包裹Null引用。<br>使用 Optional 唯一不好的是标准库对 Optional 的支持并不是很好，所以对 null 的处理仍然是必要的。</p>
<p><a href="https://lujunqiu.github.io/2017/03/09/Optional/" target="_blank" rel="external">关于Optional的介绍</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JavaSE/">JavaSE</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/学习笔记/">学习笔记</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/03/07/随便说点啥吧/" title="随便说点啥吧" itemprop="url">随便说点啥吧</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Lujunqiu" target="_blank" itemprop="author">Lujunqiu</a>
		
  <p class="article-time">
    <time datetime="2017-03-07T01:02:03.000Z" itemprop="datePublished"> Published 2017-03-07</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="关于博客"><a href="#关于博客" class="headerlink" title="关于博客"></a>关于博客</h1><p>&#160;&#160;&#160;&#160;其实在2016年本科毕业决定继续在华中科技大学读研究生的时候，我就想过要开始写博客。有几方面原因吧，写博客可以记录下平时学习过程中的笔记啥的，其次还可以当作日记来用。在我最初的认知里面，写博客应该是件文艺青年爱干的事（btw,现在写博客的大部分是程序员？文艺青年都去写朋友圈软文了？）。说不定多写写东西，可以让我看起来文艺一点，或许还能帮我追女生. </p>
<p>&#160;&#160;&#160;&#160;说了这么多，为什么过了半年才开始写？这个说来话长，原因各种各样，搭建博客的环境配置,etc…诶，其实就是懒。但是我并不是啥也没干，我选择了一种比较轻松的方法来做这件事情。我已经用有道云笔记来记录学习笔记很久了（我还是比较推荐印象笔记，有道云的多终端仓库同步时不时会宕机）。其实写笔记和写博客还是有很大区别的，写笔记是给自己看的，写的时候就很随意，自己懂了就ctrl ＋ c &amp;&amp; ctrl ＋ v。写博客说到底还是写给别人看的。一篇技术文档，自己看懂和看懂之后能写下来让别人也看懂还是有区别的，在工作的时候这种交际能力算是必备的。说到工作，最近这几天实验室的学长都在找实习，我就在一边吃瓜围观。我发现一个长期坚持写的不错的博客就是一份简历，用比较功利的话说就是坚持写有意义的博客是会在找工作的时候加分的（传说中的集齐BAT offer召唤神龙）。</p>
<h2 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h2><p>&#160;&#160;&#160;&#160;既然选择了开始做这件事情，我还是希望自己能坚持下来，养成一个习惯确实没那么简单。我想了想，有道云笔记还是要用的，毕竟方便啊，知乎和微博里面的文章一键collet，晚上我会选择比较有意思的那部分整理到博客里来。还有我之前很多在有道云里面的笔记，找个假期回头看看也可以整理一下。</p>
<p>&#160;&#160;&#160;&#160;第一次写markdown文档，排版很low，也没有什么图文并茂。现在要做的应该是把博客的外观弄起来看着舒服一点，毕竟这是一劳永逸的工作。</p>
<h2 id="mac-os搭建博客教程（hexo-amp-amp-github）"><a href="#mac-os搭建博客教程（hexo-amp-amp-github）" class="headerlink" title="mac os搭建博客教程（hexo&amp;&amp;github）"></a>mac os搭建博客教程（hexo&amp;&amp;github）</h2><ul>
<li><p>本地安装</p>
<ul>
<li><p>homebrew(挺好用的套件管理器):ruby -e “$(curl -fsSL <a href="https://raw.githubusercontent.com/Homebrew/install/master/install" target="_blank" rel="external">https://raw.githubusercontent.com/Homebrew/install/master/install</a>)”</p>
</li>
<li><p>Node.js:brew install node</p>
</li>
<li><p>hexo:sudo npm install –unsafe-perm –verbose -g hexo </p>
</li>
<li><p>创建一个文件件名为hexo:mkdir hexo;进入目录:cd hexo</p>
</li>
<li><p>hexo init</p>
</li>
<li><p>npm install</p>
</li>
<li><p>hexo deploy</p>
</li>
<li><p>hexo server</p>
</li>
</ul>
</li>
<li>到此已经在本地搭建好了博客，后续只需要在github上利用Pages的功能托管就ok了</li>
<li>具体git以及github的使用，我会在后面的博客中提及</li>
</ul>
<h2 id="最后说点啥？"><a href="#最后说点啥？" class="headerlink" title="最后说点啥？"></a>最后说点啥？</h2><p>&#160;&#160;&#160;&#160;真的很久很久很久没写能成文的字了，现在往回看，好像确实挺low的。anyway，反正也没几个人看。慢慢改进吧，第一篇文章弄了一上午，先去吃饭了。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/一本正经/">一本正经</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/胡说八道/">胡说八道</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/"><span></span>Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  


  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/JavaSE/" title="JavaSE">JavaSE<sup>8</sup></a></li>
		  
		
		  
			<li><a href="/categories/Linux/" title="Linux">Linux<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/一本正经/" title="一本正经">一本正经<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/工具/" title="工具">工具<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/算法/" title="算法">算法<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/计算机网络/" title="计算机网络">计算机网络<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/设计模式/" title="设计模式">设计模式<sup>3</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/多线程/" title="多线程">多线程<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/学习笔记/" title="学习笔记">学习笔记<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/胡说八道/" title="胡说八道">胡说八道<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/算法/" title="算法">算法<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Maven/" title="Maven">Maven<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/java8/" title="java8">java8<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/http协议/" title="http协议">http协议<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/https协议/" title="https协议">https协议<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Linux/" title="Linux">Linux<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Shell/" title="Shell">Shell<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/编程题/" title="编程题">编程题<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/策略模式/" title="策略模式">策略模式<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/设计模式原则/" title="设计模式原则">设计模式原则<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/模版方法模式/" title="模版方法模式">模版方法模式<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/内部类/" title="内部类">内部类<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">Weibo</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=2831891302&verifier=a2b6ee82&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Lujunqiu.This is my blog. <br/>
			As Kobe said,Somebody has to win, so why not be me?</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/2831891302" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2017 
		
		<a href="/about" target="_blank" title="Lujunqiu">Lujunqiu</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
